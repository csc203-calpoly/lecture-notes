<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Cal Poly CSC 203 Lecture notes</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Cal Poly CSC 203 Lecture notes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<blockquote>
<p>This introduction covers some Java language syntax relatively quickly, assuming programming proficiency at the level one would expect after an introductory college programming class.</p>
</blockquote>
<h2 id="data-types-in-java"><a class="header" href="#data-types-in-java">Data types in Java</a></h2>
<p>Since many of you are likely coming from a Python background, some of this discussion will refer back to commonalities and differences between Java and Python. If you have no Python experiences, that is fine. We do not assume Python knowledge.</p>
<p>We'll work through the <code>JavaSample.java</code> file in this lecture.
Due to some language features in Java, I will sometimes ask you to ignore certain keywords for the time being.
I only do this because I will explain what those mean later when we get to those topics.
By the end of the quarter, there won't be keywords we see in class that I'll ask you to ignore.</p>
<h3 id="static-typing"><a class="header" href="#static-typing">Static typing</a></h3>
<p><strong>Java is a <em>statically typed</em> language.</strong> What does this mean? It means that before you can <em>run</em> Java code, a <em>compiler</em> checks that variables and values are used in ways that are consistent with their data types.</p>
<p>For example, consider the following expression:</p>
<pre><code class="language-java">"foobar" / 10
</code></pre>
<p>It attempts to divide the text <code>"foobar"</code> by the number <code>10</code>, which is a meaningless operation.
The above expression would result in errors in statically-typed languages (like Java) as well as in dynamically-typed languages (like Python).
But exactly <em>when</em> those errors occur is different between the two languages.</p>
<p>In a dynamically-typed language like Python, the program would begin to run, encounter the expression above, and then crash with an error message.
That is, the error appears <em>at run time</em>.</p>
<p>In a statically-typed language like Java, before the program runs, the <strong>compiler</strong> checks the program for erroneous uses of values like we see above.
If the compiler finds any errors, you must fix them before you're able to run the program.</p>
<p>If the code has type errors like this, the code will not execute at all.</p>
<p>A statically-typed language like Java helps us catch these errors at <em>compile time</em> instead of at <em>run time</em>.
There is ongoing debate about whether statically-typed languages are better than dynamically-typed languages, and also what "better" means.</p>
<p>Proponents of statically-typed languages argue that programming is less error-prone with static typing, particularly in large codebases or in codebases where the developer is unfamiliar with the code (i.e., they didn't write it themselves).</p>
<p>Proponents of dynamically-typed languages argue that programming becomes less verbose and more flexible, and that a good test suite can catch most of the type-related errors that a compiler would flag.<sup class="footnote-reference" id="fr-compiler-test-suite-1"><a href="#footnote-compiler-test-suite">1</a></sup></p>
<h3 id="declaring-and-initialising-variables"><a class="header" href="#declaring-and-initialising-variables">Declaring and initialising variables</a></h3>
<p>You may already know what it means to <em>declare</em> and <em>initialise</em> variables using whatever language you're coming from, but we will revisit this vocabulary briefly.</p>
<ul>
<li>When you <strong>declare</strong> a variable, you are creating it, i.e., you are saying that there is now a variable with the given name.</li>
<li>When you <strong>initialise</strong> a variable, you are giving that variable an initial value.</li>
<li>When you <strong>assign</strong> a value to a variable, you are giving it a value, potentially replacing its previous value.</li>
</ul>
<p>When you declare a variable in Java, you must also say what its <em>data type</em> is.</p>
<p>A <em>data type</em> defines two things:</p>
<ul>
<li>A set of allowed values</li>
<li>A set of allowed operations on those values</li>
</ul>
<p>For example:</p>
<pre><code class="language-java">int z;
</code></pre>
<p>The variable <code>z</code> above can now <em>only</em> hold integer values.
Its set of allowed values are all the integers (<a href="01_intro_to_java/index.html#primitive-types-and-reference-types">up to certain minimum and maximum values</a>).
Its type also dictates that we can only perform "integer-friendly" operations using its value, like math operations or printing.
We can't do things like turn it to "upper case", because that doesn't make sense for an integer.</p>
<pre><code class="language-java">z = "this isn't a number!"; // this code will not compile
z = 10; // this will be fine
</code></pre>
<p>You can also declare and initialize a variable in the same line (and will usually do this).</p>
<pre><code class="language-java">int z = 10;
int y = -12;

z = 12; // you can update z's value
</code></pre>
<h3 id="primitive-types-and-reference-types"><a class="header" href="#primitive-types-and-reference-types">Primitive types and reference types</a></h3>
<p>There are eight basic or <em>primitive</em> data types in Java:</p>
<div class="table-wrapper"><table><thead><tr><th>Data type</th><th>Description</th><th>Allowed values</th></tr></thead><tbody>
<tr><td><code>byte</code></td><td>A 1-byte integer.<br>We will not use this type in this course.</td><td>-128 to 127 (inclusive)</td></tr>
<tr><td><code>short</code></td><td>A 2-byte integer.<br>Use this when you are working in limited memory environments and or you aren't working with huge numbers.</td><td>-32,768 to 32,767 (inclusive)</td></tr>
<tr><td><code>int</code></td><td>A 4-byte integer.<br>An integer literal (e.g., directly typing <code>12</code> or <code>4305</code>) will default to using the <code>int</code> type.</td><td>$$-2^{31}$$ to $$2^{31}-1$$ (inclusive)</td></tr>
<tr><td><code>long</code></td><td>An 8-byte integer.<br>Use this when you need larger numbers than <code>int</code> can support.<br>An an <code>L</code> after a number to indicate that you mean for it to be a <code>long</code>, i.e., <code>256L</code> will be a <code>long</code> value and not an <code>int</code> value.</td><td>$$-2^{63}$$ to $$2^{63}-1$$ (inclusive)</td></tr>
<tr><td><code>float</code></td><td>A 4-byte floating point number.<br>To indicate that a decimal value is a <code>float</code>, add an <code>F</code> after it, i.e., <code>12.5F</code>.</td><td>Beyond the scope of this course.</td></tr>
<tr><td><code>double</code></td><td>An 8-byte floating point number.<br>Simply using a decimal value (e.g, <code>12.5</code>) will default to using the <code>double</code> type.</td><td>Beyond the scope of this course.</td></tr>
<tr><td><code>boolean</code></td><td>Track true/false conditions.</td><td><code>true</code> or <code>false</code></td></tr>
<tr><td><code>char</code></td><td>A single 2-byte character.<br>For example, <code>'A'</code> or <code>'#'</code> (single-quotes must be used).</td><td><code>\u0000</code> (or 0) to <code>\uffff</code> (or 65535)</td></tr>
</tbody></table>
</div>
<p>There are also <em>reference</em> types, for example the <code>String</code> type.</p>
<blockquote>
<p>Reference types are abstractions created for programming convenience.
They are built using primitive types or other reference types as building blocks.</p>
</blockquote>
<p>The most commonly used reference type in Java is the <code>String</code> type.
It stores <em>text</em>.
The <code>String</code> type "strings together" a bunch of characters to make a longer piece of text.</p>
<p>You can declare and initialise a <code>String</code> variable like below.
Notice the double-quotes!
In Java, single-quotes are reserved for the <code>char</code> type. You must use double-quotes for <code>String</code>s.</p>
<pre><code class="language-java">String course = "CSC 203";
</code></pre>
<p>The "value" of a variable that is declared as a reference type is a <em>reference</em> to the data stored somewhere in memory.
Hence the name.
You can have multiple references to the same data.</p>
<p>Consider the following code:</p>
<pre><code class="language-java">String course = "CSC 203";
String courseAgain = course;
</code></pre>
<p>When the program runs, you have now a <code>course</code> variable that points to the value <code>"CSC 203"</code>, and another variable <code>courseAgain</code> that points to the <em>same</em> value.</p>
<pre class="mermaid">flowchart LR
    course --&gt; v[&quot;CSC 203&quot;]
    courseAgain --&gt; v
</pre>
<h3 id="reference-types-and-equality"><a class="header" href="#reference-types-and-equality">Reference types and equality</a></h3>
<p>There are implications to this.</p>
<p>Consider the <code>==</code> operator ("double equals").</p>
<p>For the 8 primitive types mentioned above, the behaviour of the <code>==</code> operator is pretty much what you'd expect.</p>
<pre><code class="language-java">int a = 10;
int b = 12;

System.out.println(a == b); // This will print false.
System.out.println(a == 10); // This will print true.

char theLetterA = 'a';
char theLetterAAgain = 'a';

System.out.println(theLetterA == theLetterAAgain); // This will print true.
</code></pre>
<p><em>However, for reference types, this operator's behaviour differs between Java and Python.</em></p>
<p>For reference types, the <code>==</code> operator checks whether the two operands are the <em>same</em> (as in, physically the same item in memory), and not whether they are <em>equal</em> according to some logical rule for equality.</p>
<p><strong>Example</strong>. Suppose we have two <code>Point</code> objects, representing points in 2-dimensional space.</p>
<p>(We will talk more about <code>Point</code>s later—those details are less relevant for this example.)</p>
<p>In the example below, we use the <code>new</code> keyword to create two new <code>Point</code> objects.</p>
<pre><code class="language-java">Point p1 = new Point(1, 2); // A point at coordinates (1, 2).
Point p2 = new Point(1, 2); // Another point at coordinates (1, 2).
</code></pre>
<p>Here is a figure depicting the above situation:</p>
<pre class="mermaid">flowchart LR
p1 --&gt; v1[&quot;(1, 2)&quot;]
p2 --&gt; v2[&quot;(1, 2)&quot;]
</pre>
<blockquote>
<p><strong>PONDER</strong></p>
<p>What would the expression <code>p1 == p2</code> result in? <code>true</code> or <code>false</code>?</p>
</blockquote>
<details markdown="1">
<summary>Answer</summary>
The answer is `false`, because the `==` operator checks *sameness*, not *equality*.
Because `p1` and `p2` are *reference types*, each of those variables is pointing to a different location in memory.
</details>
<p>Now, you and me and everyone else understands that if two points have the same <code>x</code> and <code>y</code> coordinates, they should probably be considered equal.</p>
<p>That is why all reference types provide an <code>equals</code> function, which checks <em>equality</em> (using some logical definition of equality) rather than <em>sameness</em>.</p>
<p>We can use it as follows:</p>
<pre><code class="language-java">Point p1 = new Point(1, 2);
Point p2 = new Point(1, 2);

Point p1Again = p1; // p1Again and p1 are both pointing to the same Point.
</code></pre>
<p>Here's a figure depicting the above situation:</p>
<pre class="mermaid">flowchart LR
p1 --&gt; v1[&quot;(1, 2)&quot;]
p2 --&gt; v2[&quot;(1, 2)&quot;]
p1Again --&gt; v1
</pre>
<blockquote>
<p><strong>PONDER</strong></p>
<p>Considering the variable assignments above, what do you think would be the values of the following expressions?</p>
<ul>
<li><code>p1 == p2</code></li>
<li><code>p1 == p1Again</code></li>
<li><code>p1.equals(p2)</code></li>
</ul>
</blockquote>
<p>Consider the expressions above and check your answers below.</p>
<details>
<summary>Answers</summary>
<ul>
<li><code>p1 == p2</code> is <code>false</code>, because <code>p1</code> and <code>p2</code> are not pointing to the same object.</li>
<li><code>p1 == p1Again</code> is <code>true</code>, because <code>p1</code> and <code>p1Again</code> <em>are</em> pointing to the same object.</li>
<li><code>p1.equals(p2)</code> is <code>true</code>, because <code>p1</code> and <code>p2</code> are logically equal objects (they have equal <code>x</code> and <code>y</code> coordinates)</li>
</ul>
</details>
<h4 id="string-equality"><a class="header" href="#string-equality">String equality</a></h4>
<p>Strings are special type of reference type.
They are so commonly used that Java provides a specialized syntax for creating a new String without using the <code>new</code> keyword.</p>
<pre><code class="language-java">String make = "Santa Cruz";
String model = "Bronson";
</code></pre>
<p>Since they are reference types, you should compare Strings for equality using the <code>equals</code> function, and <em>not</em> the <code>==</code> operator.</p>
<p>However, the Java compiler is smart enough to SOMETIMES recognise when multiple <code>String</code> variables hold the same <code>String</code> value.
It will therefore <em>intern</em> or cache the String value.
Each additional <code>String</code> variable with the same value will point to the same <code>String</code> in memory.</p>
<p>This means that, sometimes, the <code>equals</code> function and the <code>==</code> operator will have similar behaviour for <code>String</code>s, even though <code>String</code> is a reference type.</p>
<pre><code class="language-java">String csc203 = "CSC 203";
String csc203Again = "CSC 203";

System.out.println(csc203.equals(csc203Again)); // This will print true, as expected.
System.out.println(csc203 == csc203Again); // This will also print true.
</code></pre>
<p>However, this is a compiler optimisation, and you should not rely upon it.
You can't predict when <code>==</code> and <code>equals</code> will behave the same for <code>String</code>s, so you should still use <code>equals</code> to compare <code>String</code>s for equality.</p>
<h2 id="arrays"><a class="header" href="#arrays">Arrays</a></h2>
<p>To store a collection of items in Java, the simplest collection you can use is an <em>array</em>.
Two things are important to know about arrays:</p>
<ul>
<li>Their types are fixed. You can't mix types in an array.</li>
<li>Their sizes are fixed. An array can't grow or shrink after its initial creation.</li>
</ul>
<p>Here is how to declare and initialize an integer array with some data:</p>
<pre><code class="language-java">int[] scores = {83, 43, 77, 92, 73, 95, 81, 42};
</code></pre>
<p>Arrays are <em>0-indexed</em>, which means that the first item in the array is at position 0, the second is at position 1, etc.</p>
<p>You can use box brackets (<code>[</code> and <code>]</code>) to <em>index into</em> an array, i.e., access a particular position in an array.
You can use this syntax to <em>read</em> data from an array, or <em>write</em> data to the array.</p>
<pre><code class="language-java">int[] scores = {83, 43, 77, 92, 73, 95, 81, 42};

// Reading data
System.out.println(scores[0]); // This will print the value 83
System.out.println(scores[7]); // This will print the value 42

// Writing data
System.out.println(scores[1]); // This will print the value 43.
scores[1] = 37;
System.out.println(scores[1]); // This will now print 37.
</code></pre>
<p>If you try to look at a position that's beyond the bounds of the array's size, your program will crash (i.e., there will be an error at run time).</p>
<pre><code class="language-java">int[] scores = {83, 42, 77, 92, 73, 95, 81, 42};

System.out.println(scores[11]); // There is no position 11. This program will crash.
</code></pre>
<p>Remember that arrays sizes are fixed! You can't grow the array beyond its initial size.</p>
<pre><code class="language-java">int[] scores = {83, 42, 77, 92, 73, 95, 81, 42};
scores[8] = 78; // There is no position 8. This program will crash.
</code></pre>
<p>Similar to variables, you can also declare an array without initializing it.</p>
<pre><code class="language-java">int[] scores; // without initialization
</code></pre>
<p>You can also declare an array and <em>fix its size</em>, but not specify its contents.</p>
<pre><code class="language-java">int[] scores = new int[4]; // A new array of size 4
</code></pre>
<p>The above line created an array <code>scores</code> of size 4. But we didn't specify the contents of this array.
However, the array is not "empty"—there is no such thing as an empty array in Java.</p>
<p>When you create an array, you're allocating that amount of contiguous space for its contents.
So, whether or not you declare the contents of the array, that space is allocated.</p>
<p>What's sitting in that space?</p>
<h3 id="default-values"><a class="header" href="#default-values">Default values</a></h3>
<p>Java has sort of "placeholder" values for all data types. They are referred to as their <em>default</em> values. So if you create an array but don't declare its contents, Java places the default values for that type in the array.</p>
<p>Here are the default values for all the primitive types:</p>
<div class="table-wrapper"><table><thead><tr><th>Data type</th><th>Default value</th></tr></thead><tbody>
<tr><td><code>byte</code></td><td><code>0</code></td></tr>
<tr><td><code>short</code></td><td><code>0</code></td></tr>
<tr><td><code>int</code></td><td><code>0</code></td></tr>
<tr><td><code>long</code></td><td><code>0L</code></td></tr>
<tr><td><code>float</code></td><td><code>0.0F</code></td></tr>
<tr><td><code>double</code></td><td><code>0.0</code></td></tr>
<tr><td><code>boolean</code></td><td><code>false</code></td></tr>
<tr><td><code>char</code></td><td><code>\u000</code> (or 0)</td></tr>
</tbody></table>
</div>
<p>All reference types like <code>String</code> or <code>Point</code> or others we learn about have the same default value.
It is a special value in Java called <code>null</code>.
When a variable's "value" is <code>null</code>, it means that the variable is "pointing to nothing".</p>
<h2 id="control-flow"><a class="header" href="#control-flow">Control flow</a></h2>
<h3 id="conditionals"><a class="header" href="#conditionals">Conditionals</a></h3>
<p>Java uses <code>if</code>, <code>else if</code>, and <code>else</code> for conditional logic.</p>
<p>Unlike Python, Java does not use indentation to denote <em>scope</em>. We use curly braces to denote what happens inside each clause of the "if-else ladder" below.</p>
<p>However, you should still use appropriate indentation to improve readability.</p>
<pre><code class="language-java">Point p1 = new Point(1, 2);
Point p2 = new Point(1, 2);

if (p1 == p2) {
    // The above condition is false, so this line will not execute.
    System.out.println("Condition 1");
} else if (p1 == new Point(1, 2)) {
    // The above condition is also false, so this line will not execute, either.
    System.out.println("Condition 2");
} else {
    // This is the "otherwise" clause.
    System.out.println("Condition 3");
}
</code></pre>
<h3 id="repetition-looping"><a class="header" href="#repetition-looping">Repetition ("looping")</a></h3>
<p>There are 4 looping constructs in Java.</p>
<p>In most cases, any looping construct can be used to perform any task involving repetition.
But the different types of loops are provided as "syntactic sugar"—each loop type is "nicer" (more intuitive, less error-prone, etc.) to use for some tasks than others.</p>
<h4 id="the-for-loop"><a class="header" href="#the-for-loop">The <code>for</code> loop</a></h4>
<p>Use this when you want to do something repeatedly a certain number of times.</p>
<p>The <code>for</code> loop has 3 main pieces:</p>
<ul>
<li>The counter variable: <code>int i = 0</code>  in the example below. This statement runs once <em>before</em> the entire loop.</li>
<li>The looping condition: <code>i &lt; 10</code> in the example below. The loop will keep repeating as long as this condition is <code>true</code>.</li>
<li>The counting step: <code>i++</code> in the example below. This is shorthand for <code>i = i + 1</code>. This statement runs <em>after</em> each iteration of the loop.</li>
</ul>
<pre><code class="language-java">for (int i = 0; i &lt; 5; i++) {
    System.out.println(i);
}
</code></pre>
<p>The code above will print</p>
<pre><code>0
1
2
3
4
</code></pre>
<p>You can use the <code>for</code> loop to step through (or <em>iterate over</em>) an array.</p>
<pre><code class="language-java">int[] scores = {83, 43, 77, 92, 73, 95, 81, 42};

for (int i = 0; i &lt; scores.length; i++) {
    System.out.println(scores[i]);
}
</code></pre>
<p>Because <code>i</code> runs through the values <code>0</code> through <code>7</code>, we can use <code>i</code> to access elements from the <code>scores</code> array.
The code above would print</p>
<pre><code>83
43
77
92
73
95
81
42
</code></pre>
<p>There is a lot of "surface area" for potential errors in these kinds of loops.
For example, you could mess up the starting value of <code>i</code> (should it be <code>0</code> or <code>1</code>?) or the looping condition (should it be <code>i &lt; scores.length</code>, <code>i &lt;= scores.length</code>?).</p>
<p>So for iteration, we use another looping construct: the <code>for-each</code> loop.</p>
<h4 id="the-for-each-loop"><a class="header" href="#the-for-each-loop">The <code>for-each</code> loop</a></h4>
<p>The <code>for-each</code> loop takes care of the details of stepping through a collection for us.</p>
<pre><code class="language-java">int[] scores = {83, 43, 77, 92, 73, 95, 81, 42};

for (int item : scores) {
    System.out.println(item);
}
</code></pre>
<p>In the loop above, the <code>item</code> variable steps through the <code>scores</code>  array and updates in each step, stopping when you run out of items.</p>
<p>You can read the loop above as "for each item in scores".</p>
<p>It'll print:</p>
<pre><code>83
43
77
92
73
95
81
42
</code></pre>
<h4 id="the-while-loop"><a class="header" href="#the-while-loop">The <code>while</code> loop</a></h4>
<p>The "simplest" kind of loop. It simply keeps on running as long as the given condition is <code>true</code>.</p>
<p>You typically use this loop when you don't know how many times the loop is going to run beforehand.
For example, if you are reading lines from a file, and you want to keep reading it line-by-line as long as there are more lines to be read.</p>
<pre><code class="language-java">while (fileStillHasLines) {
    // Get the next line. Assume this function exists for this example.
    String line = nextLine();
    System.out.println(line);
}
</code></pre>
<p>It's important to know that the looping condition will <em>eventually</em> be <code>false</code>, otherwise your code will go into an infinite loop and the program will never progress or end.</p>
<p>This is useful when you want to perform an action 0-to-many times, depending on some condition.</p>
<h4 id="the-do-while-loop"><a class="header" href="#the-do-while-loop">The <code>do-while</code> loop</a></h4>
<p>This loop functions just like the <code>while</code> loop, except for one difference.
The <code>while</code> loop checks the looping condition <em>before</em> each iteration.
The <code>do-while</code> loop checks the looping condition <em>after</em> each iteration.</p>
<pre><code class="language-java">do {
    // Suppose, for example, our file is guaranteed to have at least one line.
    String line = nextLine();
    System.out.println(line);
} while (fileStillHasLines);
</code></pre>
<p>This can be a useful loop to use in cases where you want to perform an action <em>at least once</em>, and then repeat based on some condition.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-compiler-test-suite">
<p>You can think of the compiler as a type of limited test suite. Instead of checking functional correctness, it checks for syntax and, in statically-typed languages, type-related correctness. <a href="#fr-compiler-test-suite-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="arithmetic-and-testing"><a class="header" href="#arithmetic-and-testing">Arithmetic and testing</a></h1>
<blockquote>
<p>This brief lesson is about arithmetic in Java.
In the <a href="02_arithmetic_and_testing/../01_intro_to_java/">previous lesson</a>, we learned the different <em>primitive data types</em> in Java, including the numerical data types <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, and <code>double</code>.</p>
</blockquote>
<p>In this lesson we'll establish some rules of evaluation for expressions involving these types.</p>
<p>By <em>expression</em>, I mean anything that evaluates to a value. For example <code>3 + 5</code> is an expression that evaluates to the value <code>8</code>. <code>"why are you yelling".toUpperCase()</code> is an expression that evaluates to the value <code>"WHY ARE YOU YELLING"</code>.</p>
<h2 id="arithmetic-operators"><a class="header" href="#arithmetic-operators">Arithmetic operators</a></h2>
<p>Ok, so. Arithmetic. We already know a few arithmetic operators:</p>
<ul>
<li><code>+</code> for addition</li>
<li><code>-</code> for subtraction</li>
<li><code>*</code> for multiplication</li>
<li><code>/</code> for division</li>
<li><code>%</code> for modulo division (to obtain the remainder from a division operation)</li>
</ul>
<p>All of these are <em>binary operators</em>. This means that each operator works on two <em>operands</em>. So in the expression <code>3 + 5</code>, <code>3</code> and <code>5</code> are operands, and <code>+</code> is the operator.</p>
<p>Unlike Python, which you learned in CSC 101 and 202, there is no <code>**</code> (exponentiation) or <code>//</code> (floor division) operator.
The two slashes (<code>//</code>) are reserved for inline comments in Java.</p>
<h2 id="arithmetic-involving-operands-of-the-same-type"><a class="header" href="#arithmetic-involving-operands-of-the-same-type">Arithmetic involving operands of the same type</a></h2>
<p><strong>When both operands in a binary expression are of the same type, then the result will also be of that type.</strong></p>
<p>In the examples below, remember from the <a href="02_arithmetic_and_testing/../01_intro_to_java/index.html">previous lesson</a> that when you simply use the literal values <code>5</code> and <code>2</code>, Java treats them as the <code>int</code> type (as opposed to the <code>short</code> or <code>long</code> type).
So the expressions below are all using <code>int</code> operands.</p>
<pre><code class="language-java">int addResult = 5 + 2; // 7
int subResult = 5 - 2; // 3
int multResult = 5 * 2; // 10
int modResult = 5 % 2; // 1
</code></pre>
<p>So far so good.</p>
<p>But what if we start playing with division? Consider the expression <code>5 / 2</code>. If we were in a math class, the answer would be <code>2.5</code>, which is certainly not an integer.</p>
<pre><code class="language-java">int divResult = 5 / 2; // What's the value of divResult?
</code></pre>
<p>Open up a terminal window and type <code>jshell</code> and hit enter.</p>
<p>This will place you in a Java shell, a place where you can run small Java programs, including testing out individual expressions.</p>
<p>Use <code>jshell</code> to evaluate the expression <code>5 / 2</code>.</p>
<pre><code class="language-bash">jshell
jshell&gt; 5 / 2
$1 ==&gt; 2
</code></pre>
<p>You got the result 2!</p>
<p>However, if we were to divide <code>5.0 / 2.0</code>, we'd get the expected answer.</p>
<pre><code class="language-bash">jshell&gt; 5.0 / 2.0
$2 ==&gt; 2.5
</code></pre>
<p>Remember that <code>5 / 2</code> is an <code>int / int</code> expression.
Per our rule above, Java is going to therefore produce an <code>int</code> in return.
A <code>double / double</code> expression, on the other hand, will result in a value of type <code>double</code>.</p>
<p>When the result of an integer division in Java is a fractional number (i.e., it has a decimal point), Java simply omits or <em>truncates</em> everything after the decimal point.</p>
<p>So the value of the expression <code>5 / 2</code> is <code>2</code>.</p>
<p>Note that simply changing the type of our result variable won't help.</p>
<pre><code class="language-java">double divResult = 5 / 2; // Answer 2.0
</code></pre>
<p>Tracing the code above, it does the following:</p>
<ul>
<li>Evaluate <code>5 / 2</code> using the rules we talked about, getting the <code>int</code> result <code>2</code>.</li>
<li>See that <code>divResult</code> is declared as a <code>double</code>, which means it cannot store the <code>int</code> value <code>2</code>.</li>
<li><em>Implicitly convert</em> the result <code>2</code> into a <code>double</code>, getting the value <code>2.0</code>, and store that instead.</li>
</ul>
<p>So how would we get the answer <code>2.5</code> by dividing <code>5</code> and <code>2</code>?</p>
<h2 id="arithmetic-involving-operands-of-different-types"><a class="header" href="#arithmetic-involving-operands-of-different-types">Arithmetic involving operands of different types</a></h2>
<p>If you used two different types in an arithmetic expression, the result takes the "more precise" type.</p>
<p>If, instead of dividing two <code>ints</code>, you divided an <code>int</code> and a <code>double</code>, you would get a <code>double</code> in return.
Because at least one operand is using the <em>more precise</em> type, the result will default to that more precise type.</p>
<p>The expression below, <code>5 / 2.0</code> is a <code>int / double</code> expression.
So the result will be a <code>double</code>, which is the more precise data type of the two.</p>
<pre><code class="language-java">double mixedDiv = 5 / 2.0; // Answer: 2.5
</code></pre>
<p>The same goes for using the different <em>integer types</em>.</p>
<p>Remember that both <code>int</code> and <code>long</code> are integer data types.
If you add an <code>int</code> and a <code>long</code> (or perform any operation between an <code>int</code> and a <code>long</code>), you'll get a <code>long</code> in return.
This is because the <code>long</code> is the more precise type (it takes up more memory, allowing for a larger range of numbers).</p>
<pre><code class="language-java">long longAdd = 5 + 8L; // Will get the value 13 as a long
</code></pre>
<p>Attempting to store the result above in an <code>int</code> will result in a compiler error.</p>
<pre><code class="language-java">int add = 5 + 8L; // Error: incompatible types: possible lossy conversion from long to int
</code></pre>
<p>And this makes sense. Suppose we evaluated the expression <code>5 + 2147483647L</code> (5 plus the maximum possible <code>int</code> value). We cannot possibly the store result in an <code>int</code> variable—it's too big!</p>
<h2 id="type-casting"><a class="header" href="#type-casting">Type casting</a></h2>
<p>Finally, you can tell your compiler to treat certain values as other types instead of their own types.
This is known as <em>type-casting</em>.
You are "casting" or converting a specific value into another type.</p>
<p>A type-cast is performed by typing the name of the type you want to convert <em>to</em> in parentheses before the value you want to convert.</p>
<pre><code class="language-java">int basicInt = 5;
double nowItsADouble = (double) basicInt; // becomes 5.0
</code></pre>
<p>You can also lose data this way!</p>
<pre><code class="language-java">double basicDouble = 5.2;
int nowItsAnInt = (int) basicDouble; // becomes 5; you lost the .2
</code></pre>
<p>Type-casting can be used when you have two integer values that you need to divide, but you need a precise result.</p>
<pre><code class="language-java">int a = 132;
int b = 25;

double result = (double) a / b; // The result is 5.28
</code></pre>
<p>Tracing the code above, the following takes place:</p>
<ul>
<li>First, the expression <code>(double) a / b</code> needs to be evaluated. It is made up of two sub-expressions: <code>(double) a</code> and <code>b</code>.</li>
<li>We evaluate the expression <code>(double) a</code>. The value of <code>a</code> is <code>132</code>, so applying the type-cast to 132, we get <code>132.0</code>.</li>
<li>The sub-expression <code>b</code> evaluates to <code>25</code>.</li>
<li>We are now ready to evaluate the overall expression <code>132.0 / 25</code>, and we get the value <code>5.28</code>.</li>
</ul>
<p>In the example above, <code>a</code> was cast to a <code>double</code> before performing the division.
So it became a <code>double / int</code> operation, giving a <code>double</code> back as a result.</p>
<p><strong>Type-casting is a unary operation.</strong></p>
<p>Unlike the arithmetic operators we saw earlier, which were <em>binary operators</em> (i.e., they applied to 2 operands), type-casting is a <em>unary operator</em>. It applies to <em>only one operand</em>.</p>
<p>The type-cast will be applied to the value on the right of the type-cast operator (i.e., the data type you want to convert to).</p>
<p>Consider the following expressions and the steps involved in evaluating them:</p>
<ul>
<li>
<p><code>(double) 132 / 25</code></p>
<ul>
<li>The steps of evaluation are described above</li>
</ul>
</li>
<li>
<p><code>(double) (132 / 25)</code></p>
<ul>
<li>Here, because we've enclosed the division expression in parentheses, it takes precedence. <code>(132 / 25)</code> is evaluated first.</li>
<li>So as an intermediate expression we get <code>(double) (5)</code>. <strong>Can you think why this is?</strong></li>
<li>The final value of the expression above will then be <code>5.0</code>, because the type-cast was applied to the value <code>5</code>.</li>
</ul>
</li>
</ul>
<p><strong>Finally, type-casting applies only to values, not to variables.</strong></p>
<p>Since Java is a statically-typed language, <em>you can never change the data type of a variable</em>.
You can only change the type of a value for use in a particular statement or expression.</p>
<p>Consider the same example from above.</p>
<pre><code class="language-java">int a = 132;
int b = 25;

double result = (double) a / b;
</code></pre>
<p>In the code above, the type-cast only applies to the <em>value</em> <code>132</code> within the expression. The data type of <code>a</code> has not changed, and future uses of <code>a</code> will still evaluate to <code>132</code>, <em><strong>not</strong></em> <code>132.0</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lists-maps-and-existing-classes"><a class="header" href="#lists-maps-and-existing-classes">Lists, maps, and existing classes</a></h1>
<blockquote>
<p>In this lecture we will get a first look at <em>Classes and objects</em> in Java. Following this we'll look at some classes that are available in the Java standard library, specifically <em>Lists</em> and <em>Maps</em>.</p>
</blockquote>
<h2 id="objects-and-classes"><a class="header" href="#objects-and-classes">Objects and classes</a></h2>
<p>A <em>class</em> is the blueprint that defines data each object has and what behaviours it can perform.
You can create many individual objects using the same class.
These objects are called <em>instances</em> of the class.</p>
<p><em>Objects</em> are "boxes" of related pieces of data and behaviours that use those bits of data.</p>
<p>For example, consider the <a href="https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/lang/String.java"><code>String</code> class</a> in Java.
If you follow that link, you'll see a lot of comments and other things that will look unfamiliar (at least for these first few weeks).
But fundamentally, the <code>String</code> class defines the following</p>
<ul>
<li>All <code>String</code>s have an array of characters (data).</li>
<li>All <code>String</code>s have a bunch of actions they can perform using that array of characters (behaviours). For example, they can turn the characters to upper case or lower case, search the array for a specific sub-string of characters, or remove and replace specific characters with other ones.</li>
</ul>
<p>The <code>String</code> class, by defining the data and behaviours like the above, allows us to create <code>String</code> <em>objects</em>, each of which has its own array of characters, and its own behaviours it can perform using its array of characters.</p>
<p>In the figure below, the (super-simplified) <code>String</code> class defines the data (<code>value</code>) and behaviours that all <code>String</code>s should have.
Then we used that class to create two <em>instances</em> of <code>String</code>, i.e., two objects.
Each of those objects have their own bit of data called <code>value</code> (in this case, an array of characters), and can perform actions using that <code>value</code>.</p>
<p><img src="03_lists_maps_existing_classes/class-object.png" alt="A simplified String class and two example instances" /></p>
<p>See the example in code:</p>
<pre><code class="language-java">String firstString = "csc 203";
String secondString = "Object-oriented Programming";
</code></pre>
<p>The two variables <code>firstString</code> and <code>secondString</code> are both made out of the same <code>String</code> class, but they are two different objects, i.e., two distinct <em>instances</em> of the <code>String</code> class.</p>
<h3 id="instance-methods"><a class="header" href="#instance-methods">Instance methods</a></h3>
<p>We can tell the objects to perform certain actions. This can be done by using the <em>dot operator</em> (<code>.</code>) and saying the name of the action we want to take.</p>
<pre><code class="language-java">String firstString = "csc 203";
String secondString = "Object-oriented Programming";

String firstUpperCased = firstString.toUpperCase();
</code></pre>
<p>After the code above runs, the <code>firstUpperCased</code> variable will have the value <code>"CSC 203"</code>, because the <code>toUpperCase</code> action gives back the value of the <code>String</code> with its characters in upper-case.</p>
<p>These actions can each object can perform are called <em>instance methods</em>.
Instance methods act on particular objects, or <em>instances</em> of the class.
Notice that the expression <code>firstString.toUpperCase()</code> is totally unaffected by the value of <code>secondString</code>.
Hence the name.</p>
<p><strong>What do you think would be the value of the following expressions?</strong></p>
<ul>
<li><code>secondString.toUpperCase()</code></li>
<li><code>firstString.toUpperCase().toLowerCase()</code></li>
</ul>
<h2 id="a-code-example"><a class="header" href="#a-code-example">A code example</a></h2>
<p>Consider the following class definition. It defines a class that holds data representing a cohort of CS students, and some behaviours that each cohort object can perform using its own data.</p>
<p>Take some time to study the code below and its accompanying annotations.</p>
<p>
<div style="width: 100%; margin: auto;">
  <small>
    <a href="03_lists_maps_existing_classes/CsCohort.html" target="_blank">
      View in new tab
    </a>
    &nbsp;and then click <b>Walkthrough</b>.
  </small>
  <br/>
  <object data="CsCohort.html" width="100%" height="900px"></object>
</div>
</p>
<h2 id="encapsulation-or-information-hiding"><a class="header" href="#encapsulation-or-information-hiding">Encapsulation, or information hiding</a></h2>
<p>Consider the <code>getYear</code>, <code>setYear</code>, <code>getEnrolled</code>, <code>getRetainedPercent</code>, <code>setRetainedPercent</code> methods above.
They don't do much beyond getting or setting the values of the appropriate variables.
These are called <em>getter methods</em> (or <em>accessors</em>) and <em>setter methods</em> (or <em>mutators</em>).
Because they are marked as <code>public</code> methods, they are visible to other classes, which means other classes can <em>get</em> or <em>set</em> the cohort's <code>year</code> and so on.</p>
<p>This should raise the question: why did we make the <code>year</code> (and other instance variables) <code>private</code> if we were going to expose access to those variables via <code>public</code> instance methods?</p>
<p>The answer is <em>encapsulation</em>. When we make our instance variables <code>private</code>, we hide them from the outside world. We gain the following benefits:</p>
<ul>
<li><strong>We can prevent mutations for some variables</strong>. For example, notice that <code>enrolled</code> does not have a setter method. We simply do not allow other classes to ever modify the <code>enrolled</code> value, which we could not have done if it was <code>public</code>.</li>
<li><strong>We can control mutations for some variables.</strong> In the <code>setRetainedPercent</code> method, we are able to perform some validity checks before accepting a new value for the retained percent. Specifically, because this is a percentage, we check that the input value is within the range 0–1.</li>
<li><strong>Finally, we <em>decouple</em> our class from other classes.</strong> By hiding these bits of information (as opposed to giving unfettered access to the internals of how our <code>CsCohort</code> works), we reduce the potential for <em>coupling</em> between our <code>CsCohort</code> class and other classes in our program.</li>
</ul>
<p><strong>What's coupling?</strong> If classes are <em>tightly coupled</em>, they have to change together. Each time one of the classes changes, it will force changes in other classes to accommodate the changes in the first class. When classes are <em>loosely coupled</em>, they are mostly independent. This does not mean they don't work together to make things happen; it just means that internals of the either of the classes can change without the other ever knowing about it.</p>
<p>Encapsulation helps with this. By defaulting to making our instance variables <code>private</code>, we get a lot more control over the functionality that <code>CsCohort</code> presents to other classes.</p>
<h2 id="using-existing-classes-in-java"><a class="header" href="#using-existing-classes-in-java">Using existing classes in Java</a></h2>
<h3 id="using-the-class-that-we-just-created"><a class="header" href="#using-the-class-that-we-just-created">Using the class that we just created</a></h3>
<p>We can create new instances of the <code>CsCohort</code> class like so:</p>
<pre><code class="language-java">CsCohort year1 = new CsCohort(2012, 132, .932);
CsCohort year2 = new CsCohort(2013, 172, .924);
CsCohort year3 = new CsCohort(2014, 157, .936);
CsCohort year4 = new CsCohort(2015, 172, .977);
</code></pre>
<p>Each of the variables above points to a different object.
Each object has its own data and its own behaviours that operate on that data.</p>
<p>Remember the Java memory model.
Each of those <code>CsCohort</code> variables (<code>year1</code>, <code>year2</code>, <code>year3</code>, <code>year4</code>) are <em>pointing</em> to the objects sitting somewhere else in memory.</p>
<h3 id="using-other-existing-classes-lists"><a class="header" href="#using-other-existing-classes-lists">Using other existing classes: Lists</a></h3>
<p>Now that we know what <em>classes</em>, <em>objects</em>, and <em>instance methods</em> are, let's look at some existing classes that are provided by the Java standard library.</p>
<p>We have already seen one super commonly used class: the <code>String</code> class, which can reasonably be thought of as a <em>data structure</em> whose job it is to store and manipulate sequences of characters.</p>
<p>In the rest of this lesson, we'll talk about other data structures, specifically <em>lists</em> and <em>maps</em>.</p>
<h4 id="lists"><a class="header" href="#lists">Lists</a></h4>
<p>To talk about lists, we first need to talk about arrays.</p>
<p>Recall from the first lesson that arrays are the most basic type of collection in Java.
Its key difference from the <em>lists</em> you might be used to from Python is that arrays have <em>fixed sizes</em> and <em>fixed types</em>.</p>
<p>The <em>fixed type</em> is due to Java's static type system and fondness for (some degree of) type safety. That won't change.</p>
<p>However, we often do not know upfront how big we're going to need a sequence of data to be.
Arrays can be limiting in that regard.</p>
<p>So the Java standard library provides a couple of <em>list</em> implementations that we can use.</p>
<p><strong><code>ArrayLists</code></strong></p>
<p>The <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/ArrayList.html">ArrayList</a> class is provided in the Java Standard library.
It is, essentially, a resizable array implementation.
This means you can dynamically grow and shrink the size of the list by adding items to it or removing items from it.</p>
<p>See the <code>CompareCohorts</code> class below for examples about how to create and use <code>ArrayLists</code>.</p>
<p><em>Why would we want to use an <code>ArrayList</code> instead of a regular old array?</em> Easy. Its size can be dynamically changed, which makes it much more flexible.</p>
<p><em>How does it work?</em> An <code>ArrayList</code> works by keeping track of an array behind the scenes. We call this the <em>backing array</em>. So suppose we declare and initialize an empty <code>ArrayList</code>.
According to the documentation, Java by default creates a backing array of size 10, even though we haven't added anything to the list as yet.</p>
<p>For example, we declare the <code>ArrayList</code>:</p>
<pre><code class="language-java">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
</code></pre>
<p>And this is our backing array to begin with:</p>
<div class="table-wrapper"><table><thead><tr><th>\</th><th>\</th><th>\</th><th>\</th><th>\</th><th>\</th><th>\</th><th>\</th><th>\</th><th>\</th></tr></thead><tbody>
</tbody></table>
</div>
<p>Suppose we add ten items to the list.</p>
<pre><code class="language-java">for (int i = 0: i &lt; 10; i++) {
    list.add(i);
}
</code></pre>
<p>Our list's backing array now looks like this:</p>
<div class="table-wrapper"><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody>
</tbody></table>
</div>
<p><em>What happens when we add an 11th item?</em> In a regular array, that wouldn't be possible. But an <code>ArrayList</code> allows us to do this. Here's how.</p>
<p>When the backing array becomes full, the <code>ArrayList</code> does the following:</p>
<ol>
<li>It creates a <em>new</em> backing array that's double the size of the previous one.</li>
<li>It transfers all the existing content from the old backing array into the new backing array.</li>
<li>It then adds the new item that we tried to add, that triggered this process in the first place.</li>
</ol>
<p><strong>The backing array is full, and we want to add the number <code>10</code> to the <code>ArrayList</code>.</strong></p>
<div class="table-wrapper"><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody>
</tbody></table>
</div>
<p><strong>We create a new backing array that's double the size of the old one.</strong></p>
<div class="table-wrapper"><table><thead><tr><th>\</th><th>\</th><th>\</th><th>\</th><th>\</th><th>\</th><th>\</th><th>\</th><th>\</th><th>\</th><th>\</th><th>\</th><th>\</th><th>\</th><th>\</th><th>\</th><th>\</th><th>\</th><th>\</th></tr></thead><tbody>
</tbody></table>
</div>
<p><strong>We copy the old contents into the new backing array.</strong></p>
<div class="table-wrapper"><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>\</th><th>\</th><th>\</th><th>\</th><th>\</th><th>\</th><th>\</th><th>\</th><th>\</th><th>\</th></tr></thead><tbody>
</tbody></table>
</div>
<p><strong>Finally, we add the newest bit of data to the backing array.</strong></p>
<div class="table-wrapper"><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th><strong>10</strong></th><th>\</th><th>\</th><th>\</th><th>\</th><th>\</th><th>\</th><th>\</th><th>\</th><th>\</th></tr></thead><tbody>
</tbody></table>
</div>
<p>The <code>ArrayList</code> abstracts away all of these gory details, allowing us to deal with the list as simply a dynamically sizeable linear sequence of data.</p>
<p>Because the backing data structure is an array, the <code>ArrayList</code> lets us access any arbitrary item in the list in <em>constant time</em> (\( \theta(1) \)), i.e., it takes the same amount of time no matter how large the list is.</p>
<p>However, this comes with a cost: removing or adding items to the list can take <em>linear time</em> (\( \theta(n) \)) in the worst case, because all items in the backing might need to be shifted left (after removals) or right (before additions).</p>
<p><code>LinkedLists</code></p>
<p>The other type of list that Java provides is the <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/LinkedList.html"><code>LinkedList</code></a>. We won't belabour the point here, since you likely studied <code>LinkedLists</code> in the previous class.</p>
<p>Unlike the <code>ArrayList</code>, the <code>LinkedList</code> is made up of a sequence of objects connected ("linked") by pointers.
Each item points to the next item, forming a chain of items, i.e., the linked list.</p>
<p>The <code>LinkedList</code> is used very similarly:</p>
<pre><code class="language-java">LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();
</code></pre>
<p>It even has mostly the same methods as the <code>ArrayList</code>:</p>
<ul>
<li>You can append items to the end of the list using <code>add</code>.</li>
<li>You can remove items from specified locations using <code>remove(i)</code> (where <code>i</code> is an index number).</li>
<li>You can get the <code>size</code> of the list, i.e., the number of items in the list.</li>
<li>You can check if the list contains an item using the <code>contains</code> method.</li>
<li>You can check if the list is empty by using the <code>isEmpty</code> method.</li>
</ul>
<p>So when should you use one vs. the other? Each one is better for certain kinds of tasks. The table below shows their time complexities in the worst case for various tasks.</p>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th><code>ArrayList</code></th><th><code>LinkedList</code></th></tr></thead><tbody>
<tr><td>Random access</td><td>\( \theta(1) \)</td><td>\( \theta(n) \)</td></tr>
<tr><td>Add to end (append)</td><td>\( \theta(n) \)</td><td>\( \theta(1) \)</td></tr>
<tr><td>Add to arbitrary position</td><td>\( \theta(n) \)</td><td>\( \theta(n) \) to get to the position<br>\( \theta(1) \) to add the item</td></tr>
<tr><td>Remove (from a given position)</td><td>\( \theta(1) \) to get to the position<br/>\( \theta(n) \) to remove the item and shift items in the list as appropriate</td><td>\( \theta(n) \) to get to the position<br/>\( \theta(1) \) to perform the removal</td></tr>
<tr><td>Contains</td><td>\( \theta(n) \)</td><td>\( \theta(n) \)</td></tr>
</tbody></table>
</div>
<h3 id="a-note-about-boxed-primitive-types"><a class="header" href="#a-note-about-boxed-primitive-types">A note about "boxed" primitive types</a></h3>
<p>Creating an <code>ArrayList</code> of integers or floating point values looks like this:</p>
<pre><code class="language-java">ArrayList&lt;Integer&gt; intList = new ArrayList&lt;&gt;();
</code></pre>
<p>What's up with the <code>Integer</code> in the code above? Wasn't the primitive integer type in Java called <code>int</code>?</p>
<p>In Java, all the primitive types have "boxed" versions of those types.
I.e., versions in which they masquerade as reference types.
That is, you will sometimes see:</p>
<ul>
<li><code>short</code> referred to as <code>Short</code></li>
<li><code>int</code> referred to as <code>Integer</code></li>
<li><code>long</code> referred to as <code>Long</code></li>
<li><code>double</code> referred to as <code>Double</code></li>
<li><code>float</code> referred to as <code>Float</code></li>
<li><code>char</code> referred to as <code>Character</code></li>
<li><code>boolean</code> referred to as <code>Boolean</code></li>
<li><code>byte</code> referred to as <code>Byte</code></li>
</ul>
<p>Virtually the <em>only</em> use of these "boxed" type names is in data structures like the <code>ArrayList</code> or <code>LinkedList</code>.<sup class="footnote-reference" id="fr-generics-1"><a href="#footnote-generics">1</a></sup>
But, since they exist, they also hold some useful utility functions for doing things like parsing <code>String</code>s into <code>int</code>s, etc.
For example, see some of these on the documentation page for <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Integer.html"><code>Integer</code></a>.</p>
<p>So, while code like the following will compile successfully, you will get warnings telling you to use the primitive versions of those type names.</p>
<pre><code class="language-java">// Do this
int num = 23;

// Not these
int num1 = new Integer(23);
Integer num2 = new Integer(23);
Integer num3 = 23;
</code></pre>
<h2 id="maps"><a class="header" href="#maps">Maps</a></h2>
<p>Next, we consider <em>maps</em>.
A <em>map</em> in Java is an object that maps keys to values.
Each key can map to at most one value, i.e., each key must be unique.</p>
<p>The map is not unlike the <em>dict</em> structure you may be used to in Python.</p>
<p>The commonly used map implementation in Java is the <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/HashMap.html"><code>HashMap</code></a>.</p>
<p>The <code>HashMap</code> creates a pairing from keys to values, and allows fast (constant time) access to values, provided you have the key.
This is useful when you need to quickly access individual records in a very large dataset.</p>
<p>For example, suppose you have a <code>HashMap</code> where the <em>keys</em> are social security numbers (<code>long</code>) and the <em>values</em> are <code>Person</code> objects (assuming we, at some point, created a <code>Person</code> class).</p>
<p>You can initialise the map like so (notice the use of the "boxed" form of <code>Long</code> below):</p>
<pre><code class="language-java">HashMap&lt;Long, Person&gt; mapOfPeople = new HashMap&lt;&gt;();
</code></pre>
<p>You add records into a map using the <code>put</code> method.</p>
<pre><code class="language-java">mapOfPeople.put(123, new Person("Joe", "Bro"));
mapOfPeople.put(987, new Person("Pooja", "Ahuja"));
</code></pre>
<p>Assuming you have the <em>key</em>, you can get the <em>value</em> from map using the <code>get</code> method. If the key does not exist in the map, you will get <code>null</code> in return.</p>
<pre><code class="language-java">mapOfPeople.get(123); // will return Joe Bro
mapOfPeople.get(987); // will return Pooja Ahuja
mapOfPeople.get(192); // will return null,
</code></pre>
<p>If you try to re-enter the same key, the map will <em>replace</em> whatever was there previously with the new item.</p>
<pre><code class="language-java">mapOfPeople.put(123, new Person("Joe", "Bro"));
mapOfPeople.put(987, new Person("Pooja", "Ahuja"));

// Adding using a duplicate key
// Joe Bro is now replaced by Cody Coderson
mapOfPeople.put(123, new Person("Cody", "Coderson"));
</code></pre>
<p>The <code>HashMap</code> provides the following functionality:</p>
<ul>
<li><code>put(key, value)</code></li>
<li><code>get(key)</code></li>
<li><code>getOrDefault(key, default)</code> — returns the specified <code>default</code> value instead of <code>null</code> if the <code>key</code> is not in the map</li>
<li><code>entrySet()</code> — obtains the entire set of entries from the map; this is useful if you need to do things like loop over all the map entries</li>
<li><code>isEmpty</code> — checks if the map is empty</li>
<li><code>containsKey(key)</code> — checks if the map contains the specified <code>key</code></li>
</ul>
<p>All of the concepts in this section are demonstrated in the <code>CompareCohorts</code> class below:</p>
<p>
<div style="width: 100%; margin: auto;">
  <small>
    <a href="03_lists_maps_existing_classes/CompareCohorts.html" target="_blank">
      View in new tab
    </a>
    &nbsp;and then click <b>Walkthrough</b>.
  </small>
  <br/>
  <object data="CompareCohorts.html" style="width: 100%; height: 1000px;"></object>
</div>
</p>
<hr>
<ol class="footnote-definition"><li id="footnote-generics">
<p>Or, more generally, in Generic types, which we will get to later this quarter. That is also when we'll talk about <em>why</em> these exist. <a href="#fr-generics-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="objected-oriented-programming-and-procedural-programming"><a class="header" href="#objected-oriented-programming-and-procedural-programming">Objected-oriented Programming and Procedural Programming</a></h1>
<blockquote>
<p>In this lesson, we'll compare and contrast two styles of programming, or <em>programming paradigms</em>: <strong>procedural programming</strong> and <strong>object-oriented programming</strong> (the latter being the focus of this course).</p>
</blockquote>
<p>After this lesson, you will know about:</p>
<ul>
<li>The difference between procedural and object-oriented programs</li>
<li>Constructors and overloaded constructors</li>
<li>The difference between <code>static</code> members and instance members of a class</li>
<li>The meaning and usage of the <code>this</code> keyword in Java</li>
</ul>
<h2 id="procedural-and-object-oriented-programming"><a class="header" href="#procedural-and-object-oriented-programming">Procedural and object-oriented programming</a></h2>
<p><em>Procedural programming</em> is a style of programming that focuses on providing a series of instructions to be executed.
These would the <em>statements</em> in the program.
A procedural program can also bundle up instructions into <em>functions</em> that can be used and re-used as needed.
Similarly, data can be bundled up into compound objects, simply for the purposes of packaging up related pieces of information.</p>
<p>Procedural programming was the dominant way of doing things until Object-oriented programming (OOP) was invented in the 70s and 80s.
As programming projects started to get larger and more complex, because software was quickly being integrated into many domains, software engineers started to run into problems with software maintainability.
In procedural programming, it is easy to get into a "spaghetti code" situation, where you have a large program with tons of functions operating on a number of data structures.
The onus is on the programmer to structure the program so that it would be easily readable, testable, and changeable.</p>
<p>One proposed solution was <strong>Object-oriented programming</strong> (OOP).</p>
<p>In OOP, instead of focusing our program on data and functions that operate on that data, we use <em>objects</em>, which bundle up related data and behaviours that operate on those data into <em>classes</em>.</p>
<p>Orienting our programs around objects (the argument goes) lets us modularise the various parts of a large software system, with each part only reading or affecting its own data. This leads to a number of beneficial effects:</p>
<ul>
<li>The amount of <em>global</em> data (data that is shared by multiple objects or parts of a system) is limited. By bundling up data into objects, and tending to make that data <code>private</code> by default, the programmers exerts a fair amount of control over who can see what parts of a system.</li>
<li>Because we use <code>private</code> data and <code>public</code> functions to induce this degree of separation between parts of a system, those parts are <em>decoupled</em> from each other.</li>
<li>Features we will learn later this quarter will show us that this also helps introduce a degree of <em>resilience to change</em> into our programs. Software requirements change often — if we are unable to change our software easily to meet new requirements, we're gonna have a bad time.</li>
</ul>
<p>Of course, all of the above are hypothetical. It's perfectly possible to gain all of the above benefits using procedural programming, just like it is possible to write terrible, unmaintainable programs using OOP.</p>
<p>In this class, we're going to aim to understand the higher-level principles of good software design, using OOP as a vehicle to put those principles into practice.
This does <em>not</em> mean that those principles are unique to OOP.</p>
<p>This is a good time to note a few things!</p>
<ul>
<li>There are many conflicting views about both Java and object-oriented programming.</li>
<li>This course is not meant to evangelise Java or object-oriented programming. It is <em>not</em> the "one true way" to develop maintainable software. But it is <em>one</em> way, and an important one. So it is worth learning.</li>
<li>There are other programming paradigms, which you will learn and use in other courses and, indeed, later in this course itself.</li>
</ul>
<p>Ok, let's look at examples! We'll look at the same super-simple program written in each of the two styles.</p>
<h2 id="procedural-programming"><a class="header" href="#procedural-programming">Procedural programming</a></h2>
<p>Consider the code below.</p>
<p>We have the <code>Pitcher</code> class, which is simply a bundle of data members. You can think of this as more-or-less like a <code>dict</code> in Python, or a <code>struct</code> in C.</p>
<p>The <code>Pitcher</code> class above <em>only</em> has data, and has no behaviours.
Unlike the <code>CsCohort</code> that we looked at in the previous lesson, the <code>Pitcher</code> cannot perform any actions itself, it cannot do anything using its data.
Any behaviours we want to perform must be written as separate functions — those functions will take the <code>Pitcher</code> object as a parameter, and perform actions using the <code>Pitcher</code>'s data.</p>
<p>
<div style="width: 100%; margin: auto;">
  <small>
    <a href="04_oop_and_procedural/PitcherProc.html" target="_blank">
      View in new tab
    </a>
    &nbsp;and then click <b>Walkthrough</b>.
  </small>
  <br/>
  <object data="PitcherProc.html" width="100%" height="500px"></object>
</div>
</p>
<p>Any behaviours that use the <code>Pitcher</code>'s data must be written in separate functions, which will take the <code>Pitcher</code> object as a parameter. Those are written in the <code>PitcherUtil</code> class.</p>
<p>
<div style="width: 100%; margin: auto;">
  <small>
    <a href="04_oop_and_procedural/PitcherProcUtil.html" target="_blank">
      View in new tab
    </a>
    &nbsp;and then click <b>Walkthrough</b>.
  </small>
  <br/>
  <object data="PitcherProcUtil.html" width="100%" height="350px"></object>
</div>
</p>
<h2 id="object-oriented-programming"><a class="header" href="#object-oriented-programming">Object-oriented programming</a></h2>
<p>Here is the same program written in an Object-oriented style. Please take some time to read through the annotations within the source code.</p>
<p>
<div style="width: 100%; margin: auto;">
  <small>
    <a href="04_oop_and_procedural/Pitcher.html" target="_blank">
      View in new tab
    </a>
    &nbsp;and then click <b>Walkthrough</b>.
  </small>
  <br/>
  <object data="Pitcher.html" width="100%" height="1200px"></object>
</div>
</p>
<h3 id="static-data-and-methods"><a class="header" href="#static-data-and-methods">"static" data and methods</a></h3>
<p>The code above also introduces the notion of <code>static</code> data.
Here, the word "static" is used slightly differently than in the phrase "statically-typed".
In this context, <code>static</code> means the value belongs to the <em>class</em>, as opposed to individual instance of the class.</p>
<p>So in the example below, since all baseball games are 9 innings long, the <code>INNINGS_PER_GAME</code> variable is marked <code>static</code>, and the value is shared by all <code>Pitcher</code> objects.</p>
<blockquote>
<p><strong>PONDER</strong></p>
<p>Why don't we just give each <code>Pitcher</code> its own <code>inningsPerGame</code> instance variable and have its value be <code>9</code> for all <code>Pitcher</code>s?</p>
</blockquote>
<p>Just like we can have both <code>static</code> and instance <em>variables</em>, we can also have both <code>static</code> and instance <em>methods</em>.
A <code>static</code> method would define behaviours that don't belong to or apply to any individual <code>Pitcher</code> object.</p>
<p>For example, you might have a <code>static</code> method that takes in a list of <code>Pitcher</code> objects (<code>List&lt;Pitcher&gt;</code>) and computes the average number of runs scored across all those <code>Pitcher</code>s.</p>
<p>That is, we could have the following method inside the <code>Pitcher</code> class:</p>
<pre><code class="language-java">public static double averageRuns(List&lt;Pitcher&gt; pitchers) {
  double sum = 0;
  for (Pitcher p : pitchers) {
    sum = sum + p.runs();
  }

  if (pitchers.size() != 0) {
    return sum / pitchers.size();
  } else {
    return 0.0;
  }
}
</code></pre>
<blockquote>
<p><strong>PONDER</strong></p>
<p>What would <code>this</code> refer to in the method above?<sup class="footnote-reference" id="fr-this-1"><a href="#footnote-this">1</a></sup></p>
</blockquote>
<p><strong>Main takeaways regarding <code>static</code> methods.</strong></p>
<ul>
<li>
<p><code>static</code> methods are useful when you are writing functions that don't necessarily apply to any individual object, or if the behaviour cannot reasonably be said to be <em>performed</em> by any single object. Sometimes this will be ambiguous, and will come down to your preference.</p>
</li>
<li>
<p>If you find yourself writing a <code>static</code> method whose parameters include a single object of a given type, you should consider whether the method would be better placed as an instance method for that type. The answer will often, but not always, be <em>yes</em>.</p>
</li>
<li>
<p>Some folks tend to use <code>static</code> as an escape hatch from the Object-oriented paradigm. Sometimes this is appropriate. For example, you just want to write some useful reusable functions that don't necessarily belong to an object in a larger Object-oriented system. The <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Math.html">Math</a> class in Java is a great example: it provides a number of useful functions for things like exponentiation, trigonometry, rounding, etc. All of these are written as <code>static</code> methods. Generally useful utility classes like that are one of the only situations in which that would be acceptable. If you find yourself reaching for <code>static</code> methods, you need to re-consider your design (or your programming paradigm).</p>
</li>
</ul>
<hr>
<ol class="footnote-definition"><li id="footnote-this">
<p>There is no <code>this</code> inside a <code>static</code> method, since the method is not being called by any object. It's being called by the <em>class itself</em>. Any reference to <code>this</code> inside a <code>static</code> method would cause your code to not compile. <a href="#fr-this-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="method-dispatch-overloading-and-overriding"><a class="header" href="#method-dispatch-overloading-and-overriding">Method dispatch (overloading and overriding)</a></h1>
<blockquote>
<p>Java has a number of mechanisms in which, when a program calls a method on an object, either the compiler or the runtime must decide <em>which</em> method should be executed for that method invocation.
This is known as <em>method dispatch</em>.</p>
</blockquote>
<h2 id="method-overloading-static-dispatch"><a class="header" href="#method-overloading-static-dispatch">Method overloading (static dispatch)</a></h2>
<p><em><strong>Method overloading</strong></em> allows us to perform the same task (call the same function) in multiple different ways, depending on the inputs that are given (the arguments that are given to the function).</p>
<p>More concretely, it allows the same class to define several methods that have the <em>same name</em> but different <em>parameter</em> lists.
In Java, a method's <em>signature</em> is its <em>name</em>, its <em>parameter list</em>, and any modifiers applied to it, like <code>public</code> or <code>static</code>.
Those first two pieces—the method name and parameter list—together uniquely identify a method within a class.
Within the same class, there can never be more than one method with a given name and parameter list.</p>
<p>However, we <em>can</em> have several methods with the same name, but different parameter lists.</p>
<p>How our program chooses between all of those methods with the same names is a matter of <strong>static</strong> or <strong>dynamic dispatch</strong>.</p>
<p>Consider the two classes in the example below: <code>Circle</code> and <code>Reporter</code>.</p>
<p>
<div style="width: 100%; margin: auto;">
  <small>
    <a href="05_method_dispatch/Circle.html" target="_blank">
      View in new tab
    </a>
    &nbsp;and then click <b>Walkthrough</b>.
  </small>
  <br/>
  <object data="Circle.html" width="100%" height="500px"></object>
</div>
</p>
<p>
<div style="width: 100%; margin: auto;">
  <small>
    <a href="05_method_dispatch/Reporter.html" target="_blank">
      View in new tab
    </a>
    &nbsp;and then click <b>Walkthrough</b>.
  </small>
  <br/>
  <object data="Reporter.html" width="100%" height="500px"></object>
</div>
</p>
<p>The <code>Reporter</code> class above contains three <code>static</code> methods called <code>report</code>.<sup class="footnote-reference" id="fr-why-static-1"><a href="#footnote-why-static">1</a></sup>
Each one takes a different list of parameter types.</p>
<p>When we write code to call one of the methods, our toolchain needs to decide <em>which</em> method should get called.
This process is called <em>method dispatch</em>.</p>
<blockquote>
<p><strong>PONDER</strong></p>
<p>Why do you think they are <code>static</code> methods?<sup class="footnote-reference" id="fr-why-static-2"><a href="#footnote-why-static">1</a></sup></p>
</blockquote>
<p>So, for example, if we were to make the following function call:</p>
<pre><code class="language-java">Circle circle = new Circle(10);
Reporter.report(circle);
</code></pre>
<p>At <em>compile time</em>, the compiler determines which of the <code>report</code> methods best matches the provided input type.
In this case, the argument we've given to the <code>report</code> method is a single <code>Circle</code> object.
The compiler looks at all the <code>report</code> methods and identifies that, yes, there is a <code>report</code> method that expects a single <code>Circle</code> object as an argument.</p>
<p>After the code above is run, the text <code>"Circle: Radius: 10"</code> would be printed out.</p>
<p>If, instead, we called</p>
<pre><code class="language-java">Reporter.report(23, 2);
</code></pre>
<p>The compiler would call the <code>report</code> method that takes two <code>int</code>s as inputs, and print <code>"Two ints: 23 2"</code></p>
<p>However, if we did something like this...</p>
<pre><code class="language-java">Circle circle = new Circle(10);
Circle anotherCircle = new Circle(20);
Reporter.report(circle, anotherCircle);
</code></pre>
<p>...we would run into a compiler error.
The compiler is unable to resolve the <code>report</code> call above, i.e., it cannot find a matching method in the <code>Reporter</code> class.</p>
<p>Since all of the above happens at <em>compile time</em>, i.e., before we ran the program, this is a form of <strong>static dispatch</strong>.</p>
<h2 id="static-type-and-dynamic-type"><a class="header" href="#static-type-and-dynamic-type">Static Type and Dynamic Type</a></h2>
<p>At this point, it's useful to take a little detour.</p>
<p>We've talked about how Java is <em>statically-typed</em>.
Take a minute to remind yourself of what it means to be <em>statically-typed</em>.
Put simply, it means that the types of variables are pretty much settled at <em>compile time</em>, as opposed to <em>run time</em>.</p>
<p>However, this is not quite the complete picture in Java.
In some situations, what the <em>compiler</em> thinks is the type of a variable may not necessarily be the same as what the <em>runtime</em><sup class="footnote-reference" id="fr-runtime-1"><a href="#footnote-runtime">2</a></sup> thinks the type is (with some limitations).</p>
<p>But wait! Wasn't using a statically-typed language meant to save us from these ambiguities? How can this be?</p>
<h3 id="first-look-at-inheritance"><a class="header" href="#first-look-at-inheritance">First look at inheritance</a></h3>
<p>The Java standard library defines the <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html"><code>Object</code></a> class.
The <code>Object</code> class defines the behaviours that all objects are expected to support.
For example, the <code>Object</code> class defines these instance methods, among others:</p>
<ul>
<li><code>equals(Object): boolean</code> — This method checks if the calling object is equal to the specified <code>Object</code></li>
<li><code>toString(): String</code> — This method returns a string representation of the object</li>
</ul>
<p>Every reference type in Java is a <em>child type</em> of <code>Object</code>.
That is, every reference type in Java <em>is an</em> <code>Object</code>, and can perform all of the actions defined in the <code>Object</code> class, even if those methods were not defined for that reference type.</p>
<p>This is due to <em><strong>inheritance</strong></em>. All objects in Java inherit certain behaviours from the <code>Object</code> class, whether or not you, the programmer, explicitly told them to.</p>
<p>So, a <code>String</code> is an <code>Object</code>. A <code>Point</code> is an <code>Object</code>. The <code>CsCohort</code> and <code>Pitcher</code> classes that we created in previous lessons are <code>Object</code>s, even though we didn't explicitly mark them as such.</p>
<p>With that in mind, consider the following assignment statement:</p>
<pre><code class="language-java">Object whatAmI = new Circle(3);
</code></pre>
<p>The type on the left-hand-side of the assignment operator (<code>Object</code>) does not match the type on the right-hand-side ( <code>Circle</code>).
But our compiler is still happy with that assignment statement.</p>
<p>This is because <code>Circle</code> is a <em>subtype</em> of <code>Object</code>, i.e., <em>it can do everything that an Object can do</em>.
Our compiler works this out due to the inheritance relationship between <code>Object</code> and <code>Circle</code>.
So our compiler is totally happy to say "ok, I will treat this variable as an <code>Object</code>, because I know it can do <code>Object</code> things".</p>
<p>So:</p>
<ul>
<li>The <em>compiler</em> sees the variable <code>whatAmI</code> as an <code>Object</code>. This is known as the variable's <em><strong>static type</strong></em>.</li>
<li>The <em>runtime</em> sees the variable <code>whatAmI</code> as a <code>Circle</code>. This is known as the variable's <em><strong>dynamic type</strong></em>.</li>
</ul>
<p>I'll say that again, because that's important: <em>the variable is treated slightly differently by the compiler and the runtime</em>.
As far as the compiler knows, it's an <code>Object</code>, but the actual <em>thing</em> that is stored in memory is a <code>Circle</code>.</p>
<p>If, instead, we did...</p>
<pre><code class="language-java">Circle circ = new Circle(3);
</code></pre>
<p>...then we have no differences. The <strong>static type</strong> and the <strong>dynamic type</strong> of the variable are the same.</p>
<p>As a counterexample, consider the following.</p>
<pre><code class="language-java">// This will break!
Circle whatAmI = new Object();
</code></pre>
<p>The line above would <em>not</em> compile, because we are declaring <code>whatAmI</code> to be a <code>Circle</code>, but then we're giving it an <code>Object</code> as a value.
That is, we're saying we want to make the variable do <code>Circle</code> actions (like, say, computing its area).
But in actuality, at runtime, the variable is an <code>Object</code>, which cannot compute an area — it doesn't even have a radius!
Our compiler is able to work out this incongruence, because it understands the direction of the relationship between <code>Circle</code> and <code>Object</code>; all <code>Circles</code> are <code>Objects</code>, but not all <code>Objects</code> are <code>Circles</code>.</p>
<h2 id="back-to-method-dispatch"><a class="header" href="#back-to-method-dispatch">Back to method dispatch</a></h2>
<p>All right, with that background, let's get back to method overloading.</p>
<p>In the <code>Reporter</code> example, we have the following two <code>report</code> functions:</p>
<ul>
<li>One that takes in a <code>Circle</code> as a parameter.</li>
<li>One that takes in an <code>Object</code> as a parameter.</li>
</ul>
<p>Let's look at some function calls with different inputs.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example 1</a></h3>
<pre><code class="language-java">Circle circle = new Circle(3);
Reporter.report(circle);
</code></pre>
<ul>
<li>The input's <strong>static type</strong> is <code>Circle</code>.</li>
<li>The input's <strong>dynamic type</strong> is <code>Circle</code>.</li>
</ul>
<p><strong>What will be printed?</strong> Based on the <em>static type</em> of the variable, the compiler will decide which function should be called. In this case, it will decide on the <code>Reporter.report(Circle)</code> function, because the static type of the input is <code>Circle</code>.
So the printed output will be: <code>"Circle: Radius: 3"</code></p>
<h3 id="example-2"><a class="header" href="#example-2">Example 2</a></h3>
<pre><code class="language-java">Object obj = new Object();
Reporter.report(obj);
</code></pre>
<ul>
<li>The input's <strong>static type</strong> is <code>Object</code>.</li>
<li>The input's <strong>dynamic type</strong> is <code>Object</code>.</li>
</ul>
<p><strong>What will be printed?</strong> The compiler will choose the <code>Reporter.report(Object)</code> function, because the static type of the input is <code>Object</code>.
So the printed output will be something like: <code>"Object: Object@324618"</code><sup class="footnote-reference" id="fr-toString-1"><a href="#footnote-toString">3</a></sup></p>
<h3 id="example-3"><a class="header" href="#example-3">Example 3</a></h3>
<pre><code class="language-java">Object circ = new Circle(3);
Reporter.report(circ);
</code></pre>
<ul>
<li>The input's <strong>static type</strong> is <code>Object</code>.</li>
<li>The input's <strong>dynamic type</strong> is <code>Circle</code>.</li>
</ul>
<p><strong>What will be printed?</strong> The compiler will choose the <code>Reporter.report(Object)</code> function, because the static type of the input is <code>Object</code>.
However, the <em>dynamic type is still Circle</em>. That is, even if the compiler thinks it's an <code>Object</code>, the object that's sitting memory is still a <code>Circle</code>.</p>
<p>So we get the following output:</p>
<pre><code>"Object: Radius: 3"
</code></pre>
<p>Let's think about how we got that, step by step:</p>
<ul>
<li>When we say <em>the object in memory is a <code>Circle</code></em>, we are referring to the <em>data</em> held by a <code>Circle</code> (radius) and <em>behaviours</em> the <code>Circle</code> can perform (computing the area using <code>getArea</code>, or getting a string representation of the object using <code>toString</code>).</li>
<li>So when the print statement in the <code>report</code> function implicitly calls the <code>toString</code> method, the following two things happen:
<ol>
<li>The <em>compiler</em> checks if the static type (<code>Object</code>) has an instance method called <code>toString</code>. It does (see earlier in this lesson). If it didn't the code would not compile, and we wouldn't be able to run it at all. And this is a good check, because if the <code>Object</code> has a <code>toString</code>, we <em>know</em> that the <code>Circle</code> must also have a <code>toString</code>, because of their inheritance relationship.</li>
<li>The <em>runtime</em> needs to decide which <code>toString</code> method to call. We know that there is one in the <code>Object</code> class, and we have one in the <code>Circle</code> class. Just like before, we have to <em>choose one</em>, i.e., we have to go through the process of <em>method dispatch</em>. Since the dispatch is now occurring at <em>run time</em>, it is known as <em><strong>dynamic dispatch</strong></em>.</li>
<li>In this case, since the object is a <code>Circle</code> at run time, we choose the <code>Circle</code>'s <code>toString</code> method. And we print the <code>Radius: 3</code> message.</li>
</ol>
</li>
</ul>
<p>Putting all of that together, we get the output: <code>"Object: Radius: 3"</code></p>
<p>The <code>"Object"</code> in the string above came from the <em>static dispatch</em>, i.e., the choice of which <code>report</code> method to call. The <code>"Radius: 3"</code>  came from the <em>dynamic dispatch</em>, i.e., the choice of which <code>toString</code> method to call.</p>
<h3 id="example-4"><a class="header" href="#example-4">Example 4</a></h3>
<p>Let's consider a final example. Suppose, for a moment, that the <code>report(Circle)</code> method did <em>not</em> exist in <code>Reporter</code>. If you are following along with the code on your own machine, go ahead and delete or comment out that method now.
And suppose we did the following:</p>
<pre><code class="language-java">Circle circ = new Circle(3);
Reporter.report(circ);
</code></pre>
<p>Now, our compiler cannot find a <code>report</code> method that takes a <code>Circle</code> as a parameter, because in this example it doesn't exist.
So the compiler will now "look upward", and instead look for a method that takes as its parameter a <em>parent class</em> of <code>Circle</code> (i.e., <code>Object</code>).
So the example above would compile, and it would print out <code>"Object: Circle@eb2857"</code> (or something similar).<sup class="footnote-reference" id="fr-toString-2"><a href="#footnote-toString">3</a></sup></p>
<p><strong>Main takeway with method overloading/static dispatch.</strong></p>
<p>When a method has many overloads, the compiler checks the following rules, in this order, to determine which method should be called based on the arguments that are provided.</p>
<ol>
<li>First, it looks for a method whose parameter type is an exact match with the input's static type.</li>
<li>If that is not successful, it looks for a method whose parameter has the closest "is a" relationship with the given input's static type. In <strong>Example 4</strong> above, a <code>Circle</code> <em>is an</em> <code>Object</code>, so the compiler would resolve to calling <code>report(Object)</code> if <code>report(Circle)</code> was not present.</li>
<li>If neither of the above resolves to a method, the compiler checks if the static type of the input can be <em>implicitly</em> converted to the expected parameter type for the method. For example, if the method takes in a <code>double</code> as a parameter, and we attempt to call it with an <code>int</code> as a parameter, the compiler will implicitly convert that <code>int</code> into a <code>double</code> and call the <code>double</code> method instead.</li>
</ol>
<h2 id="method-overriding-dynamic-dispatch"><a class="header" href="#method-overriding-dynamic-dispatch">Method overriding (dynamic dispatch)</a></h2>
<p>Closely related to method overloading is the confusingly similarly named <em><strong>method overriding</strong></em>.</p>
<p>When a <em>superclass</em> (parent class) defines a behaviour and the <em>subclass</em> (child class) does not, the subclass inherits that behaviour from the superclass.
For example, if we did not write a <code>toString</code> method in our <code>Circle</code> class, it would have inherited the <code>Object</code> <code>toString</code> behaviour instead.</p>
<p><em>Method overriding</em> is when a method in a subclass has the same name and parameter list as a method in the superclass. The effect of this is that the subclass's method <em>overrides</em> the superclass's method, thus replacing the superclass's behaviour that the subclass would otherwise inherit.</p>
<h3 id="example-5"><a class="header" href="#example-5">Example 5</a></h3>
<p>Let's illustrate this with an example.</p>
<p>Continuing with our running example, suppose we had <em>not</em> written a <code>toString</code> method in the <code>Circle</code> class.</p>
<p>The <code>Circle</code> class would then inherit the <code>toString</code> behaviour from the <code>Object</code> class.
If we did not want the <code>Object</code>'s <code>toString</code> behaviour, we need to <em>override</em> it, by writing our own <code>toString</code> class in <code>Circle.</code></p>
<p>Here are the two classes again for the sake of convenience.
For this example, <code>Circle</code> has no <code>toString</code> method.</p>
<pre><code class="language-java">// Reporter.java
public class Reporter {
    public static void report(Object obj) {
        System.out.println("Object:   " + obj);
    }

    public static void report(int x, int y) {
        System.out.println("Two ints: " + x + " " + y);
    }
}

// Circle.java
public class Circle {
    private final double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    // This time with no toString method
}
</code></pre>
<p>Suppose we run the following code:</p>
<pre><code class="language-java">Object obj = new Circle(3);
Reporter.report(obj);
</code></pre>
<ul>
<li>The input's <strong>static type</strong> is <code>Object</code>.</li>
<li>The input's <strong>dynamic type</strong> is <code>Circle</code>.</li>
</ul>
<p>The following will take place:</p>
<p><strong>First,</strong> the compiler will look for a <code>report</code> function that takes an <code>Object</code> parameter. All good so far.</p>
<p><strong>Next</strong>, within the <code>report</code> function, we reach the print statement.
Inside that print statement, <code>obj.toString()</code> is implicitly called.</p>
<p><strong>Next</strong>, we should remember that, at runtime, <code>obj</code> is a <code>Circle</code>, because that was the dynamic type of our original input.
But <code>Circle</code> has no <code>toString</code> method now.</p>
<p>So what happens?</p>
<p><strong>This is where the inheritance relationship between <code>Circle</code> and <code>Object</code> comes into play.</strong>
When the runtime fails to find a <code>toString</code> method in the <code>Circle</code> object, it will "search upward", checking the ancestors of <code>Circle</code>—in this case, <code>Object</code>.</p>
<p>So, what we will see printed is:</p>
<p><code>"Circle: Object@eb78402"</code> (or something similar).<sup class="footnote-reference" id="fr-toString-3"><a href="#footnote-toString">3</a></sup></p>
<p>If we were to give <code>Circle</code> a <code>toString</code> method of its own (as in the very first code snippets in this lesson), we would replace the "default" <code>toString</code> behaviour of all <code>Object</code>s with a specific <code>toString</code> method for <code>Circle</code>s.
This process is known as <em>method overriding</em>.</p>
<!-- /*Overload resolution:
1) Exact match
2) Closest Is-A relationship
3) Can it be converted?
Resolution done at compile time (based on static type)
*/ -->
<hr>
<ol class="footnote-definition"><li id="footnote-why-static">
<p>Since there is no <em>instance data</em>, we don't really have a notion of individual <code>Reporter</code> objects. So we <em>could</em> make them instance methods, but that's not really useful right now. <a href="#fr-why-static-1">↩</a> <a href="#fr-why-static-2">↩2</a></p>
</li>
<li id="footnote-runtime">
<p>You will see me write both "run time" (as two words), and "runtime" (as one word). When I write "run time" (as two words), I mean it as <em>at run time</em>, as in "while the program is running". When I write "runtime" (as one word), I mean <em>the program execution environment</em>. In most cases these are closely related. <a href="#fr-runtime-1">↩</a></p>
</li>
<li id="footnote-toString">
<p>The <code>Object</code> class's <code>toString</code> method is not terribly useful—it simply prints the <code>Object</code>'s location in memory. I've put in some random numbers here as a memory address — yours will differ if you run this code. <a href="#fr-toString-1">↩</a> <a href="#fr-toString-2">↩2</a> <a href="#fr-toString-3">↩3</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="a-class-design-process"><a class="header" href="#a-class-design-process">A class design process</a></h1>
<blockquote>
<p>In this lesson we'll implement a simple game using an object-oriented (OO) design process.
The goal is to get a tiny taste of the thought process that goes into designing an OO system with multiple interacting classes.</p>
</blockquote>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>We're going to implement the <a href="https://en.wikipedia.org/wiki/Nim">Game of Nim</a>. Lets start by first understanding the game we're building. The rules are simple:</p>
<ul>
<li>There are two players.</li>
<li>There is a pile of sticks. We can let the players decide how many sticks should be in the pile to begin with.</li>
<li>The players take turns removing 1–3 sticks from the pile. Each turn <em>must</em> involve at least 1 stick being removed from the pile.</li>
<li>The player that removes the last stick from the pile loses.</li>
</ul>
<p>We're going to build this as a text-based game. Here is how an example game might go:</p>
<pre><code class="language-txt">Player 1's name? Yaa
Player 2's name? Michael
How many sticks? 5
Yaa, how many sticks do you want to take? 2
Yaa takes 2 stick(s).
There are 3 left in the pile.
Michael, how many sticks do you want to take? 1
Michael takes 1 stick(s).
There are 2 left in the pile.
Yaa, how many sticks do you want to take? 1
Yaa takes 1 stick(s).
There are 1 left in the pile.
Michael, how many sticks do you want to take? 1
Michael takes 1 stick(s).
There are 0 left in the pile.
Yaa is the winner
</code></pre>
<h2 id="why-follow-a-principled-design-process"><a class="header" href="#why-follow-a-principled-design-process">Why follow a principled design process?</a></h2>
<p>Before we proceed, I want to acknowledge that the requirements, as described above, are fairly simple.
You could probably write the whole game in a couple hundred lines in a single file.</p>
<p>That is fine: we're still going to use an OO process to design and implement this game.
Remember, our goal is to learn to follow a principled design process when we engineer software.
OO design is one such process to help us write maintainable code.</p>
<p>But it's worth questioning: <strong>what do we actually mean by that?</strong> When I say we should prioritise <em>maintainability</em>, I'm thinking of the following:</p>
<p><strong>Requirements change over time.</strong> Software requirements rarely stay the same. Either because the client (the person for whom we're building the software) refines what they're asking for, or because new features need to be added, or because we, the developers, are correcting initial misunderstandings about aspects of the requirements, change is a constant in software engineering.</p>
<p><strong>There will be bugs.</strong> It's likely that you'll need to debug your program at some point. Decoupling the different modules involved in the overall game implementation will help to quickly isolate issues as well as the changes needed to resolve them. This is related to the previous point. If you are making changes all over your codebase to support every new feature or bug-fix or what have you, your likelihood of introducing more bugs increases significantly. The more interactions there are between the different modules involved, the larger the "search space" grows when you are trying to hunt down a bug.</p>
<p><strong>Testing.</strong> Finally, you want to be able to test the distinct parts of your program to verify that they are working correctly, both individually and together. "<a href="https://en.wikipedia.org/wiki/Spaghetti_code">Spaghetti code</a>" is much harder to test than smaller cohesive modules, in part because it becomes difficult to even tell what a "distinct part" of the program is.</p>
<p>All that to say: it pays to follow a principled software design process.
That is, we want to write <strong>loosely coupled</strong>, <strong>tightly cohesive</strong> components (where "components" can mean functions, classes, packages, etc.; I use "component" as a general term to emphasise that these principles are not unique to OOP).</p>
<ul>
<li><strong>Loose coupling</strong>: Components can work together harmoniously, but are not dependent on each others' implementation details. If one component needs to change how it works, that should not beget changes in other components, or at least should minimise them.</li>
<li><strong>Tight cohesion</strong>: The above goal can be realised by writing components that <em>do one thing</em>. What that "one thing" is is dependent on the problem at hand. For example, we might have a component whose job it is to manage the user interface for the game (whether it is text-based or graphical) and a component whose job it is to manage the game logic.</li>
</ul>
<h3 id="detour-a-small-but-important-real-world-example"><a class="header" href="#detour-a-small-but-important-real-world-example">Detour: A small but important real-world example</a></h3>
<p>Consider the <strong><code>String</code></strong> class in Java.</p>
<p>We casually think of a <code>String</code> as being a "string of characters".
This is how the <code>String</code> used to be implemented in older versions of Java in years past.
For example, the <a href="https://github.com/openjdk/jdk8/blob/master/jdk/src/share/classes/java/lang/String.java#L114">Java 8 <code>String</code> implementation</a>, used around 2014, has a <code>value</code> instance variable declared as a <code>char[]</code>.</p>
<p>However, the <code>char</code> data type can represent a large but limited set of possible characters in its two bytes of memory (the <a href="https://en.wikipedia.org/wiki/UTF-16">UTF-16</a> encoding<sup class="footnote-reference" id="fr-encodings-1"><a href="#footnote-encodings">1</a></sup>).
At some point, the Java standard library made the switch to where the <code>value</code> of a <code>String</code> is now represented by a much less restricted array of <code>byte</code>s instead.
See <a href="https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/lang/String.java#L160">the current <code>String</code> implementation</a>.</p>
<p>Importantly, the <code>value</code> instance variable is marked as <code>private</code>, meaning that other code that used <code>String</code>s did not have direct access to this <code>value</code>, and therefore could not <em>rely</em> on it being a <code>char[]</code>.
The maintainers were able to change this to be a <code>byte[]</code> with little fuss (that I'm aware of), because the "public-facing" surface of the <code>String</code> class remained the same as far as any outsiders were concerned.
They were <em>decoupled</em> from the <code>String</code> class.</p>
<p>That said, the <code>String</code> class <em>does</em> provide the <code>toCharArray</code> method, which still gives back a <code>char[]</code>.
Code that uses that method to obtain access to the underlying array of characters could possibly break if the <code>String</code> contained characters outside the UTF-16 encoding (e.g., emojis).</p>
<p>This should serve as a warning that you should carefully think about whether or not you should provide accessor methods for your <code>private</code> instance variables.
Many Java developers do it as an automatic step when creating new classes, but that defeats some of the purpose of information hiding.</p>
<h2 id="designing-the-classes-needed-for-the-game"><a class="header" href="#designing-the-classes-needed-for-the-game">Designing the classes needed for the game</a></h2>
<p>I find it useful to ask a series of questions to help me understand what it is I'm building.</p>
<p>What data do we need to keep track of to run this game? To what <em>entities</em> do those pieces of data belong? For what <em>behaviours</em> (functionality) is each entity responsible?</p>
<ul>
<li>For starters, we have the <strong>Players</strong>. Based on the recorded game output at the beginning of this lesson, what <em>data</em> do you think a <code>Player</code> should hold? What <em>behaviours</em> do you think a <code>Player</code> should be able to perform? For example, the <code>Player</code> ought to have a <code>name</code>, since that is what is used in the text-based output. The <code>Player</code> should also be able to remove a specified number of sticks from the pile. Leading us to...</li>
<li><strong>The pile of sticks</strong>. What are the data and behaviours here? The <code>Pile</code> should, at the very least, be able to keep track of how many <code>sticks</code> are left in it. It's also probably a good idea to prevent the removal of <em>too many</em> or <em>too few</em> sticks.</li>
<li>Finally, we have <strong>the game itself</strong>. This is sort of the "controller" of this whole thing. What <em>data</em> does the <code>Game</code> know about? It needs to know about the <code>Player</code>s who are playing the game, and the <code>Pile</code> they are playing with. It also needs to manage the game logic, i.e., setting up the game, letting the players go turn-by-turn, and checking for a winner after each turn.</li>
</ul>
<blockquote>
<p><strong>PONDER</strong></p>
<p>In the game rules, a player must remove 1–3 sticks from the pile. This means we must not allow player turns in which the player tries to remove <code>&lt; 1</code> stick or <code>&gt; 3</code> sticks. Should this check be done by the <code>Pile</code>, the <code>Player</code>, or the <code>Game</code>? Why?<br><br>
In this text based game, the <code>Player</code> might enter text that cannot be parsed into an <code>int</code> while choosing the number of sticks they want to pick up. How should this be handled? Whose job is it to handle it?</p>
</blockquote>
<p>We will discuss the above together as a class.
That discussion should ideally give us an idea of what classes should exist in our system, and roughly what each of them should be responsible for.</p>
<p>Here is <em>one possible</em> implementation of the game — we may come up with something different in class, or you may come up with something different on your own.
That is fine.</p>
<h3 id="the-player-class"><a class="header" href="#the-player-class">The Player class</a></h3>
<!--{% include casdocs.html url="Player.html" height="700px" %}-->
<p>
<div style="width: 100%; margin: auto;">
  <small>
    <a href="06_class_design_process/Player.html" target="_blank">
      View in new tab
    </a>
    &nbsp;and then click <b>Walkthrough</b>.
  </small>
  <br/>
  <object data="Player.html" width="100%" height="700px"></object>
</div>
</p>
<h3 id="the-pile-class"><a class="header" href="#the-pile-class">The Pile class</a></h3>
<!--{% include casdocs.html url="Pile.html" height="600px" %}-->
<p>
<div style="width: 100%; margin: auto;">
  <small>
    <a href="06_class_design_process/Pile.html" target="_blank">
      View in new tab
    </a>
    &nbsp;and then click <b>Walkthrough</b>.
  </small>
  <br/>
  <object data="Pile.html" width="100%" height="600px"></object>
</div>
</p>
<h3 id="the-game-class"><a class="header" href="#the-game-class">The Game class</a></h3>
<p>The <code>Game</code> class is our "controller" — it sits above and in-between the <code>Player</code> and <code>Pile</code> classes, managing and mediating those classes' communications with each other.</p>
<p>That is, the <code>Game</code> prompts the <code>Player</code> to see how many sticks they want to pick up, and sends that input to the <code>Pile</code>. The <code>Pile</code> acts on this information, updating its number of sticks accordingly. The <code>Game</code> then inspects the <code>Pile</code> to see if the game is over or not (by using the <code>Pile</code>'s getter method).</p>
<!--{% include casdocs.html url="Game.html" height="100%" %}-->
<p>
<div style="width: 100%; margin: auto;">
  <small>
    <a href="06_class_design_process/Game.html" target="_blank">
      View in new tab
    </a>
    &nbsp;and then click <b>Walkthrough</b>.
  </small>
  <br/>
  <object data="Game.html" width="100%" height="1000px"></object>
</div>
</p>
<h2 id="supporting-additional-features"><a class="header" href="#supporting-additional-features">Supporting additional features</a></h2>
<p>As we've said before, a central theme in software engineering is that your requirements can change.
For example, as you think about designing the game <em>as described above</em>, think about how easy or difficult it would be to support features like the following.
How much of our code would need to change to allow these features?</p>
<ul>
<li><strong>Multiple piles instead of a single pile.</strong> Traditional versions of this game can involve <em>multiple piles</em> of sticks, as opposed to just one. Users pick up sticks from one pile at a time, but the game ends when <em>all</em> piles are empty.</li>
<li><strong>Supporting a graphical user interface.</strong> How much of our codebase needs to change to support a graphical user interface instead of (or in addition to!) a text-based interface?</li>
<li><strong>Game history.</strong> Suppose we want to be able to show a history of games that have been played, in the system as a whole and/or for individual players. How would our classes change?</li>
</ul>
<p>You will find that there is a balance to be achieved between two extremes.
On one end, you can put in huge amounts of design effort upfront, and try to prepare your code to easily handle <em>any</em> updates to the requirements, i.e., by strictly adhering to principles like information hiding and creating new abstractions (e.g., classes) to support most key features.
The downside is that you often don't need all of those abstractions—that design and preparatory implementation work can go to waste<sup class="footnote-reference" id="fr-yagni-1"><a href="#footnote-yagni">2</a></sup>, and worse, it can make your code harder to read and understand for someone who is not already familiar with the codebase.</p>
<p>On the other extreme, you can eschew this upfront design work, and when changes to requirements inevitably <em>do</em> crop up, you can pay the piper then. Though by that time you may have accrued a fair amount of <em>technical debt</em>.<sup class="footnote-reference" id="fr-td-1"><a href="#footnote-td">3</a></sup></p>
<hr>
<ol class="footnote-definition"><li id="footnote-encodings">
<p>If you're curious, this blog post by Joel Spolsky (one of the creators of StackOverflow) is a good overview about character encodings: <a href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/"><em>The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)</em></a>. <a href="#fr-encodings-1">↩</a></p>
</li>
<li id="footnote-yagni">
<p>Many pithy acronyms for engineering principles hint at this, like <a href="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it">YAGNI</a> (you aren't gonna need it) and <a href="https://en.wikipedia.org/wiki/KISS_principle">KISS</a> (keep it simple, stupid!) <a href="#fr-yagni-1">↩</a></p>
</li>
<li id="footnote-td">
<p><em>Technical debt</em> is a metaphor describing the situation in which developers sacrifice some software maintenance tasks (like software design, testing, documentation, refactoring) in favour of speedy implementations and deployments. Sometimes this is fine, as long as that "debt" is repaid soon. <em><a href="https://www.agilealliance.org/wp-content/uploads/2016/05/IntroductiontotheTechnicalDebtConcept-V-02.pdf">A little debt speeds development so long as it is paid back promptly with refactoring.</a></em> <a href="#fr-td-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="interfaces"><a class="header" href="#interfaces">Interfaces</a></h1>
<blockquote>
<p>In this lesson, we'll learn:</p>
<ul>
<li>About interfaces, the general concept.</li>
<li>About <code>interface</code>s, the embodiment of that concept in the Java language.</li>
<li>About how they are useful, using lists as an example.</li>
<li>About the meaning of <strong>polymorphism</strong>.</li>
</ul>
</blockquote>
<h2 id="what-is-an-interface"><a class="header" href="#what-is-an-interface">What is an interface?</a></h2>
<blockquote>
<p><strong>PONDER</strong></p>
<p>What does the word "interface" mean to you?</p>
</blockquote>
<p>You may have heard the term in various contexts.
For example, a graphical user interface (GUI) is the "frontend" that a computer application presents to the user, usually with buttons to click, text or images on screen, and information dialogues to convey information.</p>
<p>An <em>interface</em> is the surface at which two systems interact.
A <em>system</em> here can be a person, an organization, a computer systems, etc.</p>
<p>For example, consider the file system on your computer.
You have data on your computer organised into a hierarchy of files and folders.
You can interact with this file system using your operating system's file explorer GUI, e.g., the <strong>Finder</strong> app in macOS.
What you can do is dictated by the behaviours exposed by the interface.
That is, you can drag-and-drop files to move them, you can right-click on files or folders to copy, paste, rename, or delete them, and so on.</p>
<p><img src="07_interfaces/finder.png" alt="A screenshot of the Finder app in macOS, depicting a home folder." /></p>
<p>You can also interact with the <em>same</em> underlying system using another interface: the command line.
The command line exposes the same behaviours and more — again, what you can accomplish is determined by the behaviours exposed by the interface.</p>
<p><img src="07_interfaces/cli.png" alt="A screenshot of the iTerm app in macOS, depicting the contents of a home folder." /></p>
<p>In both cases, the interfaces above hide many details from you, the user, like the actual organisation of bits and bytes on disk, the permissions system that dictates who can see or use what files, etc.</p>
<p>Those interfaces are the <em>surface</em> at which the two systems—the user and the file system—interact with each other. Similarly, classes in Java (or, more generally, modules in software systems) expose behaviours that other classes or modules can use to interact with them.</p>
<h3 id="weve-already-seen-interfaces-in-action"><a class="header" href="#weve-already-seen-interfaces-in-action">We've already seen interfaces in action</a></h3>
<p>Though there is an <code>interface</code> keyword and program construct in Java, we aren't talking about that just yet.</p>
<p>Even though we haven't used that word explicitly, we've already been thinking about interfaces.
When we create classes in Java, we tend to make our instance variables <code>private</code> and we make most of our instance methods <code>public</code>.
This is us defining the "public surface" of our class, or the "public surface" that instances of that class will expose to other classes that want to interact with them.</p>
<p>The "public surface" here would include:</p>
<ul>
<li><strong>Method signatures for the public instance methods</strong>. I.e., their names, return types, and parameter types. These three give a sense of what the method does, what inputs it expects, and what outputs it will give back.</li>
<li><strong>Documentation</strong>. Often, there is more detail needed to describe a method's purpose. E.g., simply knowing that a method returns an <code>int</code> doesn't necessarily tell us much about what that <code>int</code> means. There may be preconditions without which the method would not work as expected. There may be postconditions, i.e., effects that method will have that are not necessarily reflected in the returned value (for example, a setter method that mutates an object's state). So we also write documentation that accompanies every public method.<sup class="footnote-reference" id="fr-javadoc-1"><a href="#footnote-javadoc">1</a></sup></li>
</ul>
<p>In sum:</p>
<blockquote>
<p>The interface of a class exposes <em>what</em> the class does, but not <em>how</em> it does it.</p>
</blockquote>
<h2 id="interfaces-in-java"><a class="header" href="#interfaces-in-java">Interfaces in Java</a></h2>
<p>The <code>interface</code> keyword in Java takes this principle and makes it a language-level construct.
An <code>interface</code> is a type of limited <code>class</code>. Unlike a class,</p>
<ul>
<li>An <code>interface</code> <strong>declares</strong> instance methods, but does not <strong>define</strong> them. That is, it only specifies method signatures, and nothing else.<sup class="footnote-reference" id="fr-default-1"><a href="#footnote-default">2</a></sup></li>
<li>An <code>interface</code> cannot declare instance variables. This makes sense from two perspectives.
<ul>
<li>First, if the <code>interface</code> dictated the available instance variables, it's straying closer to saying <em>how</em> things should be done, i.e., implementation details. This is not the goal of interfaces.</li>
<li>Second, with no method definitions, there wouldn't be much use for those instance variables.</li>
</ul>
</li>
<li>An <code>interface</code> cannot have constructors, nor can it have any data or behaviour. So, unlike a <code>class</code>, an <code>interface</code> cannot be used as a blueprint from which to create objects.</li>
<li>An <code>interface</code> <strong><em>can</em></strong> have <code>static</code> variables and <code>static</code> methods.</li>
</ul>
<blockquote>
<p><strong>PONDER</strong></p>
<p>Why do you think it's okay for <code>interface</code>s to have <code>static</code> members? Why do you suppose that would be useful?</p>
</blockquote>
<p>By omitting all implementation details—like instance variables, and the bodies (definitions) of instance methods—the <code>interface</code> takes the "skeleton" of what a class should be able to do, and places that in a separate Java file.</p>
<p>Then, you can write a separate Java class that <em>implements</em> an interface by providing implementations for the methods that the <code>interface</code> declared.
That class can have whatever instance variables it needs for its implementations.</p>
<blockquote>
<p>Just like a <code>class</code> can be used as a blueprint from which to create objects, and <code>interface</code> is a blueprint for a <code>class</code>.</p>
</blockquote>
<p>Let's look at some examples!</p>
<h3 id="a-data-structures-example-lists"><a class="header" href="#a-data-structures-example-lists">A data structures example: Lists</a></h3>
<p>Consider the <strong>List</strong> data structure.
I don't mean lists in any particular programming language—I just mean the <a href="https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/ADT.html">abstract notion</a> of a list.
Abstractly, we expect lists to support the following basic operations:</p>
<ul>
<li><code>get(index): Object</code>: We should be able to get the item at the specified index.</li>
<li><code>add(item)</code>: We should be able to add an item to the back of the list.</li>
<li><code>add(index, item)</code>: We should be able to add an item to the specified index in the list.</li>
<li><code>remove(item): boolean</code>: We should be able to remove the specified item from the list, and tell the user if something was removed or not.</li>
<li><code>remove(index): Object</code>: We should be able to remove an item from a specified index in the list, and return the item that was removed.</li>
<li><code>contains(item): boolean</code>: We should be able to check if the list contains the specified item.</li>
<li><code>size()</code>: We should be able to get the number of items in the list.</li>
</ul>
<p>In most cases, we don't actually care <em>how</em> those operations are defined, as long as they accomplish their goals.
A list is a list regardless of how the operations above are implemented.</p>
<p>The Java standard library provides the <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/List.html"><code>List</code> interface</a> to capture these expected behaviours.
The Java <code>List</code> declares many more behaviours than what I've said above, but the idea remains the same: it <em>declares</em> the signatures for those methods, and provides documentation describing what the methods should accomplish, but gives no restrictions on how those tasks should be implemented.
The <code>List</code> interface does this through the use of <em>abstract methods</em>.</p>
<blockquote>
<p><strong>Abstract methods</strong> are method declarations without definitions. I.e., they only declare the method signature, but do not include a method body.
To put it in terms we've been talking about, abstract methods dictate <em>what</em> a <code>List</code> should do, but not <em>how</em> it should do it.</p>
</blockquote>
<p>Below is a super-pared-down example of what the <code>List</code> interface might look like.</p>
<p>
<div style="width: 100%; margin: auto;">
  <small>
    <a href="07_interfaces/List.html" target="_blank">
      View in new tab
    </a>
    &nbsp;and then click <b>Walkthrough</b>.
  </small>
  <br/>
  <object data="List.html" width="100%" height="600px"></object>
</div>
</p>
<p>Because the interface contains no data and no behaviour, it cannot be initialised. That is, you cannot do the following:</p>
<pre><code class="language-java">List myList = new List(); // This will not compile
</code></pre>
<p>The left-hand-side of the above statement is okay.
The right-hand-side will cause a compiler error—you cannot use <code>new</code> to create an instance of an <code>interface</code>, because the interface is just "meta-data". There's nothing there to initialise.</p>
<h3 id="using-the-list-interface"><a class="header" href="#using-the-list-interface">Using the List interface</a></h3>
<p>Armed with the interface above, we can create list <em>implementations</em>.
You have already seen two of them: <code>ArrayList</code> and <code>LinkedList</code>.</p>
<p>Both those data structures implement the behaviours required by the <code>List</code> interface. The <code>ArrayList</code> uses a backing array to keep track of the list's contents, and the <code>LinkedList</code> uses a chain of nodes and pointers.
But the "contracts" for the <code>add</code>, <code>remove</code>, <code>contains</code>, and <code>size</code> methods are fulfilled by both implementations.</p>
<p>A class can use the <code>implements</code> keyword to declare that it is an implementation of an interface.
The class <em>must</em> contain implementations for all the abstract methods that were declared in the interface.</p>
<p>For example, here is what the <code>ArrayList</code> class might look like. It declares that it <code>implements</code> the <code>List</code> interface, and once it does so, it <em>must</em> include implementations (i.e., <em>non</em>-abstract, or "concrete" methods) for all the abstract methods that were declared in the interface.</p>
<pre><code class="language-java">/**
* This is (clearly) not the actual ArrayList implementation.
* Just an illustration of what it might look like.
*/
public class ArrayList implements List {

  private E[] backingArray;
  private int size;

  /**
  * Initialise an empty ArrayList with a capacity for 10 items.
  */
  public ArrayList() {
    this.size = 0;
    this.backingArray = new E[10];
  }

  public E get(int index) {
    return this.backingArray[index];
  }

  public void add(E e) {
    // If the list is at capacity, move its contents to a new, bigger
    // backing array.
    if (this.size == this.backingArray.length) {
      E[] newBackingArray = new E[this.backingArray.length * 2];

      // Transfer over all current list items to the new backing array.
      for (int i = 0; i &lt; this.size; i++) {
        newBackingArray[i] = this.backingArray[i];
      }
      this.backingArray = newBackingArray;
    }

    // Add the new item to the end of the list.
    this.backingArray[this.size] = e;
    this.size++;
  }

  public void add(int index, E e) {
    // omitted for brevity
  }

  public boolean remove(E e) {
    // omitted for brevity
  }

  public E remove(int index) {
    // omitted for brevity
  }

  public boolean contains(E e) {
    // omitted for brevity
  }
}
</code></pre>
<p>The <code>ArrayList</code> and <code>LinkedList</code> classes <em>must</em> contain implementations for all the abstract methods declared in the <code>List</code> interface.
These implementations can be different from each other.
In the example above, the <code>ArrayList</code>'s <code>add</code> method contains logic for making sure we stay within the capacity of our backing array.
The <code>LinkedList</code>'s <code>add</code> method will include a different set of rules for appending to a <code>LinkedList</code>.</p>
<p>What's important is that all the methods exist and contain the required signatures.
If any of the methods are omitted (or if the names are misspelled, parameter lists are different, etc.) you will get a compiler error that won't go away until you implement all of the methods.</p>
<p>The two list implementations <em>can</em> contain:</p>
<ul>
<li>Instance variables — these can be different for each class.</li>
<li>Additional methods — they can (and do) specify additional behaviours in addition to what is required by the <code>List</code> interface.</li>
</ul>
<h2 id="the-relationship-between-an-interface-and-its-implementing-subclasses"><a class="header" href="#the-relationship-between-an-interface-and-its-implementing-subclasses">The relationship between an interface and its implementing subclasses</a></h2>
<p>When a <code>class</code> <code>implements</code> an <code>interface</code>, the class is said to be an <em>implementing subclass</em> of the interface.
Recall from our lesson on <a href="07_interfaces/../05_method_dispatch/">method dispatch</a> that the <code>Object</code> class is the root of the Java type hierarchy.
All reference types in Java are <em>subtypes</em> or <em>child types</em> of the <code>Object</code> class.</p>
<p>When we create an <code>interface</code> (say, the <code>List</code> interface), we are introducing that interface into the type hierarchy.
And when we create implementations of the <code>List</code> interface, we are saying that <code>ArrayList</code> and <code>LinkedList</code> are subtypes of <code>List</code>.</p>
<blockquote>
<p>A <code>List</code> <em>is an</em> <code>Object</code>. An <code>ArrayList</code> <em>is a</em> <code>List</code>, and a <code>LinkedList</code> <em>is a</em> <code>List</code>.</p>
</blockquote>
<p>Our updated Java type hierarchy now looks like this:<sup class="footnote-reference" id="fr-hierarchy-1"><a href="#footnote-hierarchy">3</a></sup></p>
<pre class="mermaid">flowchart BT
  Other[All reference types in Java, including...]
  Other &amp; Point &amp; String &amp; List --is a--&gt; Object
  ArrayList &amp; LinkedList --is a--&gt; List
</pre>
<p>This means that we can declare and initialise lists like this:</p>
<pre><code class="language-java">// For example, say we are working with a list of Points
List&lt;Point&gt; points = new ArrayList&lt;&gt;();
</code></pre>
<blockquote>
<p><strong>PONDER</strong></p>
<p>What's the <strong>static type</strong> of the <code>points</code> variable above? What's its <strong>dynamic type</strong>? When might we be faced with a situation where its useful or necessary to have these be different?</p>
</blockquote>
<h2 id="why-is-this-useful"><a class="header" href="#why-is-this-useful">Why is this useful?</a></h2>
<p>Recall our <a href="07_interfaces/../06_class_design_process/">discussion on coupling and cohesion</a>.
Our goal is to write <em>cohesive</em> classes that are <em>loosely coupled</em> with each other.
If classes are tightly coupled, they have to change together, because they depend on each other's implementation details.
When classes are loosely coupled, they are mostly independent.
They still work together to enable the system as a whole to function, but it means that a class in a larger system can be modified without other classes noticing, as long as its public interface stays the same.</p>
<p>Usually, we achieve this by making all the data inside a class <code>private</code>.
The idea is simple: if we hide internal implementation details (like the instance variables and methods that are only used internally), then other classes <em>can't</em> depend on those implementation details.</p>
<p>The <code>interface</code> construct in Java codifies this by creating a whole new "type", just for the public interface.</p>
<p>So for example, suppose you are writing a function in a statistics package that computes a mean from a collection of data.
You would ideally make your function take a <code>List</code> as a parameter, instead of the more specific <code>ArrayList</code> or <code>LinkedList</code>.</p>
<pre><code class="language-java">public static double mean(List&lt;Integer&gt; data) {
  if (data.size() == 0) {
    return 0.0;
  }

  int sum = 0;
  for (int current : data) {
    sum = sum + current;
  }

  return sum / data.size();
}
</code></pre>
<p>Some other module that is using this function is now free to use whatever list implementation it wants — the <code>ArrayList</code> or the <code>LinkedList</code>.
When that module calls your <code>mean</code> function, the input will be a <code>List</code> at compile time, but will be the specific list subtype at run tme.
Dynamic dispatch will help the runtime figure out whether to call <code>ArrayList</code> methods or <code>LinkedList</code> methods while the program runs.</p>
<p>This is an example of <strong>polymorphism</strong>. Polymorphism literally means "many forms" — the <code>data</code> variable in the function above can take (one of) many forms at run time.</p>
<p>Your <code>mean</code> function is <em>decoupled</em> from the specifics of how the other module is handling its data. It can use a <code>LinkedList</code>, an <code>ArrayList</code>, or some newfangled list type that we haven't heard of, as long as it exposes a <code>List</code>-like interface; your function would never know the difference.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-javadoc">
<p>The exact format of that documentation is quite simple and beyond the scope of this lesson. Documentation in Java is written in a format that can be understood by a tool called JavaDoc. JavaDoc can read your comments and generate a web-page containing documentation. For example, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/ArrayList.html">this ArrayList documentation</a> was generated by JavaDoc based on the comments in <a href="https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/ArrayList.java">this Java file</a>. Here is a <a href="https://www.baeldung.com/javadoc">nice concise overview of the JavaDoc format</a> <a href="#fr-javadoc-1">↩</a></p>
</li>
<li id="footnote-default">
<p>This is a temporary simplification. We'll talk about <code>default</code> methods in the next lesson. If you already know about them, allow me this sin of omission for the time being. <a href="#fr-default-1">↩</a></p>
</li>
<li id="footnote-hierarchy">
<p>In reality, there are a few more "intermediate" layers between <code>Object</code> and <code>List</code> — but this gets the point across. We will talk in the next couple of lessons about interfaces that are subtypes of other interfaces. <a href="#fr-hierarchy-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="interfaces-part-2"><a class="header" href="#interfaces-part-2">Interfaces Part 2</a></h1>
<blockquote>
<p>In the previous lesson, we learned about <em>interfaces</em> — both the general concept as well as the program construct in Java.
In this lesson, we'll walk through an example of creating and using interfaces in a program design process.
We'll see how interfaces can help reduce coupling and introduce separation of concerns.</p>
</blockquote>
<h2 id="updating-the-nim-game"><a class="header" href="#updating-the-nim-game">Updating the Nim Game</a></h2>
<p>Will work with the Nim game example that we talked about in the lesson on <a href="08_interfaces_part_2/../06_class_design_process/">a class design process</a>.
So far, we have a game that only supports human players, i.e., at each turn our <code>Game</code> class will pause and wait for a <code>Player</code> to manually enter the number of sticks they want to pick up.</p>
<p>In this lesson we'll add support for more kinds of automated players, i.e., bots that the human player can play with.</p>
<p>Please take a minute to go look at the <a href="08_interfaces_part_2/../06_class_design_process/">current implementation of our Nim game</a>.
We have the following class structure that accomplish the following tasks.
The relationship between the classes here is a <em>has a</em> relationship. I.e., the <code>Game</code> class <em>has two</em> <code>Player</code>s, and it <em>has a</em> <code>Pile</code> as global members (instance variables, or tantamount to instance variables).</p>
<pre class="mermaid">classDiagram
  direction LR
  note for Game &quot;Underlined members are static.&quot;
  Game --&gt; Player : has two
  Game --&gt; Pile : has a
  class Game {
    +Player p1
    +Player p2
    +Pile pile
    playGame() void$
  }

  class Player {
    +String name
    +getName() String
    +takeTurn(Pile) int
  }

  class Pile {
    +int numSticks
    +removeSticks(int) void
    +getSticks() int
  }
</pre>
<p>We now want to create support for including multiple types of <code>Player</code>s — not just "human" <code>Players</code> where the game must pause and wait for input from the user.</p>
<p>Ideally, we would like to do this without having to update the <code>Game</code> logic too much.</p>
<h3 id="our-strategy"><a class="header" href="#our-strategy">Our strategy</a></h3>
<p>We can do this by creating a <code>Player</code> interface.
The <code>Game</code> will still interact with a <code>Player</code>, just like it has thus far.</p>
<p>First, we can start by defining a <code>Player</code> interface with two abstract methods.</p>
<pre class="mermaid">classDiagram
  note for `interface Player` &quot;Italicised methods are abstract.&quot;
  note for `interface Player` &quot;The &lt;code&gt;takeTurn&lt;/code&gt; method returns the number of sticks that were removed.&quot;
  class `interface Player`{
    +getName() String*
    +takeTurn(Pile) int*
  }
</pre>
<p>Then, once our <code>Player</code> interface is created, we can refactor our <code>Game</code> class to <em>only</em> use behaviours that the <code>Player</code> interface supports, i.e., to only depend on behaviours that <em>all</em> players can perform, like taking a turn and returning one's name.
As far as the <code>Game</code> is aware, both <code>p1</code> and <code>p2</code> are just <code>Player</code>s — but at runtime, they might be any one of the following:</p>
<ul>
<li><code>GreedyPlayer</code> — In the <code>takeTurn</code> method, the <code>GreedyPlayer</code> always takes as many sticks as possible, i.e., 3 if available, or as many sticks as there are left on the pile. Clearly not a winning strategy.</li>
<li><code>TimidPlayer</code> — This player always the <em>fewest</em> possible number of sticks, i.e., 1.</li>
<li><code>RandomPlayer</code> — Just for fun, this player picks randomly between 1, 2, and 3 sticks, and takes those many sticks from the pile.</li>
<li><code>HumanPlayer</code> — This is the player we implemented last week.</li>
</ul>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<h3 id="the-player-interface"><a class="header" href="#the-player-interface">The Player interface</a></h3>
<p>Here is our <code>Player</code> interface.</p>
<pre><code class="language-java">public interface Player {
  String getName();
  int takeTurn(Pile pile);
}
</code></pre>
<blockquote>
<p><strong>PONDER</strong></p>
<p>Notice a change from our previous implementation. Previously, our <code>Player</code>'s <code>takeTurn</code> method expected as a parameter the number of sticks to remove from the pile. Now, we let each <code>Player</code> compute the number of sticks to remove, and we give that information back to the <code>Game</code>. <strong>Can you think of why we've made this change?</strong> We will discuss this further below.</p>
</blockquote>
<h3 id="the-timid-player"><a class="header" href="#the-timid-player">The Timid Player</a></h3>
<p>The <code>TimidPlayer</code> always removes one stick from the pile of sticks.</p>
<pre><code class="language-java">public class TimidPlayer implements Player {
  private String name;

  public TimidPlayer(String name) {
    this.name = name;
  }

  @Override
  public String getName() {
    return name;
  }

  @Override
  public int takeTurn(Pile pile) {
    pile.removeSticks(1);
    return 1;
  }
}
</code></pre>
<h3 id="the-greedy-player"><a class="header" href="#the-greedy-player">The Greedy Player</a></h3>
<p>Recall that implementing subclasses of the same interface don't <em>have to</em> have all the same instance variables.</p>
<p>The interface defines a "lower bound" on what the class must implement. The class <em>must</em> implement the methods declared in the interface, but it <em>can</em> also implement additional behaviours.</p>
<p>Our <code>GreedyPlayer</code> has one additional behaviour in addition to what is required by the <code>Player</code> interface.
The <code>GreedyPlayer</code> is not the sharpest tool in the shed, and in addition to its less-than-optimal game play strategy, it also likes to antagonise its opponent.</p>
<p>So we give the <code>GreedyPlayer</code> a <code>jeer</code> instance variable.</p>
<pre><code class="language-java">public class GreedyPlayer implements Player {
  private String name;
  private String jeer; // This player talks smack

  public GreedyPlayer(String name, String jeer) {
    this.name = name;
    this.jeer = jeer;
  }

  public void jeer() {
    System.out.println(this.jeer);
  }

  @Override
  public String getName() {
    return this.name;
  }

  @Override
  public int takeTurn(Pile pile) {
    int toRemove = 0;
    if (pile.getSticks() &gt;= 3) {
      toRemove = 3;
    } else {
      toRemove = pile.getSticks();
    }
    return toRemove;
  }
}
</code></pre>
<h3 id="the-random-player"><a class="header" href="#the-random-player">The Random Player</a></h3>
<p>Our <code>RandomPlayer</code> uses a <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Random.html"><code>Random</code></a> object to generate a random number of sticks to pick up each time.</p>
<pre><code class="language-java">import java.util.Random;

public class RandomPlayer implements Player {
  private String name;
  private Random random;

  public RandomPlayer(String name) {
    this.name = name;
    this.random = new Random();
  }

  @Override
  public String getName() {
    return this.name;
  }

  @Override
  public int takeTurn(Pile pile) {
    // If there's more than 3 sticks on the pile, only remove 1--3 sticks.
    // If there's fewer than 3 sticks on the pile, don't try to remove more
    // than the remaining number of sticks.
    int toRemove = this.random.nextInt(1, Math.min(3, pile.getSticks()) + 1);
    pile.removeSticks(toRemove);
    return toRemove;
  }
}
</code></pre>
<h3 id="the-game-class-1"><a class="header" href="#the-game-class-1">The Game class</a></h3>
<p>With all of that set up, let's think about how the <code>Game</code> looks now. (We'll come back to the <code>HumanPlayer</code> after this.)</p>
<p>Use the "Walkthrough" button to step through the code below. Take time to read the code and understand what is going on.</p>
<p>The key thing to note here is that the <code>Game</code> functions the same way no matter how many different kinds of <code>Player</code> subtypes we support.</p>
<!--{% include casdocs.html url="Game.html" height="850x" %}-->
<p>
<div style="width: 100%; margin: auto;">
  <small>
    <a href="08_interfaces_part_2/Game.html" target="_blank">
      View in new tab
    </a>
    &nbsp;and then click <b>Walkthrough</b>.
  </small>
  <br/>
  <object data="Game.html" width="100%" height="850px"></object>
</div>
</p>
<h3 id="the-human-player"><a class="header" href="#the-human-player">The Human Player</a></h3>
<p>Finally, let's look at the <code>HumanPlayer</code>. We're going to do this bit as an in-class discussion.</p>
<p>In the <a href="08_interfaces_part_2/../06_class_design_process#the-game-class">previous implementation of the Game</a>, the <code>Game</code> was responsible for deciding how many sticks to pick up, and then giving that information to the <code>Player</code> object by calling the <code>takeTurn</code> method.
However, that meant that the <code>Game</code> logic was <em>coupled with</em> the <code>Player</code> logic — it knew about the player's strategy for choosing a number of sticks to pick up (i.e., ask the user and wait for input).</p>
<p>In our current implementation, we've introduced a degree of separation between <code>Game</code> logic and <code>Player</code> logic, setting things up so the <code>Game</code> can be totally unaware of how the <code>Player</code> takes their turn.
This allowed us to incorporate three different types of <code>Players</code>, each with their own turn taking strategies.</p>
<blockquote>
<p><strong>DISCUSS</strong></p>
<p>How do we incorporate the <code>HumanPlayer</code> into this class structure?</p>
</blockquote>
<p>Here are some hints to keep in mind as you think through this (click to expand).</p>
<details>
<summary>Hint 1</summary>
<p>The <code>Game</code> has a <code>Scanner</code> object that is setup to accept input that the user types in, i.e., <code>System.in</code>.</p>
</details>
<details>
<summary>Hint 2</summary>
<p>It is considered good practice to not create multiple <code>Scanner</code> objects for the same input stream. So we need to use <em>this same</em> <code>Scanner</code> object in the <code>HumanPlayer</code> class.</p>
</details>
<details>
<summary>Hint 3</summary>
<p>We need to pass that <code>Scanner</code> object to the <code>HumanPlayer</code> so that the <code>HumanPlayer</code> can use it, while still making it adhere to the <code>Player</code> interface.</p>
</details>
<h2 id="introducing-player-specific-functionality"><a class="header" href="#introducing-player-specific-functionality">Introducing player-specific functionality</a></h2>
<p>In <a href="08_interfaces_part_2/index.html#the-greedy-player">Greedy player</a> implementation above, we included an additional instance variable for the <code>GreedyPlayer</code> — the <code>jeer</code>.
Suppose we want our <code>GreedyPlayer</code>s to "talk smack" every time they play a turn, i.e., we want to them to print their <code>jeer</code> each time they take a turn.</p>
<p>I will work through two ways in which to add this behaviour, and we will discuss pros and cons of each strategy.</p>
<h4 id="1-the-instanceof-operator"><a class="header" href="#1-the-instanceof-operator">#1 The <code>instanceof</code> operator</a></h4>
<p>Strategy 1 is to make the <code>Game</code> handle this behaviour.
Whenever a player plays a turn (in the <code>play</code> method of the <code>Game</code>), we check if the player is an instance of <code>GreedyPlayer</code>.
That is, even though the <strong>static type</strong> of <code>p1</code> and <code>p2</code> is <code>Player</code>, we can check at run time if their <strong>dynamic</strong> type is <code>GreedyPlayer</code>.</p>
<p>We can do this using the <code>instanceof</code> operator.</p>
<blockquote>
<p>The <code>instanceof</code> operator works with a variable and a data type, and checks—at run time—if the variable is an <em>instance of</em> that data type.</p>
</blockquote>
<p>Below is the <code>play</code> method of the <code>Game</code> class, reproduced with a few added lines of code.</p>
<!--{% include casdocs.html url="play-method.html" height="500px" %}-->
<p>
<div style="width: 100%; margin: auto;">
  <small>
    <a href="08_interfaces_part_2/play-method.html" target="_blank">
      View in new tab
    </a>
    &nbsp;and then click <b>Walkthrough</b>.
  </small>
  <br/>
  <object data="play-method.html" width="100%" height="500px"></object>
</div>
</p>
<h4 id="2-make-the-greedyplayer-do-it"><a class="header" href="#2-make-the-greedyplayer-do-it">#2 Make the GreedyPlayer do it</a></h4>
<p>Strategy 2 is to make the <code>GreedyPlayer</code> handle this behaviour.</p>
<p>The <code>GreedyPlayer</code> already knows what kind of player it is—<a href="08_interfaces_part_2/../05_method_dispatch/">dynamic dispatch</a> is already taking care of calling the right <code>takeTurn</code> method depending on the player type.
So since we want this behaviour to take place each time the <code>GreedyPlayer</code> takes a turn, we could change our <code>GreedyPlayer</code>'s <code>takeTurn</code> method to the following.</p>
<pre><code class="language-java">public class GreedyPlayer implements Player {
  // Rest of the class stays the same...
  @Override
  public void takeTurn(Pile pile) {
    int toRemove = 0;
    if (pile.getSticks() &gt;= 3) {
      toRemove = 3;
    } else {
      toRemove = pile.getSticks();
    }

    // ADDED: Talk smack
    System.out.println(this.jeer);

    return toRemove;
  }
}
</code></pre>
<blockquote>
<p><strong>DISCUSS</strong></p>
<p>What are some pros and cons of the two approaches above? Which one do you prefer, and why?</p>
</blockquote>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>By using interfaces, we have introduced a degree of separation of concerns between the <code>Game</code> and the <code>Player</code>.
The <code>Game</code> interacts with two <code>Player</code> objects.
Those objects may, at run time, be any one of several possible <code>Player</code> subtypes.</p>
<p><em>Do you remember what the ability of a variable to be take many possible forms at run time is called?</em></p>
<p>The <code>Game</code> doesn't know or care about this, since it only knows about the <code>Player</code> interface.</p>
<p>The diagram below shows the entire system using a somewhat informal flowchart notation.
Note that the diagram is showing both <em>has-a</em> relationships (wherein one class has instances of another class as instance variables), and <em>is-a</em> relationships (wherein one or more classes are subclasses of another class or interface).</p>
<pre class="mermaid">classDiagram
  direction LR
  note for Game &quot;Underlined members are static.&quot;
  Game --&gt; `interface Player` : has two
  Game --&gt; Pile : has a
  `interface Player` &lt;|-- TimidPlayer : is a
  `interface Player` &lt;|-- GreedyPlayer : is a
  `interface Player` &lt;|-- RandomPlayer : is a

  class Game {
    +Player p1
    +Player p2
    +Pile pile
    playGame() void$
  }

  class `interface Player` {
    +getName() String*
    +takeTurn(Pile) int*
  }

  namespace PlayerSubtypes {
    class TimidPlayer { }

    class GreedyPlayer {
      +String jeer
      +jeer() void
    }

    class RandomPlayer { }
  }

  class Pile {
    +int numSticks
    +removeSticks(int) void
    +getSticks() int
  }
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interfaces-part-3"><a class="header" href="#interfaces-part-3">Interfaces Part 3</a></h1>
<h2 id="objectives"><a class="header" href="#objectives">Objectives</a></h2>
<blockquote>
<p>In this lesson you will learn:</p>
<ul>
<li>About hierarchical relationships between interfaces, i.e., <code>public interface &gt; InterfaceA extends InterfaceB</code>.</li>
<li>About how a class can implement multiple interfaces, i.e., <code>public class MyClass &gt; implements InterfaceA, InterfaceB</code>.</li>
<li>About <code>default</code> methods in interfaces.</li>
<li>About "the diamond" problem, i.e., what happens when a class inherits two implementations of the same method.</li>
</ul>
</blockquote>
<h2 id="recap"><a class="header" href="#recap">Recap</a></h2>
<ul>
<li><strong>Interfaces</strong> allow us to define <em>what</em> a type should be able to do, but not <em>how</em> it should do it.</li>
<li>We do this through the use of <strong>abstract methods</strong> that define a method signature, but no method body.</li>
<li>Implementing subclasses must including implementations for those methods, and can include additional methods if needed.</li>
</ul>
<p>In the previous lessons we learned about <em>interfaces</em>—both the general idea, as well as the embodiment of that idea in the form of the <code>interface</code> construct in the Java language.</p>
<p>Continuing with our running example of the Nim game, we came up with the following class design for the game.</p>
<ul>
<li>The <code>Game</code> class has two <code>Player</code>s and a <code>Pile</code> of sticks.</li>
<li>The <code>Player</code> is an interface, which means that at run time the <code>Player</code> might be any kind of available <code>Player</code> subtype, and the <code>Game</code> doesn't know or care which.</li>
<li>The <code>Player</code> interface, in other words, sits between the <code>Game</code> and the different player implementations, hiding those implementation details from other parts of the system.</li>
</ul>
<pre class="mermaid">classDiagram
  direction LR
  note for Game &quot;Underlined members are static.&quot;
  Game --&gt; `interface Player` : has two
  Game --&gt; Pile : has a
  `interface Player` &lt;|-- TimidPlayer : is a
  `interface Player` &lt;|-- GreedyPlayer : is a
  `interface Player` &lt;|-- RandomPlayer : is a

  class Game {
    +Player p1
    +Player p2
    +Pile pile
    playGame() void$
  }

  class `interface Player` {
    +getName() String*
    +takeTurn(Pile) int*
  }

  namespace PlayerSubtypes {
    class TimidPlayer { }

    class GreedyPlayer {
      +String jeer
      +jeer() String
    }

    class RandomPlayer { }
  }

  class Pile {
    +int numSticks
    +remove(int) void
    +getSticks() int
  }
</pre>
<p>For the rest of this lesson, for the sake brevity, we will only include the <code>Player</code> and its subtypes when we consider a diagrammatic view of the class structure.</p>
<h2 id="interfaces-can-extend-interfaces"><a class="header" href="#interfaces-can-extend-interfaces">Interfaces can extend interfaces</a></h2>
<p>In this lesson, we are going to consider how to incorporate yet more features into our Nim game.</p>
<p>In the design above, we have included support for the <code>GreedyPlayer</code> to <code>jeer</code> at their opponent each time they take a turn.</p>
<p>Let's suppose want to add support for multiple types of "chatty" players in our system.
That is, we don't want <em>only</em> our <code>GreedyPlayer</code> to be able to print a message each time they take a turn—we want to allow <em>any</em> new <code>Player</code> type to optionally have this ability.</p>
<p>Let's consider some options to accomplish this.</p>
<p><strong>Option 1 — Give all players the ability to print a message</strong></p>
<p>We could give all of our <code>Player</code> subtypes a <code>makeComment()</code> method that prints the <code>Player</code>'s comment to the screen.
We can also give them a <code>makeComment(String)</code> overload that prints the specified message to the screen, instead of the <code>Player</code>'s pre-defined message.</p>
<p>An advantage of this approach is that it's <em>simple</em>.
We can stick a <em><code>makeComment</code></em> overloaded abstract methods in the <code>Player</code> interface, and all implementing subclasses can print their chosen message.</p>
<p>A disadvantage is that this would reduce the <em>cohesiveness</em> of our <code>Player</code> type.
For example, the <code>TimidPlayer</code> has no intention of presenting a message each time they take a turn — what should the <code>TimidPlayer</code>'s <code>makeComment()</code> method return? An empty string (<code>""</code>)? <code>null</code>? Some string that will never be used?</p>
<p>The <code>Player</code> interface is now less cohesive because it includes behaviour (<code>message()</code>) that is not relevant to <em>all</em> <code>Player</code> instances.</p>
<p><strong>Option 2 — Break out the chatty behaviour into another type</strong></p>
<p>Option 2 is to separate the behaviour of playing games and "socializing" — they are separate concerns that don't need to be implemented together.</p>
<p>We can do this by creating a separate <code>interface</code> for <code>SocialPlayer</code>s.
The <code>SocialPlayer</code> interface will <em>extend</em> the <code>Player</code> interface.</p>
<p>The <code>SocialPlayer</code> interface looks like the following:</p>
<pre><code class="language-java">interface SocialPlayer extends Player {
  void makeComment(); // prints some pre-defined comment
  void makeComment(String message); // prints the specified message
}
</code></pre>
<blockquote>
<p>In the code above, we use the <strong><code>extends</code></strong> keyword to declare that the <code>SocialPlayer</code> <code>interface</code> is a subtype of the <code>Player</code> <code>interface</code>. That is, all <code>SocialPlayer</code>s are <code>Player</code>s.</p>
</blockquote>
<p>The <code>SocialPlayer</code> only declares one (overloaded) behaviour—the <code>makeComment</code> methods.
Any class that <code>implements SocialPlayer</code> must now include implementations of <code>Player</code> methods <em>and</em> implementations of <code>SocialPlayer</code> methods.</p>
<p>In our updated Nim game, our <code>GreedyPlayer</code> is a <code>SocialPlayer</code>, which means it can take turns in the game like all <code>Player</code>s, but can also send <code>message</code>s.</p>
<p>Here is what the <code>Player</code> type hierarchy looks like now. In the diagram below, we use <code>implements</code> or <code>extends</code> to show the specific keyword used to define the "is a" relationship between a child type and its parent type.</p>
<pre class="mermaid">classDiagram
  direction TB
  `interface Player` &lt;|-- `interface SocialPlayer` : extends
  `interface Player` &lt;|-- TimidPlayer : implements
  `interface Player` &lt;|-- RandomPlayer : implements
  `interface SocialPlayer` &lt;|-- GreedyPlayer : implements

  class `interface Player` {
    +getName() String*
    +takeTurn(Pile) int*
  }

  class `interface SocialPlayer` {
    +makeComment() void*
    +makeComment(String message) void*
  }

  namespace PlayerSubtypes {
    class TimidPlayer { }

    class GreedyPlayer { }

    class RandomPlayer { }
  }
</pre>
<p>Our <code>GreedyPlayer</code> implementation would look the same as before (except instead of <code>jeer</code> we now use the more general <code>makeComment</code> methods to chat).
But now we can incorporate additional player types that have social behaviours, and treat them all as <code>SocialPlayer</code>s in other parts of the system.</p>
<pre><code class="language-java">public class GreedyPlayer implements SocialPlayer {
  private String name;
  private String jeer; // This player talks smack

  public GreedyPlayer(String name, String jeer) {
    this.name = name;
    this.jeer = jeer;
  }

  @Override
  public void makeComment() {
    System.out.println(this.jeer);
  }

  @Override
  public void makeComment(String message) {
    System.out.println(message);
  }

  @Override
  public String getName() {
    return this.name;
  }

  @Override
  public int takeTurn(Pile pile) {
    int toRemove = 0;
    if (pile.getSticks() &gt;= 3) {
      toRemove = 3;
    } else {
      toRemove = pile.getSticks();
    }
    return toRemove;
  }
}
</code></pre>
<h3 id="whats-the-benefit-of-doing-this"><a class="header" href="#whats-the-benefit-of-doing-this">What's the benefit of doing this?</a></h3>
<p>The <code>Player</code> interface introduced a uniform set of behaviours that the <code>Game</code> could rely on; i.e., it could expect all <code>Player</code> objects to be able to do things like taking a turn, no matter what kind of player subtype they were.</p>
<p>Similarly, the <code>SocialPlayer</code> interface introduces a uniform set of <em>additional</em> behaviours that some players can perform—they can make comments.
This opens up an avenue for a version of the <code>Game</code> that allows some players (those that support social behaviours) to make comments during game play.</p>
<p>Consider this updated <code>play</code> method for the <code>Game</code> class.
In the code below, each time a <code>Player</code> takes a turn, we give the <code>opponent</code> the opportunity to print a message.</p>
<p>We use the <code>instanceof</code> operator to check if the <code>opponent</code> is an instance of the <code>SocialPlayer</code> type, and if so, we print the message.
The <code>SocialPlayer</code> interface allows us to change our "view" of the <code>opponent</code> object, deciding whether to see it as simply a <code>Player</code>, or as a <code>SocialPlayer</code>, depending on what set of behaviours we mean to invoke.</p>
<pre><code class="language-java">public static boolean play(Player p, Pile pile, Player opponent) {
  int sticksTaken = p.takeTurn(pile);
  System.out.println("\n" + p.getName() + " takes " + sticksTaken + " sticks.\n" +
    "There are " + pile.getSticks() + " left in the pile.");

  // Each time a player takes a turn, if the opponent is a social player,
  // print a vaguely threatening message.
  if (opponent instanceof SocialPlayer) {
    ((SocialPlayer) opponent).makeComment("Bad move, " + p.getName() + "!");
  }

  if (pile.getSticks() &lt;= 0) {
      return true;
  }

  return false;
}
</code></pre>
<blockquote>
<p><strong>PONDER</strong></p>
<p>Do you think this is a reasonable use of the <code>instanceof</code> operator? Is there any way to print the opponent's message from the <code>SocialPlayer</code> implementing subclasses directly?</p>
</blockquote>
<p>In the example, we are dealing with both "views" of the <code>opponent</code> in the same method.</p>
<p>As a larger example, consider if we wrote a separate, feature-rich "chatroom" module for this Nim game.
We can make that module <em>only</em> view players as <code>SocialPlayer</code>s, since it is only interested in the behaviours relevant to social interactions, and not game play.</p>
<h2 id="classes-can-implement-multiple-interfaces"><a class="header" href="#classes-can-implement-multiple-interfaces">Classes can implement multiple interfaces</a></h2>
<p>What if, as part of our expanded Nim application, we wanted to also support general "socializers"? That is, users who are not players in the Nim game, but are still able to make comments that other users can see?</p>
<p>As things currently stand, to create "socializers"—users that can make comments—we would need to implement the <code>SocialPlayer</code> interface.
Unfortunately, this brings with it a fair bit of baggage — if you implement the commenting behaviour from the <code>SocialPlayer</code>, you need to also implement the game play behaviour from the <code>Player</code> interface.
This is due to the hierarchical relationship between <code>SocialPlayer</code> and <code>Player</code>: all <code>SocialPlayer</code>s are <code>Player</code>s.</p>
<p>We can decouple the socializing functionality from the gameplay functionality by removing the hierarchical relationship between those interfaces.
That is, instead of wrapping social behaviours into a <code>SocialPlayer</code> interface that is a child type of <code>Player</code>, we can create two separate, unrelated interfaces:</p>
<ul>
<li>The <code>Player</code> interface for gameplay behaviours, unchanged from what we have seen so far.</li>
<li>The <code>Socializer</code> interface for social behaviours, like making comments.</li>
</ul>
<blockquote>
<p>In Java, classes can implement multiple interfaces. These interfaces provide different "views" to the class, or different, well, interfaces through which to interact with the class.</p>
</blockquote>
<p>The player subtypes that only support gameplay functionality (like <code>TimidPlayer</code> and <code>RandomPlayer</code>) will implement only the <code>Player</code> interface.
The player subtypes that want to support both gameplay functionality <em>and</em> socializing functionality (like <code>GreedyPlayer</code>) will implement <em>both</em> the <code>Player</code> and <code>Socializer</code> interfaces.
Finally, the users that want to only support socializing functionality (say, <code>Spectator</code> or <code>Referee</code> objects) will only implement the <code>Socializer</code> interfaces.</p>
<p>Here is what our new class structure would look like.
By separating the <code>Player</code> and <code>Socializer</code> interfaces (instead of having them have a hierarchical relationship), we have allowed classes to more flexibly combine or not combine those behaviours.</p>
<pre class="mermaid">classDiagram
  direction TB
  `interface Player` &lt;|-- TimidPlayer : implements
  `interface Player` &lt;|-- RandomPlayer : implements
  `interface Player` &lt;|-- GreedyPlayer : implements
  `interface Socializer` &lt;|-- GreedyPlayer : implements
  `interface Socializer` &lt;|-- Spectator : implements
  `interface Socializer` &lt;|-- Referee : implements

  class `interface Player` {
    +getName() String*
    +takeTurn(Pile) int*
  }

  class `interface Socializer` {
    +makeComment() void*
    +makeComment(String message) void*
  }

  class TimidPlayer { }

  class GreedyPlayer { }

  class RandomPlayer { }
</pre>
<p>To support the structure above, our <code>GreedyPlayer</code> only needs to change its signature to implement the two interfaces.
Everything else in the class would remain the same: it still needs to implement all <code>Player</code> behaviours, and it still needs to implement all <code>Socializer</code> behaviours.</p>
<pre><code class="language-java">public class GreedyPlayer implements Player, Socializer {
  // Rest of the GreedyPlayer class remains the same
}
</code></pre>
<h2 id="default-methods"><a class="header" href="#default-methods"><code>default</code> methods</a></h2>
<p>The <code>GreedyPlayer</code>, <code>Spectator</code>, and <code>Referee</code> objects all have to include implementations for the two <code>makeComment</code> methods from the <code>Socializer</code> interface.
The overload that has no parameters, i.e., <code>makeComment()</code>, will be different for each implementation.</p>
<p>It makes sense for those three classes to implement their own versions of <code>makeComment()</code>.</p>
<ul>
<li>The <code>GreedyPlayer</code> prints its <code>jeer</code>.</li>
<li>The <code>Spectator</code> might print support a message of support for the player that has their allegiance.</li>
<li>The <code>Referee</code> might print a message after conducting some checks concerning game rules.</li>
</ul>
<p>However, consider that second overload: <code>makeComment(String)</code>.
In most cases, the job of that method is to simply print the input it has been given.</p>
<p><strong>Do we really want to duplicate that code in each of those three classes?</strong></p>
<p><strong>Enter <code>default</code> methods</strong>. So far, we have only seen <em>abstract methods</em> in interfaces: methods with <em>declarations</em>, but no <em>definitions</em>. Method <em>signatures</em>, but no <em>bodies</em>.
These methods must be implemented by a subclass, because otherwise the object cannot actually perform that behaviour.</p>
<p>However, interfaces also allow us to define <code>default</code> methods: these are methods in interfaces that <em>do</em> have implementations.
These implementations are inherited by all implementing subclasses, unless the subclass overrides it.<sup class="footnote-reference" id="fr-override-1"><a href="#footnote-override">1</a></sup></p>
<p>Let us consider the <code>Socializer</code> interface as our illustrative example.</p>
<pre><code class="language-java">public interface Socializer {
  void makeComment();

  default void makeComment(String message) {
    System.out.println(message);
  }
}
</code></pre>
<p>Each of the implementing subclasses (<code>GreedyPlayer</code>, <code>Spectator</code>, and <code>Referee</code>) will inherit the existing <code>default</code> implementation of the second <code>makeComment</code> method above.
This means that they only need to implement the first <code>makeComment()</code> in order to "fully implement" the <code>Socializer</code> interface.
This is great! It saves us from having to duplicate the second <code>makeComment(String)</code> method three times.</p>
<p>Of course, they are free to <em>override</em> the <code>makeComment(String)</code> method if they want to do something different from inherited <code>default</code> method.</p>
<p>For example, suppose the <code>Referee</code> wants to print the word <code>"WHISTLE!"</code> before each comment they print.</p>
<p>In the code below, the <code>Referee</code> class implements one <code>makeComment()</code> method because that <em>has to</em> be implemented — it's abstract in the <code>Socializer</code> interface.
It also implements the <code>makeComment(String)</code> method, this time overriding the default behaviour that was inherited from the <code>Socializer</code> interface.</p>
<p>It prints the word <code>"WHISTLE!"</code> first.
Then it uses the <code>super</code> keyword to invoke the parent implementation of the <code>makeComment(String)</code> method.</p>
<blockquote>
<p>The <code>super</code> keyword is like the <code>this</code> keyword, except the object refers to itself <em>as its parent type</em> instead of its own type.</p>
</blockquote>
<p>In the example below, the <code>super.makeComment(message)</code> invokes the <code>makeComment(String)</code> method from the parent type, i.e., the <code>Socializer</code> interface.</p>
<pre><code class="language-java">public class Referee implements Socializer {
  // Referee's instance variables
  private Game game; // The Game that is currently being refereed

  public Referee(Game game) {
    this.game = game;
  }

  @Override
  public void makeComment() {
    System.out.println(game); // The referee just reports the Game state
  }

  @Override
  public void makeComment(String message) {
    System.out.print("WHISTLE! "); // Referee adds its own behaviour here
    super.makeComment(message); // Referee invokes the Socializer's default behaviour
  }
}
</code></pre>
<blockquote>
<p><strong>PONDER</strong></p>
<p>In the <code>makeComment(String)</code> method above, what do you think would happen if we called <code>this.makeComment(message)</code> instead of <code>super.makeComment(message)</code>?</p>
</blockquote>
<h3 id="the-diamond-problem"><a class="header" href="#the-diamond-problem">The "diamond problem"</a></h3>
<p>So far, we have learned the following facts about interfaces in Java:</p>
<ul>
<li>Interfaces can define abstract methods that <em>must</em> be implemented by subclasses.</li>
<li>Interfaces can also define "concrete" methods using the <code>default</code> keyword — these <em>can</em> be overridden by implementing subclasses, or they can be inherited.</li>
<li>Classes can implement multiple interfaces.</li>
</ul>
<p>With the facts above in mind, consider the following example.</p>
<p>Class <code>C</code> <code>implements</code> both interfaces <code>A</code> and <code>B</code>.
Interfaces <code>A</code> and <code>B</code> both define the method <code>doStuff</code> as a <code>default</code> method, but both do different things.</p>
<pre class="mermaid">classDiagram
  direction TD

  note &quot;Interfaces &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; both define &lt;code&gt;doStuff&lt;/code&gt; as a &lt;code&gt;default&lt;/code&gt; method.&quot;

  `interface A` &lt;|-- C : implements
  `interface B` &lt;|-- C : implements

  class `interface A` {
    +doStuff() void
  }

  class `interface B` {
    +doStuff() void
  }
</pre>
<blockquote>
<p><strong>PONDER</strong></p>
<p>Which of the two <code>doStuff</code> behaviours should class <code>C</code> inherit?</p>
</blockquote>
<h3 id="java-doesnt-support-multiple-inheritance"><a class="header" href="#java-doesnt-support-multiple-inheritance">Java doesn't support multiple inheritance</a></h3>
<p>In a situation like the above, there is simply no way for the compiler to know <em>which</em> <code>doStuff</code> method you want to inherit.
So the compiler will show you an error until you give class <code>C</code> its own implementation of <code>doStuff</code>.
By implementing its version of the method, there is no ambiguity about which one to inherit—<code>C</code> inherits neither of the parent interface's <code>doStuff</code> implementations.</p>
<p>What if you <em>wanted</em> one of the specific implementations? Do you just duplicate that code? <strong>No.</strong></p>
<p>In that case, you still need to write your own <code>doStuff</code> method, but in the body of the method, you can invoke the specific parent <code>doStuff</code> that you want.</p>
<p>So suppose you want the class <code>C</code>'s <code>doStuff</code> method to do whatever was defined in <code>interface A</code>. You do the following:</p>
<pre><code class="language-java">public class C implements A, B {
  @Override
  public void doStuff() {
    A.super.doStuff(); // Invoke the interface A's version of the method
  }
}
</code></pre>
<h2 id="extends-or-implements"><a class="header" href="#extends-or-implements"><code>extends</code> or <code>implements</code>?</a></h2>
<p>So we've seen two ways of creating fairly complex class structures. We can either create a "tree like" structure, where one interface <code>extends</code> another interface in order to allow classes to combine those behaviours.
Or we can create a "flatter" structure by creating multiple interfaces; classes that want to combine those behaviours simply need to implement both interfaces.
And <code>default</code> methods allow us to also introduce some code reuse into this picture.</p>
<p><strong>Interfaces let you create non-hierarchical type frameworks.</strong> Not all class organisations lend themselves to tree structures. That is, you may want different combinations of types "mixed together" for specific subclasses. To achieve this flexibly with <code>extends</code> relationships, you would end up with many more "intermediate" layers in your type hierarchy, creating a separate type for each combination of functionality you want to support. With interfaces you have infinite flexibility to enhance class behaviours as needed.</p>
<p>However, it is often easier to reason about tree-like structures, because there is less ambiguity about what classes can perform what behaviours.
This "straightline" flow of inherited behaviours can often be a blessing in a large, complex class structure.
If you know you're not likely to add new classes that support some behaviours but not others, it may be worthwhile to commit to a tree-like structure using <code>extends</code> for the time being.</p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>To sum up, here are some facts about interfaces:</p>
<ul>
<li>Interfaces can have abstract methods. These only have method signatures, but not method bodies. There is no special keyword for abstract methods in interfaces.</li>
<li>A class that <code>implements</code> an interface <em>must</em> include implementations for all abstract methods in a parent interface.</li>
<li>Interfaces can also have methods that <em>do</em> have implementations. These are created using the <code>default</code> keyword.</li>
<li>Implementing subclasses <em>can</em> include implementations for the <code>default</code> methods from the parent interface; this will override the interface's <code>default</code> behaviour for that method.</li>
<li>Interfaces can have <code>static</code> variables and <code>static</code> methods.</li>
<li>Interfaces <strong>cannot</strong> have instance variables.</li>
<li>Interfaces can extend other interfaces using the <code>extends</code> keyword. If a class declares that it <code>implements</code> an interface, and that interface has "parent" interfaces, the class must implement all abstract methods from the immediate parent as well as all the "grand parent" interfaces.</li>
<li>Classes can implement more than one interface.</li>
</ul>
<hr>
<ol class="footnote-definition"><li id="footnote-override">
<p>See the lesson on <a href="09_interfaces_part_3/../05_method_dispatch/">method dispatch</a> for a review of what is meant by "overriding". <a href="#fr-override-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="abstract-classes"><a class="header" href="#abstract-classes">Abstract classes</a></h1>
<p>We learned about interfaces in Java in the previous lessons.
For a recap, please take a look at the <a href="10_abstract_classes/../09_interfaces_part_3#summary">Summary</a> from the previous lesson.</p>
<p>Interfaces come with numerous benefits:</p>
<ol>
<li>They let us introduce a degree of separation between implementation details of different classes in a larger Object-oriented system.</li>
<li><code>default</code> methods in interfaces let us "pull up" common method implementations into the interface, allowing implementing subclasses to inherit those methods. This saves us from having to duplicate code.</li>
</ol>
<p>However, interfaces are just one way to achieve <em>polymorphism</em> in Java.</p>
<blockquote>
<p>In this lesson, we will learn about a related Java construct called <em>abstract classes</em>.
Abstract classes are just like regular classes in Java, except they can have <em>abstract methods.</em> There are a few similarities and differences between abstract classes and interfaces in Java.</p>
</blockquote>
<p><strong>Differences between interfaces and abstract classes</strong></p>
<ul>
<li>Abstract methods in abstract classes must be marked using the <code>abstract</code> keyword. (In interfaces, there is no keyword used for abstract methods.)</li>
<li>Abstract classes <em>can</em> have instance variables, while interfaces cannot.</li>
<li>A class <code>extends</code> an abstract class, while it <code>implements</code> an interface.</li>
<li>Classes can extend <em>at most one</em> abstract class, but it can implement more than one interface.</li>
</ul>
<p><strong>Similarities between interfaces and abstract classes</strong></p>
<ul>
<li>Both abstract classes and interfaces are forms of polymorphism in Java.</li>
<li>Like an interface, an abstract class can have both abstract and concrete methods.</li>
<li>Concrete methods in interfaces must be marked using the <code>default</code> keyword. (In abstract classes, there is no keyword used for concrete methods.)</li>
<li>Just like an interface, you <em>cannot</em> use an abstract class to initialise an object. The abstract class might have abstract methods, so this makes sense. (We don't want to create objects with "gaps" in their functionality.)</li>
</ul>
<p>We'll motivate the use of abstract classes by first looking at a disadvantage of using interfaces.</p>
<h2 id="a-disadvantage-of-using-interfaces"><a class="header" href="#a-disadvantage-of-using-interfaces">A disadvantage of using interfaces</a></h2>
<p>Consider the following interface-based type hierarchy.</p>
<p>In the <code>Shape</code> interface below, we have five abstract methods, each of which needs to be implemented by the four subtypes.</p>
<pre class="mermaid">classDiagram
  direction TD
  `interface Shape` &lt;|-- Square : implements
  `interface Shape` &lt;|-- Rectangle : implements
  `interface Shape` &lt;|-- Circle : implements
  `interface Shape` &lt;|-- Triangle : implements

  class `interface Shape` {
    getColor() Color*
    setColor(Color newColor) Color*
    getArea() double*
    getPerimeter() double*
    translate(Point point) void*
  }

  class Square {
    -double sideLength
    -Point center
    -Color color

    getColor() Color
    setColor(Color newColor) Color
    getArea() double
    getPerimeter() double
    translate(Point point) void
  }

  class Rectangle {
    -double width
    -double height
    -Point center
    -Color color
    getColor() Color
    setColor(Color newColor) Color
    getArea() double
    getPerimeter() double
    translate(Point point) void
  }

  class Circle {
    -double radius
    -Point center
    -Color color
    getColor() Color
    setColor(Color newColor) Color
    getArea() double
    getPerimeter() double
    translate(Point point) void
  }

  class Triangle {
    -Point a
    -Point b
    -Point c
    -Color color
    getColor() Color
    setColor(Color newColor) Color
    getArea() double
    getPerimeter() double
    translate(Point point) void
  }
</pre>
<p>Implementations for <code>getArea</code>, <code>getPerimeter</code>, and <code>translate</code> would likely be different for each subclass, and need to implemented on a per-class basis.
For example, calculating the area for a square is different from that of a circle, which is different from that of a triangle, etc.</p>
<p>However, implementations for <code>getColor</code> and <code>setColor</code> are likely be <em>identical</em> for all the subclasses—chances are they have a <code>private Color color</code> instance variable, and they are pretty standard getters and setters.</p>
<blockquote>
<p>Because interfaces cannot have instance variables, any code that directly touches those instance variables <em>must</em> be written in the implementing subclasses, even if is the same for all subclasses.</p>
</blockquote>
<h2 id="abstract-classes-1"><a class="header" href="#abstract-classes-1">Abstract classes</a></h2>
<p>Abstract classes can help us in these types of situations.
Specifically, they are useful when:</p>
<ul>
<li>We want a set of classes to adhere to a common public interface.</li>
<li>The implementing classes share both data and behaviour. That is, they have shared methods and instance variables.</li>
</ul>
<p>Right now, the <code>color</code> instance variable and its getter and setter methods are all being duplicated in the four child classes.
If we instead write <code>Shape</code> as an abstract class, we can "pull up" that data and behaviour into a common parent, thereby allowing all the subclasses to re-use that code.</p>
<p>In the new hierarchy below, which uses an abstract class, we can see that the subclasses have reduced in size because they now do not duplicate the shared behaviour.</p>
<pre class="mermaid">classDiagram
  direction TD
  `abstract Shape` &lt;|-- Square : extends
  `abstract Shape` &lt;|-- Rectangle : extends
  `abstract Shape` &lt;|-- Circle : extends
  `abstract Shape` &lt;|-- Triangle : extends

  class `abstract Shape` {
    +Color color
    getColor() Color
    setColor(Color newColor) Color

    getArea() double*
    getPerimeter() double*
    translate(Point point) void*
  }

  class Square {
    -double sideLength
    -Point center
    getArea() double
    getPerimeter() double
    translate(Point point) void
  }

  class Rectangle {
    -double width
    -double height
    -Point center
    getArea() double
    getPerimeter() double
    translate(Point point) void
  }

  class Circle {
    -double radius
    -Point center
    getArea() double
    getPerimeter() double
    translate(Point point) void
  }

  class Triangle {
    -Point a
    -Point b
    -Point c
    getArea() double
    getPerimeter() double
    translate(Point point) void
  }
</pre>
<blockquote>
<p><strong>DISCUSS</strong></p>
<p>Do you see further opportunities for improvement to the structure above? Is there any other duplicated data that can be "moved upward" to reduce code duplication?</p>
</blockquote>
<h3 id="code-for-the-example-above"><a class="header" href="#code-for-the-example-above">Code for the example above</a></h3>
<h4 id="the-shape-abstract-class"><a class="header" href="#the-shape-abstract-class">The Shape abstract class</a></h4>
<p>See the <code>Shape</code> abstract class below. Please use the "Walkthrough" button to see notes about important parts of the code below.
In particular, there are two new keywords introduced in the code below: <code>abstract</code> and <code>protected</code>.</p>
<!--{% include casdocs.html url="Shape.html" height="800px" %}-->
<p>
<div style="width: 100%; margin: auto;">
  <small>
    <a href="10_abstract_classes/Shape.html" target="_blank">
      View in new tab
    </a>
    &nbsp;and then click <b>Walkthrough</b>.
  </small>
  <br/>
  <object data="Shape.html" width="100%" height="800px"></object>
</div>
</p>
<p>Since the <code>Shape</code> is abstract, you can't do this:</p>
<pre><code class="language-java">// This code won't compile
Shape myShape = new Shape(new Color(255, 0, 0)); // A red....shape?
</code></pre>
<p>Just like an interface, an abstract class is a skeleton for its subclasses — it can't be used to create objects. It's a convenient construct for placing common code in one place so that subclasses don't have to duplicate it.</p>
<h4 id="the-triangle-class"><a class="header" href="#the-triangle-class">The Triangle class</a></h4>
<p>Code for the <code>Triangle</code> class is below. Please use the "Walkthrough" button to step through the accompanying notes. Here are some key features to note:</p>
<ul>
<li><strong><code>extends</code></strong>: We use the <code>extends</code> keyword to extend an abstract class. A class can extend <em>at most one</em> abstract class. But it can implement as many interfaces as needed.</li>
<li><strong><code>super</code></strong>: In the <code>Triangle</code> constructor, we use the <code>super</code> keyword to invoke the "super constructor". This is used to initialise the parent class's instance variables. In this case, when the <code>Triangle</code> is created using the <code>Triangle</code> constructor, it needs to tell the parent class (<code>Shape</code>) to also initialise <em>its</em> instance variables.</li>
</ul>
<!--{% include casdocs.html url="Triangle.html" height="1500px" %}-->
<p>
<div style="width: 100%; margin: auto;">
  <small>
    <a href="10_abstract_classes/Triangle.html" target="_blank">
      View in new tab
    </a>
    &nbsp;and then click <b>Walkthrough</b>.
  </small>
  <br/>
  <object data="Triangle.html" width="100%" height="1500px"></object>
</div>
</p>
<h2 id="interfaces-or-abstract-classes"><a class="header" href="#interfaces-or-abstract-classes">Interfaces or abstract classes?</a></h2>
<p>The key consideration is that a class can implement <em>at most one</em> abstract class.</p>
<p>If your class hierarchy is designed using only abstract classes, you are necessarily going to end up with a tree-like structure, where very child type has exactly one parent type.
Sometimes this simplicity is desirable, and sometimes it is too restrictive.</p>
<p>On the other hand, if you create a class hierarchy only interfaces, you end up with a "flatter" hierarchy that is much more flexible, since classes and implement multiple interfaces.
This allows you to "mix in" different parent types for individual subclasses, as needed.
This flexibility can be a blessing, but can also become difficult to reason about as your project grows.</p>
<p>Or, more likely, you will use some combination of abstract classes and interfaces.</p>
<p>Suppose you have a bunch of interfaces <code>A</code>, <code>B</code>, <code>C</code>, and <code>D</code>.
You have created a number of subclasses that implement various combinations of these interfaces, but you find yourself creating some combinations more often than others.
For example, you find yourself creating many classes that implement both <code>B</code> and <code>C</code>, and end up duplicating instance variables and methods in those classes.
In this case, it may make sense to create an abstract class that <code>implements B, C</code>, and root all of that common data and behaviour in the abstract class.</p>
<p>Yet another possibility is to use <em>neither</em>, at least when you're working on a smaller system.
Sometimes too much polymorphism can be a bad thing.
If it's a simple function and you only do it once, perhaps you don't need to create a whole type hierarchy to do what you could have done with a "type" variable and an <code>if</code> condition. If you find yourself frequently checking this "type" variable before performing tasks, <em>that's</em> when you could consider using polymorphism.</p>
<p>Like many problems in software design, there is no "silver bullet" that solves all your problems.
You will face tradeoffs and make choices about how to design your systems.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inheritance-and-equality"><a class="header" href="#inheritance-and-equality">Inheritance and equality</a></h1>
<h2 id="plain-old-inheritance"><a class="header" href="#plain-old-inheritance">Plain old inheritance</a></h2>
<p>So far, we have seen two ways of using polymorphism in Java: interfaces and abstract classes.
In this lesson we will (briefly) talk about "plain old inheritance".</p>
<p>In short: it is possible for "regular old classes" to be <code>extend</code>ed by other classes.
For example, we could have...</p>
<pre><code class="language-java">public class A extends B {
  private int var1;

  public A(int var1, int var2) {
    super(var2); // Just like abstract classes, we need to invoke the super constructor
    this.var1 = var1;
  }
}
</code></pre>
<p>...but unlike the examples about abstract classes, <code>class B</code> is a class <em>in its own right</em>.
It represents an abstraction that can also be used to create objects.</p>
<p>On the other hand, abstract classes help us to avoid code duplication and help us root shared behaviours in a common type, but we cannot create objects from abstract classes.</p>
<p>A common example of this type of inheritance is GUI component libraries.
For example, the Android development framework provides a bunch of classes that can be used for various frontend components, like <code>Button</code>, <code>TextArea</code>, or <code>ListView</code>.</p>
<p>All of these classes are usable components in their own right, and can be used to create objects.
However, it's likely that an Android app developer would want to create their own specialised versions of these components.
For example, they may want to create a <code>TextArea</code> that has line numbers.
To do that, they might create a class like:</p>
<pre><code class="language-java">public class LineNumberTextArea extends TextArea {
  ...
}
</code></pre>
<p><strong>You've already seen plain old inheritance through the <code>Object</code> class.</strong></p>
<p>In the lesson on <a href="11_inheritance_equality/../05_method_dispatch/">method dispatch</a>, we saw the following line of code.</p>
<pre><code class="language-java">Object obj = new Object();
</code></pre>
<p>The fact that we were able to initialise the <code>obj</code> variable using the <code>Object</code> constructor should tell you that <code>Object</code> is <em>not</em> an abstract class.
And, as we know, all reference types <code>extend</code> the <code>Object</code> class, and can inherit or override <code>Object</code>'s behaviours.</p>
<p>Below are two methods defined in the <code>Object</code> class that are commonly overridden in subclasses. (There are more, but these two are relevant for this discussion.)</p>
<ul>
<li><code>public String toString()</code>: Computes and returns a <code>String</code> representation of the object. For the <code>Object</code> class, this simply returns the object's hash code (an unique-as-far-as-possible integer representing the object). This (not super useful) behaviour will be inherited by a subclass unless the subclass overrides it by writing its own <code>toString</code> method.</li>
<li><code>public boolean equals(Object other)</code>: Checks if this <code>Object</code> (the calling object) is logically equal to the <code>other</code> object. For the <code>Object</code> class, this method checks if they are the same object (i.e., it is the same as using the <code>==</code> operator). If a subclass wants to define a more useful <code>equals</code> method, it must override it.</li>
</ul>
<h2 id="tostring"><a class="header" href="#tostring"><code>toString</code></a></h2>
<p>The <code>Object</code> class defines a <code>toString</code> method whose job it is to return a short, human friendly string representation of the object.
For a plain old <code>Object</code> which is almost never used directly by developers, this <code>toString</code> method simply returns the object's hash code, which itself is simply an integer representation of the object's memory address, unless you override it yourself, <a href="11_inheritance_equality/../12_hashcode/">which you should</a>.
The <code>Object</code> has no other distinguishing features, so there's not much more to say about it.</p>
<p><strong>You should always override <code>toString</code> when you write your own classes.</strong> It's often useful to have a <code>toString</code> method for your own classes.
It brings a number of conveniences.</p>
<ol>
<li>You can simply "print" an object's info by giving the object as an argument to <code>System.out.print</code>. The <code>print</code> method will automatically call <code>toString</code> on whatever its argument is, if its argument is not a <code>String</code>. If you don't write a <code>toString</code> method, the runtime will simply move up the type hierarchy until it finds a <code>toString</code> method, and call that instead.<sup class="footnote-reference" id="fr-polymorphism-1"><a href="#footnote-polymorphism">1</a></sup></li>
<li>When you give your object a <code>toString</code> method, you "buy into" a larger ecosystem of libraries.</li>
</ol>
<p>For example, suppose you've created your own custom linked list class, called <code>MyLinkedList</code>.
For simplicity, let's say the list contains integers, and you are performing some complex operations on this linked list.</p>
<p>You will hopefully be writing tests to check that your list functions are behaving as expected. E.g., you might write something like this:</p>
<pre><code class="language-java">// Expected value is a list like 1 --&gt; 2 --&gt; 3
MyLinkedList expected = new MyLinkedList(new Node(1, new Node(2, new Node(3, null)));
MyLinkedList actual = .... // Assume you have called some complex function here that returns a list
assertEquals(expected, actual);
</code></pre>
<p>If your test passes, all well and good.
However, if your test fails, you're going to see an error message like this:</p>
<pre><code class="language-txt">Expected: MyLinkedList@eb2184
Actual: MyLinkedList@ai02481
</code></pre>
<p>The JUnit failure message for <code>assertEquals</code> automatically uses the object's <code>toString</code> method to communicate the expected value and actual values to the user.
If you do not write a <code>toString</code> method, you're going to get the gibberish above.</p>
<p>If you <em>do</em> write a <code>toString</code> method, you will get much nicer error messages in JUnit.
For example, assuming you wrote a <code>toString</code> method that prints out each node's value with an arrow between them, you would see the following:</p>
<pre><code class="language-txt">Expected: 1 --&gt; 2 --&gt; 3
Actual: 3 --&gt; 2 --&gt; 1
</code></pre>
<p>Much easier to interpret!</p>
<p><strong>In general, IDEs and libraries will use the <code>toString</code> method whenever they need to refer to an object in text output for a human to read.</strong></p>
<p>Another really important example is the <a href="https://www.jetbrains.com/help/idea/debugging-code.html">debugger in IntelliJ IDEA</a> and most other Java IDEs. When you inspect a variable's value while debugging, the debugger by default displays the result of calling <code>toString</code> on that variable.
Without a <code>toString</code> method for custom classes, you are just going to be given the Object's default <code>toString</code> which as we've seen above is not very useful.</p>
<p>For example, consider the image below, reproduced from <a href="https://www.jetbrains.com/help/idea/debug-tool-window.html#sessions">IntelliJ's help docs</a>. In the screenshot, the user is inspecting the <code>this</code> object, which appears to be a <code>Whale</code> object.
Unfortunately, the <code>Whale</code> in this example does <em>not</em> have a <code>toString</code> method, so the user has to expand the <code>this</code> object to inspect its data.
If the <code>Whale</code> <em>did</em> have a <code>toString</code>, that value would be printed instead of <code>{Whale@784}</code> (the object's hash code).</p>
<p><img src="11_inheritance_equality/debugger.png" alt="A screenshot of a debugger session. Notice the &#39;Whale@784&#39;." /></p>
<p>A well-written <code>toString</code> can make this type of debugging go much faster.</p>
<h3 id="tostring-should-not-have-any-side-effects"><a class="header" href="#tostring-should-not-have-any-side-effects"><code>toString</code> should not have any side-effects!</a></h3>
<p>This is a <strong>REALLY IMPORTANT</strong> requirement of <code>toString</code> methods. A <code>toString</code> method must <strong>not</strong>, under any circumstances, make changes to an object, or generally have any other effects other than computing and returning a <code>String</code>.</p>
<p>Because the <code>toString</code> method is implicitly used by so many libraries, it can lead to really subtle and hard-to-track-down bugs if the <code>toString</code> method also causes other effects like mutations, or writing to a file.</p>
<p>A real example: In Spring 2023, in a java programming assignment, a student was reading data from a file in their <code>toString</code> method.
Each file read was triggering a "cache miss counter" which counted how many times the file was read.
This counter was supposed to end up with values within an expected range.
Imagine their surprise when the program worked differently when it was run in debug mode vs. regular mode vs. test mode!
Each use of <code>toString</code> (whether the student called it themselves or not) caused the counter to trigger — this means that, in addition to normal circumstances, the counter got triggered when a JUnit test case tried to display results, and when the student tried debug their program using the debugger.</p>
<p>The act of using the debugger was itself manifesting the bug the student was trying to track down. What a nightmare!</p>
<h2 id="equals"><a class="header" href="#equals"><code>equals</code></a></h2>
<p>Next up, we will talk about the <code>equals</code> method in Java.
All the way in the <a href="11_inheritance_equality/../01_intro_to_java/">first lesson</a>, we talked about how reference types (i.e., objects) must <em>not</em> be checked for equality using the <code>==</code> operator.
We must instead use the <code>.equals</code> method.</p>
<p>The <code>Object</code> class provides an <code>equals</code> method that all classes inherit, unless they write their own <code>equals</code> method.
This "fallback" <code>equals</code> method does the same check as <code>==</code> — it checks if two variables' memory addresses are the same.
That is, it checks if they both point to the same object.</p>
<p>Like we've seen, this is not super useful. We can write our own <code>equals</code> method.</p>
<p>The <code>equals</code> method in the <code>Object</code> class has the signature: <code>public boolean equals(Object other)</code>. Notice that it takes an <em><code>Object</code></em> as a parameter—it has to, because as far as <code>Object</code> is concerned, no other classes exist.</p>
<p>This means that when we override <code>equals</code> in a subclass, even the subclass's <code>equals</code> method needs to take an <code>Object</code> as a parameter.</p>
<p>Every <code>equals</code> method must do the following checks.</p>
<ol>
<li>Check if the incoming object is <code>null</code>. If it is <code>null</code>, then we cannot be equal to it, so return <code>false</code> and quit.
<ul>
<li>This step is necessary because we need the object to actually exist in order to check its type.</li>
</ul>
</li>
<li>Check if the incoming object has the same type as our <code>this</code> object. If it does not, then we cannot be equal to it, so return <code>false</code> and quit.
<ul>
<li>This step is necessary because we need the types to match to be able to cast the incoming object to the <code>this</code> object's type. Because the parameter type is declared to be <code>Object</code>, you can call any <code>equals</code> with pretty much <em>any</em> parameter. We don't want nasty runtime errors because of that.</li>
</ul>
</li>
<li>If the types match, cast the incoming object to our type, so that we can access its data.
<ul>
<li>This step is needed because we can't access the data we're interested in from the incoming object while its static type is still <code>Object</code>.</li>
</ul>
</li>
<li>Compare the fields you need to compare to determine equality.
<ul>
<li>This step is necessary for, well, checking equality.</li>
</ul>
</li>
</ol>
<p>The <code>equals</code> method is a regrettably clunky bit of tedium baked into the Java language.
Arguably, only step 4 above is germane to the task of deciding whether two objects are equal — all the other steps are just us fighting with the type and inheritance systems to be able to actually compare the data we want to compare.
Unfortunately, as described above, all the steps are necessary or we risk runtime exceptions.
So it goes.</p>
<p>Luckily, most IDEs can generate an equals method for you if you have a class that contains instance variables.</p>
<p>See the <code>Person</code> class below for an example.
It contains two instance variables: <code>name</code> and <code>age</code>, and an <code>equals</code> method that considers two <code>Person</code> objects "equal" if they have equal names and equal ages.</p>
<p>Use the "Walkthrough" button to see how each check that was described above is carried out.</p>
<!--{% include casdocs.html url="Person.html" height="700px" %}-->
<p>
<div style="width: 100%; margin: auto;">
  <small>
    <a href="11_inheritance_equality/Person.html" target="_blank">
      View in new tab
    </a>
    &nbsp;and then click <b>Walkthrough</b>.
  </small>
  <br/>
  <object data="Person.html" width="100%" height="700px"></object>
</div>
</p>
<p><strong>You should always write an <code>equals</code> method for any class that you create.</strong>
Like the <code>toString</code> method, this buys you into a larger set of libraries.
For example:</p>
<ul>
<li>The JUnit <code>assertEquals</code> method uses the <code>equals</code> method to check if its two arguments are equal.</li>
</ul>
<pre><code class="language-java">Point a = new Point(2, 3);
Point b = new Point(2, 3);

assertEquals(a, b);
</code></pre>
<p>The <code>assertEquals</code> above is equivalent to doing <code>assertTrue(a.equals(b))</code>.
That is, <code>assertEquals</code> calls the <code>equals</code> method of the first argument, using the second argument as the input.
If you do <em>not</em> write an <code>equals</code> method, the test above will fail, because it will be checking <em>sameness</em>, not equality.</p>
<ul>
<li>Java collections use the <code>equals</code> method for things like checking if a list contains an object, etc.</li>
</ul>
<p>Suppose you had the following <code>List&lt;Person&gt;</code>, and it contained some <code>Person</code> objects.</p>
<pre><code class="language-java">List&lt;Person&gt; people = List.of(
   new Person("Joe Bro", 29),
   new Person("Pooja Ahuja", 31)
);
</code></pre>
<p>Then, suppose in another function, you need to check if <code>"Pooja Ahuja"</code> exists in this list.
You would use the list's <code>contains</code> function to do this check.</p>
<pre><code class="language-java">Person pa = new Person("Pooja Ahuja", 31);
assertTrue(people.list(contains(pa))); // Will this test pass or fail?
</code></pre>
<p>The <code>contains</code> method loops over the items in the <code>people</code> list, and checks if each one <code>equals</code> the <code>pa</code> object.
If you do <em>not</em> give <code>Person</code> an <code>equals</code> method, it will default to inherited <code>equals</code> behaviour, i.e., it will check whether any item in the list is the <em>same</em> object as the one that <code>pa</code> points to.
This means the test above will fail.</p>
<p>If you <em>do</em> write an <code>equals</code> method for <code>Person</code>, the <code>contains</code> method does a much more logical check for equality—it checks each person in the <code>people</code> list and returns <code>true</code> if it finds a <code>Person</code> with the same name and age as <code>pa</code>.</p>
<h2 id="inheritance-and-equality-1"><a class="header" href="#inheritance-and-equality-1">Inheritance and equality</a></h2>
<p>...or, why we don't use <code>instanceof</code> in the type check of an <code>equals</code> method.</p>
<p>Notice that in the <code>equals</code> method above, we are doing the type check using <code>this.getClass().equals(other.getClass())</code> and not <code>other instanceof Person</code>.
The <code>getClass</code> method is inherited from <code>Object</code>, and returns the dynamic type of the calling object.</p>
<blockquote>
<p>Comparing the <em>class</em> of two objects lets you do an <em>exact match</em> comparison.
So if <code>this</code> is a <code>Person</code> object, the boolean expression <code>this.getClass().equals(other.getClass())</code> will be <code>true</code> if and only if <code>other</code> is also a <code>Person</code> object.
On the other hand, the boolean expression <code>other instanceof Person</code> will be <code>true</code> if <code>other</code> is a <code>Person</code> object or if it is some subtype of <code>Person</code>.</p>
</blockquote>
<p>Let's see an example of how this can go wrong.</p>
<p>Consider the following type hierarchy.</p>
<ul>
<li>We have a <code>ClosedFigure</code> that has a <code>location</code>, a getter and setter method for it, and an <code>equals</code> method (two <code>ClosedFigure</code>s are considered equal if they have equal locations).</li>
<li>We have a <code>Circle</code> that extends <code>ClosedFigure</code> and additionally has a <code>radius</code>. Two <code>Circle</code>s are considered equal if they have equal radii <em>and</em> locations.</li>
<li>We have a <code>Square</code> that extends <code>ClosedFigure</code> and additionally has a <code>side</code> length. Two <code>Square</code>s are considered equal if they have equal side lengths <em>and</em> locations.</li>
</ul>
<p><code>Circle</code> and <code>Square</code> each have their own override of <code>ClosedFigure</code>'s <code>equals</code> method.
None of these classes are abstract.</p>
<pre class="mermaid">classDiagram
   direction LR

   ClosedFigure &lt;-- Circle : extends
   ClosedFigure &lt;-- Square : extends

   class ClosedFigure {
      -Point location
      location() Point
      moveTo(Point) void
      toString() String
      equals(Object) boolean
   }

   class Circle {
      -int radius
      radius() int
      equals(Object) boolean
   }

   class Square {
      -int side
      side() int
      equals(Object) boolean
   }
</pre>
<p>Let's take a look at the <code>equals</code> methods for these three classes.</p>
<h3 id="closedfigure-equals"><a class="header" href="#closedfigure-equals"><code>ClosedFigure</code> <code>equals</code></a></h3>
<p>The code below shows an <code>equals</code> method for the <code>ClosedFigure</code> class.
Two <code>ClosedFigure</code>s are considered equal if they have the same location.</p>
<p>This is pretty standard, just like we saw for the <code>Person</code> example above.</p>
<pre><code class="language-java">@Override
public boolean equals(Object other) {
   if (other == null) {
      return false;
   }

   if (getClass().equals(other.getClass())) {
      return false;
   }

   return this.location.equals(((ClosedFigure) other).location);
}
</code></pre>
<h3 id="circle-equals"><a class="header" href="#circle-equals"><code>Circle</code> <code>equals</code></a></h3>
<p>Two <code>Circle</code>s are considered equal if they have the same radii <em>and</em> they have the same location.
Now, we could easily copy the <code>equals</code> method from above and just add an <code>&amp;&amp;</code> to that last return statement to also check the radii of the circles.
But that would be code duplication, and we don't want that.</p>
<p>Instead, since <code>Circle extends ClosedFigure</code>, we can use that inheritance relationship so re-use <code>ClosedFigure</code>'s equals method for the location check (and really, all the other checks except the radius check).</p>
<p>In the code below, there is no null check or type check—those checks are already being taken care of by the <code>ClosedFigure</code> class.</p>
<pre><code class="language-java">@Override
public boolean equals(Object other){
   return super.equals(other) &amp;&amp; this.radius == ((Circle) other).radius;
}
</code></pre>
<p>The compound boolean expression in the return statement above will "short circuit" if the first condition is <code>false</code>.
That is, if <code>super.equals(other)</code> is <code>false</code>, the rest of the condition doesn't matter, so it just won't be checked.</p>
<h3 id="square-equals"><a class="header" href="#square-equals"><code>Square</code> <code>equals</code></a></h3>
<p>Similarly, the <code>Square</code>'s equals method can be simplified by re-using the <code>equals</code> method from the parent class.</p>
<pre><code class="language-java">@Override
public boolean equals(Object other){
   return super.equals(other) &amp;&amp; this.side == ((Square) other).side;
}
</code></pre>
<h2 id="some-examples"><a class="header" href="#some-examples">Some examples</a></h2>
<p>Because the <code>ClosedFigure</code> equals method uses <code>getClass</code> for the type check, <a href="11_inheritance_equality/../05_method_dispatch/">dynamic dispatch</a> takes care of getting the right class name at run time.</p>
<p>So even if you created an object like so:</p>
<pre><code class="language-java">// Create a circle with location and radius
ClosedFigure fig = new Circle(new Point(2, 2), 10);
</code></pre>
<p>If you called <code>fig.getClass()</code>, you would <code>Circle</code> in return, not <code>ClosedFigure</code>.</p>
<h3 id="example-1-1"><a class="header" href="#example-1-1">Example 1</a></h3>
<pre><code class="language-java">ClosedFigure fig = new Circle(new Point(2, 2), 10);
Circle fig2 = new Circle(new Point(2, 2), 10);
</code></pre>
<blockquote>
<p><strong>PONDER</strong></p>
<p>What would <code>fig.equals(fig2)</code> return in the code above?</p>
</blockquote>
<p>Here is what happens:</p>
<ol>
<li>In the code above, dynamic dispatch would call <code>Circle'</code>s equals method, with <code>fig</code> as the calling object (i.e., <code>this</code>).</li>
<li><code>Circle</code>'s equals method will in turn call <code>ClosedFigure</code>'s equals method.</li>
<li>In <code>ClosedFigure</code>'s equals method, we move past the <code>null</code> check, since <code>fig2</code> is not null.</li>
<li>We also move past the type check, because <code>this.getClass()</code> returns <code>Circle</code>, and <code>other.getClass()</code> also returns <code>Circle</code>, because of dynamic dispatch. Even though we are tracing code in the <code>ClosedFigure</code> class, the <em>calling object</em> is a <code>Circle</code> at run time.</li>
<li>Since the type check passed, we cast <code>other</code> to a <code>ClosedFigure</code> and check its location. That check will pass, since both locations are <code>(2, 2)</code>.</li>
<li>Finally, we come back to the <code>Circle</code> class, cast <code>other</code> to a <code>Circle</code> and compare radii.</li>
</ol>
<h3 id="example-2-1"><a class="header" href="#example-2-1">Example 2</a></h3>
<p>Suppose in our <code>ClosedFigure</code> class, we had used <code>instanceof</code> instead of <code>getClass</code>. That is, the type check was carried out using <code>other instanceof ClosedFigure</code>.</p>
<blockquote>
<p><strong>PONDER</strong></p>
<p>Looking at the same example as above, what would the outcome of <code>fig.equals(fig2)</code> be?</p>
</blockquote>
<p><strong>There would be no change</strong>. At the moment of the type check, we would check if <code>other instanceof ClosedFigure</code>. <code>other</code> is a <code>Circle</code>, which <em>is a</em> <code>ClosedFigure</code>. So everything is okay, and our type casts go through without a problem.</p>
<h3 id="example-3-1"><a class="header" href="#example-3-1">Example 3</a></h3>
<p>Finally, think about the following example:</p>
<pre><code class="language-java">Circle circle = new Circle(new Point(2, 2), 10);
Square square = new Square(new Point(2, 2), 23);

assertTrue(circle.equals(square));
</code></pre>
<blockquote>
<p><strong>PONDER</strong></p>
<p>What would outcome of <code>fig.equals(fig2)</code> be? Would it be different using <code>getClass</code> vs. <code>instanceof</code> in the <code>ClosedFigure</code> type check?</p>
</blockquote>
<p>Let's trace the call <code>circle.equals(square)</code>.</p>
<ol>
<li>First, we call the <code>Circle</code> <code>equals</code> method. That immediately calls the superclass's <code>equals</code> method.</li>
<li>In the superclass equals method (<code>ClosedFigure::equals</code>), we first check if the argument is <code>null</code>. It is not (<code>square</code> was initialised in this example), so we move on.</li>
<li>Next, we check the type. Let's think about what happens if we use <code>instanceof</code> here vs. <code>getClass</code>. If the check was <code>other instanceof ClosedFigure</code>: yes, <code>square</code> is an instance of <code>ClosedFigure</code>, because of the inheritance relationship between <code>Square</code> and <code>ClosedFigure</code>. So move past this check.</li>
<li>Because the type check was good, we do the type-cast. This is also fine.</li>
<li>The <code>location</code> check also passes, because <code>circle</code> and <code>square</code> are both at the location <code>(2, 2)</code> in this example.</li>
<li>The <code>ClosedFigure</code> <code>equals</code> method returns <code>true</code>, because all the <code>ClosedFigure</code> stuff was equal! We bounce back to the rest of the <code>Circle</code> <code>equals</code> method.</li>
<li>Because the <code>super.equals(other)</code> part passed, we check the right-hand-side of the compound <code>&amp;&amp;</code> expression.</li>
<li><strong>At this point, our code will crash</strong>. We attempt to cast <code>other</code> to a <code>Circle</code>, but <code>other</code> is a <code>Square</code>!</li>
</ol>
<p>This mismatch only occurs if in the <code>ClosedFigure</code> equals method, we use <code>instanceof</code> to check the type. The <code>Square</code> <em>is</em> an instance of <code>ClosedFigure</code>, so even though the two objects are of different types, our equality check doesn't quit at that line.
This is why we use <code>getClass</code> to perform the type check in an <code>equals</code> method.</p>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>In 99% of cases, you should use <code>instanceof</code> for type-checking in Java (though if you are doing a lot of type-checking yourself, you should step back and consider your object-oriented design). In <code>equals</code> methods, where we need an <em>exact accounting</em> of the differences between two objects, we need to use <code>getClass</code> if we want two objects with the same parent equals method to be treated differently.</p>
<p>Of course, our other option is to perform the type checks in each subclass in addition to the superclass — if you do that, you can use <code>instanceof</code> as usual, because the equals method will appropriately fail at the subclass's type check.</p>
<p>You might say that this code duplication is tiresome, but...so is the <code>equals</code> method.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-polymorphism">
<p>This is a good example of polymorphism. The <code>System.out.print</code> method asks for an <code>Object</code> as a parameter. The actual argument its given might be <em>any type</em>, as long as it's a subtype of <code>Object</code>. All the <code>print</code> method cares about is that its input can produce a string representation of itself, i.e., it can call <code>toString</code>. <a href="#fr-polymorphism-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="hashcode"><a class="header" href="#hashcode"><code>hashCode</code></a></h1>
<blockquote>
<p>This brief lesson is about the <code>hashCode</code> function in the <code>Object</code> class.</p>
<ul>
<li>Like <code>toString</code> and <code>equals</code>, all classes inherit (or can override) the <code>Object</code>'s <code>hashCode</code> function.</li>
<li>Like <code>toString</code> and <code>equals</code>, you should write a <code>hashCode</code> for new classes that you create.</li>
</ul>
</blockquote>
<p>The purpose of the <code>hashCode</code> function is to generate an as-far-as-possible unique integer for distinct objects.
The produced integer should be consistent for the object.
That is, the produced integer should not change unless the object itself is changed in some way.</p>
<h2 id="whats-hashcode-used-for"><a class="header" href="#whats-hashcode-used-for">What's <code>hashCode</code> used for?</a></h2>
<p>Think about the <code>HashMap</code> data structure, discussed <a href="12_hashCode/../03_lists_maps_existing_classes/">in a previous lesson</a>.
The <code>HashMap</code> supports these fundamental operations:</p>
<ul>
<li><code>put</code> entries (key-value pairs) into the map</li>
<li><code>get</code> values from the map quickly, using a key</li>
</ul>
<p>The operations above can, for the most part, be done in constant time.
This is possible because of the "hash" part of the data structure.</p>
<p>Suppose you are trying to use a given key <code>k</code> to put some value <code>v</code> into the map.
The <code>HashMap</code> uses the key's <code>hashCode</code> value to "find a place" for <code>v</code>.
That is, you can imagine that it calls <code>k.hashCode()</code> to produce some unique integer, and uses that integer to choose a position in which to store <code>v</code>.</p>
<p>The same thing is done when we try to retrieve <code>v</code> from the map, using the key <code>k</code>.
That is, the map will call <code>k.hashCode()</code> again, come up with the <em>same integer</em> as before, and find the value <code>v</code>.
If done well, this can happen without searching the entire set of entries — so no matter how many records are in the map, we do the same amount of work to look up a value using its key.</p>
<h3 id="a-hashcode-is-an-integer"><a class="header" href="#a-hashcode-is-an-integer">A <code>hashCode</code> is an integer</a></h3>
<p>The <code>hashCode</code> function has the following signature in the <code>Object</code> class:</p>
<p><code>public int hashCode()</code></p>
<p>So any override in a class you create must also have the same signature, otherwise it will not actually override the <code>hashCode</code> function, and won't be used by data structures like the <code>HashMap</code> or <code>HashSet</code>.</p>
<p>Ok, fine, it's a method that returns an <code>int</code>. That's easy enough! But you can't return any old integer. It's important to, as far as possible, return a <em>unique</em> integer for any given object, and to have that integer be consistent across multiple calls to <code>hashCode</code> unless the object changes.</p>
<p>When distinct objects have distinct <code>hashCode</code>s, this ensures that the objects are appropriately "spread out" in a map or set.
On the other hand, if many distinct keys produce the same <code>hashCode</code>, then those keys would "collide" in the map or set.
Maps and sets are able to handle these collisions (e.g., a simple way is to "stack up" all the keys that have the same <code>hashCode</code>).
But the more collisions you have, the more your map's performance degrades.
That is, if many collisions occur, then the bigger your map gets, the more time it takes to add to retrieve items from it.</p>
<blockquote>
<p>Having distinct hash codes for distinct objects ensures that the performance of the <code>get</code>, <code>put</code>, and <code>contains</code> operations for maps and sets remain as close to constant time as possible.</p>
</blockquote>
<h3 id="equals-and-hashcode-go-hand-in-hand"><a class="header" href="#equals-and-hashcode-go-hand-in-hand"><code>equals</code> and <code>hashCode</code> go hand-in-hand</a></h3>
<p>The <code>equals</code> and <code>hashCode</code> methods <em>must</em> go hand-in-hand.</p>
<p>When you try to <code>get</code> an item from a map using a key, the following steps take place (a simplified overview):</p>
<ol>
<li>Use the key's <code>hashCode</code> to "find" the data in the map.</li>
<li>When you reach the computed position, check if the provided key <code>equals</code> the key in the map entry.</li>
<li>If the two keys are <code>equal</code>, return the value from the map entry.</li>
<li>If the two keys are <em>not</em> <code>equal</code>, follow the map's collision resolution policy to check the next possible location, or return <code>null</code>.</li>
</ol>
<p><strong>This suggests that <code>hashCode</code> and <code>equals</code> should always take the same information into account, and should always "agree" with each other.</strong>
Not doing this will result in strange and incorrect behaviour in your <code>HashMap</code>s and <code>HashSet</code>s.</p>
<p>These leads us to the following "contract" for the <code>hashCode</code> and <code>equals</code> methods in any class<sup class="footnote-reference" id="fr-javadoc-1"><a href="#footnote-javadoc">1</a></sup>:</p>
<ul>
<li>When <code>hashCode</code> is called more than once on the same object, it should consistently return the same integer, provided that no fields that are used in the <code>equals</code> method have been modified.</li>
<li>If two objects are "equal" according to the <code>equals</code> method, then calling <code>hashCode</code> on them <em>must</em> produce the same integer.</li>
<li>If two objects are <em>not</em> "equal" according to the <code>equals</code> method, it's difficult to guarantee that they return distinct integer results. But doing this as far as possible will improve <code>HashMap</code> and <code>HashSet</code> performance.</li>
</ul>
<h2 id="writing-a-hashcode-function"><a class="header" href="#writing-a-hashcode-function">Writing a <code>hashCode</code> function</a></h2>
<p>So, how to write a good <code>hashCode</code>?
That's...out of scope for this class, and is an important research problem in its own right.
The <a href="https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/HashIntro.html">OpenDSA Chapter on Hashing</a> is a really good overview.</p>
<p>In this example, we'll look at two examples of <code>hashCode</code> functions.</p>
<p>Suppose we have a simple <code>Person</code> class (the same one we used in <a href="12_hashCode/../11_inheritance_equality/">the previous lesson</a>). Each <code>Person</code> has two properties:</p>
<ul>
<li><code>int age</code></li>
<li><code>String name</code></li>
</ul>
<p>And two <code>Person</code>s are considered <code>equal</code> to each other if they have equal names and ages.
This means that:</p>
<ol>
<li>Two <code>Person</code>s with equal names and ages should produce the same hash code.</li>
<li>If two <code>Person</code>s differ in name or age or both, they should produce different hash codes, as far as possible.</li>
</ol>
<p>We'll look at two ways of writing the <code>hashCode</code> function.</p>
<h3 id="rolling-our-own"><a class="header" href="#rolling-our-own">Rolling our own</a></h3>
<p>One option is to compute an integer ourselves.
We should make use of all instance variables that factor into the <code>equals</code> decision in order to meet the "contract" we talked about earlier, and we need to make it so that differences in the values of those instance variables will result in differences in our final integer.</p>
<p>Here's an example.</p>
<ul>
<li>In the code below, we start with the number <code>1</code>.</li>
<li>Then we multiply by <code>37</code> — multiplying by a prime number like <code>37</code> makes it more likely for us to produce a number that other objects <em>won't</em> produce. You can use any prime number you want.</li>
<li>Then we add the <code>name</code>'s <code>hashCode</code> value. The <code>String</code> class already has a <code>hashCode</code> function, so we don't need to re-invent that. Note that we are assuming here that the <code>name</code> is not <code>null</code>! We can do this because we <a href="12_hashCode/../11_inheritance_equality#equals">included code to guarantee this in the previous lesson</a> If it's possible for <code>name</code> to be <code>null</code>, then you need to check that first.</li>
<li>We multiply this result again by <code>37</code>, then add the <code>age</code>.</li>
</ul>
<pre><code class="language-java">@Override
public int hashCode() {
  int result = 1;

  result = result * 37 + this.name.hashCode();
  result = result * 37 + this.age;

  return result;
}
</code></pre>
<h3 id="using-existing-methods"><a class="header" href="#using-existing-methods">Using existing methods</a></h3>
<p>A lot has been said or written about generating good hash values for different primitive data types (which in turn can be used as building blocks for generating hash values for reference types).
Many of these ideas have been implemented already.
In many cases it's better to use existing implementations instead of re-inventing the wheel.</p>
<p>The <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Objects.html"><code>Objects</code></a><sup class="footnote-reference" id="fr-s-1"><a href="#footnote-s">2</a></sup> class in Java contains number of useful static methods, among them utilities for generating a hash code based on a given set of fields.</p>
<p>The <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Objects.html#hash(java.lang.Object...)"><code>hash</code></a> static function takes in a list of parameters, and generates a hash code based on those values.
So we could rewrite the <code>hashCode</code> for our <code>Person</code> class as:</p>
<pre><code class="language-java">@Override
public int hashCode() {
  return Objects.hash(this.name, this.age);
}
</code></pre>
<p>The <code>Objects</code> class also provides the <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Objects.html#equals(java.lang.Object,java.lang.Object)"><code>Objects.equals</code></a> function. You can use <code>Objects.equals(a, b)</code> instead of <code>a.equals(b)</code>.
This is useful in cases you are not sure if <code>a</code> is null or not — <code>a.equals(b)</code> would crash with a <code>NullPointerException</code> if <code>a</code> was null, whereas <code>Objects.equals</code> checks that for you, or you could check it yourself.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-javadoc">
<p>Paraphrased from the <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#hashCode()">Object documentation</a>. <a href="#fr-javadoc-1">↩</a></p>
</li>
<li id="footnote-s">
<p>Notice the "s" in <code>Objects</code>. <a href="#fr-s-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="comparables-and-comparators"><a class="header" href="#comparables-and-comparators">Comparables and Comparators</a></h1>
<blockquote>
<p>In this lesson, we're going to learn about the <code>Comparable</code> and <code>Comparator</code> interfaces in Java.
These interfaces help us to, well, <em>compare</em> pairs of objects to determine and order between them.</p>
</blockquote>
<p><strong>Let's start with a motivating example.</strong> Let's consider the problem of <em>sorting a list of objects.</em></p>
<p>You've probably studied a number of sorting algorithms like <a href="https://en.wikipedia.org/wiki/Insertion_sort">insertion sort</a>, <a href="https://en.wikipedia.org/wiki/Merge_sort">merge sort</a>, <a href="https://en.wikipedia.org/wiki/Quicksort">quicksort</a>, etc.
They all work slightly differently, but ultimately the outcome is the same: given a collection of data, they each give you back that same collection with the items arranged <em>in order.</em></p>
<blockquote>
<p>The <strong>"in order"</strong> in the sentence above is actually doing a lot of work.</p>
</blockquote>
<p>Every sort function needs to, at some point, do a <em>pairwise comparison</em> of objects in the collection that's being sorted.
That is, regardless of how the sorting algorithm works, at some point two items in the collection need to be compared to each other to determine how they should be ordered relative to each other.</p>
<p>Consider the following <code>sort</code> function that implements <a href="https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/InsertionSort.html">insertion sort</a>.<sup class="footnote-reference" id="fr-opendsa-1"><a href="#footnote-opendsa">1</a></sup>
How we perform that pairwise comparison is going to depend on <em>what</em> is being sorted.</p>
<pre><code class="language-java">public static void sort(Album[] arr) {
  for (int i = 1; i &lt; arr.length; i++) {
    for (int j = i; j &gt; 0; j--) {
      if (______________________) { // Compare arr[j] and arr[j - 1]
        // Swap arr[j] and arr[j-1]
        Album temp = arr[j];
        arr[j] = arr[j - 1];
        arr[j - 1] = temp;
      } else {
        break;
      }
    }
  }
}
</code></pre>
<p>The blank in the <code>if</code> statement in the code above is where the comparison should take place.
That is, we need to check if <code>arr[j]</code> is "less than" <code>arr[j - 1]</code>, whatever that means for the particular data being sorted.</p>
<p><strong>How should that comparison take place?</strong></p>
<p>When we think about sorting a list of numbers, the comparison is clear: we often mean to order the numbers in ascending order, i.e., smallest-to-largest.
That is, for any pair of numbers, we know the smaller one should come before the larger one.
If we needed to order them in descending order (largest-to-smallest), that's still easy---given the numbers <code>8</code> and <code>5</code>, we can easily say what their relative order should be using operators like <code>&gt;</code>, <code>&lt;</code>, and <code>==</code>.</p>
<!-- Suppose, instead, you have a list of strings.
Slightly more complicated, but again, our intent is likely predictable: we mean to sort the list in alphabetical order. -->
<p>Suppose, instead, you have a custom object, based on a class you have just created.
For example, an <code>Album</code> object that contains a number of fields (or instance variables):</p>
<ul>
<li><code>String title</code></li>
<li><code>String artist</code></li>
<li><code>int year</code></li>
<li><code>double price</code></li>
</ul>
<p>How should a list of <code>Album</code>s be sorted? By <code>title</code>, <code>artist</code>, <code>year</code>? Some combination of fields?
We cannot use comparison operators like <code>&gt;</code> or <code>&lt;</code> on our <code>Album</code> object because those operators are reserved for numerical (and <code>char</code>) types in Java.</p>
<p>At the same time, we don't want to have to re-write our <code>sort</code> function for our <code>Album</code> class, because pretty soon we will have an <code>Artist</code> class and then a <code>Song</code> class, and we definitely don't want to keep re-writing a sorting algorithm when the only thing that's changing is the <em>type of data</em> that's being sorted (and therefore, the pairwise comparison).</p>
<p>So, how should we compare <code>Album</code>s? We can write custom code to compare any two <code>Album</code>s using whatever criterion we think is a good "natural ordering" for <code>Album</code>s.</p>
<p>Observe that, no matter how we decide to order <code>Album</code>s, the rest of that <code>sort</code> function will stay the same.
The <em>only</em> part of the function that needs to change is the comparison in the <code>if</code> statement.</p>
<p>Can we abstract out that comparison so that the <code>sort</code> doesn't need to know how it's being done?</p>
<hr>
<ol class="footnote-definition"><li id="footnote-opendsa">
<p>From the <a href="https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/InsertionSort.html">OpenDSA chapter on Insertion Sort</a>. <a href="#fr-opendsa-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="comparable"><a class="header" href="#comparable"><code>Comparable</code></a></h1>
<blockquote>
<p>The <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Comparable.html"><code>Comparable</code> interface</a> is used when we create a class and we want to define a "natural" ordering between any pair of objects created from that class.
In essence, its job is to let us define <code>&gt;</code>, <code>&lt;</code>, and <code>==</code> relationships for classes that we create.</p>
</blockquote>
<p>The <code>Comparable</code> interface contains a single abstract method that must be implemented by implementing subclasses:</p>
<p><code>int compareTo(T other)</code></p>
<p>It defines how <code>this</code> object compares to the <code>other</code> object.</p>
<p>Two things are worth discussing about the method signature.</p>
<ol>
<li><strong>The parameter <code>T other</code>:</strong> The <code>T</code> here is a placeholder type. The <code>Comparable</code> interface doesn't know what type of data is going to be compared, and doesn't care. In our <code>Album</code> class, the signature would be <code>int compareTo(Album other)</code>.</li>
<li><strong>The <code>int</code> return type.</strong> The comparison is not a binary decision: there are three possible outcomes (<code>&lt;</code>, <code>&gt;</code>, or <code>==</code>). So we cannot use a <code>boolean</code> as the return type.</li>
</ol>
<p>The "contract" for the <code>compareTo</code> function is:</p>
<ul>
<li>If <code>this</code> is "less than" <code>other</code>, i.e., it should come before <code>other</code> in a sorted list, return a negative number.</li>
<li>If <code>this</code> is "greater than" <code>other</code>, i.e., should come after <code>other</code> in a sorted list, return a positive number.</li>
<li>If <code>this</code> and <code>other</code> are equal, return <code>0</code>. In general, it's recommended that if <code>this.equals(other)</code> is <code>true</code>, then <code>this.compareTo(other)</code> should return <code>0</code>.</li>
</ul>
<p>Consider the code below.
We have an <code>Album</code> class that is declared to be <code>Comparable</code>.
We are saying <code>Album</code> objects are comparable to other <code>Album</code> objects.
This means the <code>Album</code> must define a <code>compareTo</code> method.</p>
<p>In the example below, we are saying that <code>Album</code> ordering is determined based on their <code>title</code>s.
Notice that we are not ourselves writing a lexicographic comparison of <code>this.title</code> and <code>other.title</code>: <code>title</code> is a <code>String</code>, which itself implements the <code>Comparable</code> interface.
We can use that.</p>
<pre><code class="language-java">public class Album implements Comparable&lt;Album&gt; {
  private final String title;
  private final String artist;
  private final int year;
  private double price;

  // ... Assume we have written a constructor, getters, setters etc.

  @Override
  public int compareTo(Album other) {
    return this.title.compareTo(other.title);
  }
}
</code></pre>
<h3 id="what-does-this-get-us"><a class="header" href="#what-does-this-get-us">What does this get us?</a></h3>
<p>Consider our <code>sort</code> function example from above.
If, instead of using <code>Album[]</code> as our parameter type, we used a <code>Comparable[]</code> as our parameter type, we can now use the same <code>sort</code> function for <em>any</em> data type, as long as that data type implements the <code>Comparable</code> interface.</p>
<p>See the <code>if</code> statement in the updated <code>sort</code> function below.</p>
<pre><code class="language-java">public static void sort(Comparable[] arr) {
  for (int i = 1; i &lt; arr.length; i++) {
    for (int j = i; j &gt; 0; j--) {
      if (arr[j].compareTo(arr[j - 1]) &lt; 0) { // If arr[j] is "less than" arr[j - 1]
        // Swap arr[j] and arr[j-1]
        Album temp = arr[j];
        arr[j] = arr[j - 1];
        arr[j - 1] = temp;
      } else {
        break;
      }
    }
  }
}
</code></pre>
<p>This is an example of using <em>abstraction</em> — we are ignoring or abstracting away the details of the specific object being sorted, and only focusing on the salient detail, i.e., the fact that it can be compared to other objects of its own type.
Because we can use <code>compareTo</code>, we don't need to know or care what specific type of object is stored in <code>arr</code>.</p>
<p>And this is exactly what is done in sort functions already available in the Java standard library.
The <code>Collections</code> class provides a number of helpful static functions; among them is <code>Collections.sort</code>.</p>
<p>If you have a list of objects, and those objects are <code>Comparable</code>, you can call <code>Collections.sort</code> on that list to sort it according to the object's "natural ordering", i.e., according to its <code>compareTo</code> method.</p>
<p>Note that <code>Collections.sort</code> sorts the list <em>in place</em>, meaning it mutates the underlying list, instead of returning a new sorted list.</p>
<pre><code class="language-java">List&lt;Album&gt; albums = Arrays.asList(
  new Album("Rubber Soul", "The Beatles", 1965, 18.99),
  new Album("1989 (Taylor's Version)", "Taylor Swift", 2023, 18.99),
  new Album("1989", "Taylor Swift", 2014, 18.99),
  new Album("Leaving Eden", "The Carolina Chocolate Drops", 2012, 18.99)
);

// If Album does not implement Comparable, this line won't compile.
Collections.sort(albums);

for (Album current : albums) {
  System.out.println(current);
}
</code></pre>
<p>The code above would print:</p>
<pre><code class="language-txt">1989
1989 (Taylor's Version)
Leaving Eden
Rubber Soul
</code></pre>
<blockquote>
<p><strong>PONDER</strong></p>
<p>Suppose you were asked to handle tie-breakers. E.g., for albums with the same title, break ties by artist name.
How would you handle this in the <code>compareTo</code> function?</p>
</blockquote>
<blockquote>
<p><strong>PONDER</strong></p>
<p>Can you change <code>Album</code>'s <code>compareTo</code> to induce a reversed ordering, i.e., in descending order?</p>
</blockquote>
<h2 id="comparator"><a class="header" href="#comparator"><code>Comparator</code></a></h2>
<p>The <code>ComparABLE</code> interface is used to define a "natural ordering" for an object.
What exactly does that mean?</p>
<p>You should use <code>Comparable</code> when there is an argument to made that there is an <em>obvious</em> way to compare two objects of a given type.
For example, the <code>String</code> class in Java implements the <code>Comparable</code> interface.
It defines what many would <em>naturally</em> expect when they compare two <code>String</code> objects, say, for the purpose of sorting.
It compares <code>String</code>s using their lexicographic ordering, i.e., their alphabetic order.</p>
<p>However, sometimes you need to order a collection of objects using something other than its natural order.
Or you need to order a collection of objects that cannot be reasonably considered to have a "natural" ordering for all circumstances.
These are cases in which you need to define, on an as-needed basis, a custom comparison between two objects.</p>
<p>That's where the <code>ComparATOR</code> interface comes in.
These two interfaces are annoyingly similarly named, I know.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>So, for example, suppose we need to compare albums by their <code>price</code>, and not by their "natural" ordering based on <code>title</code>.</p>
<p>The <code>Comparator</code> interface defines one abstract method that must be implemented by subclasses:</p>
<pre><code class="language-java">public int compare(T o1, T o2)
</code></pre>
<p>This is very similar to the <code>compareTo</code> method for the <code>Comparable</code>. The only difference is now we take two parameters instead of one, because <em>both</em> items to be compared are being passed to the method.
That is, the "calling object" is not the one being compared, so <code>this</code> is not really relevant here.</p>
<p>To compare <code>Album</code>s by <code>price</code>, we would create a new class that implements the <code>Comparator</code> interface, and implement the required <code>compare</code> function in that class.</p>
<pre><code class="language-java">public class AlbumPriceComparator implements Comparator&lt;Album&gt; {
  public int compare(Album o1, Album o2) {
    if (o1.getPrice() &gt; o2.getPrice()) {
      return 1; // Can return any positive integer
    } else if (o1.getPrice() &lt; o2.getPrice()) {
      return -1; // Can return any negative integer
    } else {
      return 0;
    }
  }
}
</code></pre>
<p>This comparator object can then be used to impose "custom" orderings on <code>Album</code>s.</p>
<p><strong>How does this help us?</strong> The <code>Collections.sort</code> function has an overloaded version that takes two parameters:</p>
<ul>
<li>A collection of objects</li>
<li>A comparator to use for pairwise comparisons</li>
</ul>
<p>If you use this version of the <code>Collections.sort</code> function, you <em>don't</em> need the objects being sorted to be <code>ComparABLE</code>. This is because the second parameter, the <code>ComparATOR</code>, knows how to compare those objects.</p>
<pre><code class="language-java">List&lt;Album&gt; albums = ...; // Same list as before
Comparator&lt;Album&gt; priceComp = new AlbumPriceComparator();

// Sort the albums in ascending order of price
// Doesn't matter here whether or not Album implements Comparable
Collections.sort(albums, priceComp);
</code></pre>
<h2 id="in-the-next-lesson"><a class="header" href="#in-the-next-lesson">In the next lesson...</a></h2>
<p><strong>We can also dynamically create <code>Comparator</code>s on an as-needed basis.</strong>
Comparators are useful when you don't know upfront how a collection of objects is going to be compared or sorted.</p>
<p>Continuing with the Album example, consider your music library in whatever application you use to manage and listen to your music.
Chances are you've seen a "table view" that lists all the songs in your library, and you can click on the columns in that table to change how the songs are sorted.
E.g., if you click on "Title" the songs will be sorted by title. If you click on "Artist" the order will change. If you click again, it'll reverse it.</p>
<p>These are <em>dynamic</em> changes in the current sort order, i.e., they are happening while the program (the application, Spotify or whatever) is running.
Can we programmatically spin up new <code>Comparator</code>s to support these changes in desired sort orders?</p>
<p><strong>Doesn't this seem like a lot of work to just write one <code>compare</code> function?</strong>
All we really care about is that <code>compare</code> function, but because we need to "pass" the <code>compare</code> function to the <code>sort</code> function, we went through the rigmarole of wrapping it in a class and creating an object.</p>
<p>In the next lesson, we'll learn about using <em>lambdas</em> in Java to concisely create new <code>Comparator</code>s.
Lambdas allow us to treat functions as <em>values</em> that can be stored and passed around, e.g., as parameters to other functions.
We'll use that as a springboard to learn about lambdas and functional programming more generally.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comparators"><a class="header" href="#comparators">Comparators</a></h1>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>This lesson provides more information about <code>Comparator</code>s in Java.
While conceptually simple, <code>Comparator</code>s are also used here as a vehicle to introduce a number of new concepts and syntaxes that may be unfamiliar.
Specifically, in this lesson we will:</p>
<ul>
<li>Recap what we learned about <code>Comparator</code>s in the previous lesson.</li>
<li>Learn about <em>lambdas</em>, using <code>Comparator</code>s as a concrete usage example.</li>
<li>Learn about <em>method references</em>, using <code>Comparator</code>s as a concrete usage example.</li>
</ul>
<p>The next lesson will dive into lambdas more deeply and <em>functional interfaces</em> more generally.</p>
<h2 id="recap-1"><a class="header" href="#recap-1">Recap</a></h2>
<p>In the <a href="14_comparators/../13_comparables/">previous lesson</a>, we learned about the <code>Comparable</code> and <code>Comparator</code> interfaces.
To recap the main difference between the two:</p>
<ul>
<li>The <code>Comparable</code> interface is used to define a "natural ordering" for objects of a given type. If you need to define an ordering for some data type (class) you have created, then you make that class implement the <code>Comparable</code> interface. This allows you to make instances of that class <em>comparable</em> to each other. A class that implements <code>Comparable</code> must implement a <code>compareTo</code> instance method.</li>
<li>The <code>Comparator</code> interface is used to define orderings for classes that <em>don't</em> have a natural ordering, or to define orderings in addition to a class's natural ordering. This is useful when you are defining a comparison to help solve a particular problem. <code>Comparators</code> are usually not defined as instance methods for the objects being compared.</li>
</ul>
<p>We worked with an <code>Album</code> class that had the following fields.
We'll continue with the same example in this lesson.</p>
<ul>
<li><code>String title</code></li>
<li><code>String artist</code></li>
<li><code>int year</code></li>
<li><code>double price</code></li>
</ul>
<p>(Assume that we have defined getter methods for all the instance variables above.)</p>
<p>There are many ways of defining <code>Comparator</code>s in Java.
We will explore them in this lesson, starting with the most basic (repeated from the previous lesson), and then consider some more convenient alternatives.</p>
<h2 id="defining-a-comparator-in-a-separate-class"><a class="header" href="#defining-a-comparator-in-a-separate-class">Defining a <code>Comparator</code> in a separate class</a></h2>
<p>Recall that the <code>Comparator</code> interface defines one abstract method: <code>public int compare(Album a1, Album a2)</code>.</p>
<p>The simplest way to create a <code>Comparator</code> for <code>Album</code> objects is to create a separate class that implements the <code>Comparator</code> interface.</p>
<p>Let's consider a comparator that compares albums by their <code>title</code>.</p>
<pre><code class="language-java">// The Comparator interface only has one abstract method
public class AlbumTitleComparator implements Comparator&lt;Album&gt; {

  public int compare(Album a1, Album a2) {
    return a1.getTitle().compareTo(a2.getTitle());
  }
}
</code></pre>
<p>The <code>Comparator</code> above can be used in functions like <code>Collections.sort</code> like below.
We create a new instance of the comparator object, and pass that object as a second parameter to the <code>sort</code> function.</p>
<pre><code class="language-java">List&lt;Album&gt; albums = ...; // Assume this list is populated

Comparator&lt;Album&gt; titleComp = new AlbumTitleComparator();
Collections.sort(albums, titleComp);
</code></pre>
<p>This version of the <code>sort</code> function will now use the specified comparator for the pairwise comparisons during the sorting process.
As a result, the list of albums will be sorted by the title name in ascending order.</p>
<p>In essence, we have <em>parameterised</em> the comparison procedure in the <code>sort</code> function, thereby making the <code>sort</code> function more generally usable.
Because we tell it what comparator to use, the same <code>sort</code> function can be used to sort objects using <em>any ordering we define</em>.
We only need to define comparators and pass them to the function as parameters.</p>
<h2 id="lambdas"><a class="header" href="#lambdas">Lambdas</a></h2>
<p>In the example above, we created a whole new class (<code>AlbumTitleComparator</code>) just to define a single function (the <code>compare</code> function).
What's more, we created a new instance of the comparator only to pass it to the <code>sort</code> function.
We never called the <code>compare</code> function ourselves.</p>
<p>All this to say: all we <em>really</em> care about in that comparator class is the <code>compare</code> function.
Can we define it separately, instead of wrapping it in a class and creating a new object to hold the function?</p>
<p>This is where the <em>lambda</em> syntax comes in. Lambdas have the following basic "anatomy":</p>
<pre><code>(&lt;params&gt;) -&gt; &lt;lambda body&gt;;
</code></pre>
<blockquote>
<p>A lambda is an anonymous function.</p>
</blockquote>
<p>Since the lambda is a function, it has inputs (<code>&lt;params&gt;</code>) and it has a body (<code>&lt;lambda body&gt;</code>).
But, since it's anonymous, it doesn't have a name.
And this is okay!
The <em>writer</em> of a lambda is usually not the one who <em>calls</em> the lambda, so we often don't need to name the function.</p>
<p>However, we <em>can</em> store the lambda in a variable that has a name, or we can pass lambdas to other functions as parameters.</p>
<h3 id="writing-a-comparator-using-a-lambda"><a class="header" href="#writing-a-comparator-using-a-lambda">Writing a comparator using a lambda</a></h3>
<p>With that in mind, let's take a look at what a comparator looks like expressed as a lambda.
We'll start simple, by defining a comparator that only compares <code>Album</code>s by their <code>title</code>.</p>
<p>When we create <code>Comparator</code>s, what we're <em>really</em> trying to create is a <code>compare</code> function.
Lambdas allow us to do that without going through the steps of creating a new class that implements the <code>Comparator</code> interface.
The key thing is that our compiler still thinks of the resulting comparator as a <code>Comparator</code> object.</p>
<p>The code below defines a <code>Comparator</code> using the lambda syntax.
This code is considerably more concise than the previous example — in particular, we don't need to create a new class.
This <code>titleComp</code> comparator can be used in the same way as the previous example.</p>
<pre><code class="language-java">Comparator&lt;Album&gt; titleComp = (a1, a2) -&gt; a1.getTitle().compareTo(a2.getTitle());
</code></pre>
<p>Let's break down the code above.</p>
<ul>
<li><strong><code>Comparator&lt;Album&gt; titleComp</code></strong> — Everything on the left-hand-side of the variable assignment should be familiar. We are declaring a variable of type <code>Comparator&lt;Album&gt;</code> called <code>titleComp</code>. This part is the same whether or not we use the lambda syntax.</li>
<li>Everything on the right-hand-side of the variable assignment is the <em>lambda</em>. In particular, the lambda represents the <code>compare</code> function.
<ul>
<li><strong><code>(a1, a2)</code></strong> — These are the two parameters to the <code>compare</code> function. Observe that we don't need to specify the types of the parameters <code>a1</code> and <code>a2</code>. Because the lambda is being declared as a comparator of <code>Album</code>s, the compiler can infer these types.</li>
<li><strong><code>-&gt;</code></strong> — This is the separator between the lambda's parameters and the function body.</li>
<li><strong><code>a1.getTitle().compareTo(a2.getTitle())</code></strong> — This expression<sup class="footnote-reference" id="fr-expression-1"><a href="#footnote-expression">1</a></sup> is the body of the lambda. The expression as a whole evaluates to an <code>int</code>. Remember that the <code>compare</code> function <em>must</em> return an <code>int</code>, so if this expression evaluates to anything but an <code>int</code>, your program won't compile.</li>
</ul>
</li>
</ul>
<p>In most cases, lambdas are single-line functions that return values.
If a lambda has only one line, and that line is an expression, there is no need to use the <code>return</code> keyword.
The value of that expression is returned implicitly.</p>
<p>We can write same lambda in "long form":</p>
<pre><code class="language-java">Comparator&lt;Album&gt; titleComp = (Album a1, Album a2) -&gt; {
  return a1.getTitle().compareTo(a2.getTitle());
}
</code></pre>
<p>By using curly braces in the lambda, we can write functions that include multiple lines.
This is sometimes necessary, e.g., if you need to write code that uses loops.
At that point, the lambda starts to look like a "plain old function", and you need to explicitly use the <code>return</code> keyword to return a value.</p>
<p>The lambdas above can be used in the same way we've already seen.
For example, if we want to sort a list of albums by title:</p>
<pre><code class="language-java">List&lt;Album&gt; albums = ...; // Assume this list is populated

// Create the comparator using the lambda syntax
Comparator&lt;Album&gt; titleComp = (a1, a2) -&gt; a1.getTitle().compareTo(a2.getTitle());

// Pass the comparator to the sort function
Collections.sort(albums, titleComp);
</code></pre>
<p>In the example above, the comparator is a <em>value</em> that is passed to the <code>sort</code> function as a parameter.
You can write the function without first storing it in the <code>titleComp</code> variable.</p>
<pre><code class="language-java">Collections.sort(albums, (Album a1, Album a2) -&gt; a1.getTitle().compareTo(a2.getTitle()));
</code></pre>
<p>This time we <em>do</em> need to specify the types of <code>a1</code> and <code>a2</code>, because this time the compiler doesn't have clues from which to infer the the types of those parameters.</p>
<h3 id="more-lambda-examples"><a class="header" href="#more-lambda-examples">More lambda examples</a></h3>
<h4 id="compare-albums-by-year-an-int"><a class="header" href="#compare-albums-by-year-an-int">Compare albums by year (an <code>int</code>)</a></h4>
<p>Here is an example comparator that would compare two <code>Album</code>s by <code>year</code>.</p>
<pre><code class="language-java">Comparator&lt;Album&gt; yearComp = (a1, a2) -&gt; a1.getYear() - a2.getYear();
</code></pre>
<blockquote>
<p><strong>PONDER</strong></p>
<p>Why does the code above work as a year comparator?</p>
</blockquote>
<details>
<summary>Hint</summary>
<p>The <code>compare</code> function needs to return a positive integer if <code>a1</code>'s <code>year</code> is greater than <code>a2</code>'s <code>year</code>; a negative number <code>a1</code>'s <code>year</code> is less than <code>a2</code>'s <code>year</code>; and 0 if they are equal. We don't care what the actual returned values are, as long as their signs are correct. Simply subtracting the two years successfully computes such an integer.</p>
</details>
<h4 id="compare-albums-by-price-a-double"><a class="header" href="#compare-albums-by-price-a-double">Compare albums by price (a <code>double</code>)</a></h4>
<blockquote>
<p><strong>PONDER</strong></p>
<p>If we need to compare <code>Album</code>s by <code>price</code>, which is declared as a <code>double</code>, we can't simply compute the difference between the two prices.
Why do you think this is?</p>
</blockquote>
<details markdown="1">
<summary>Hint</summary>
[The result of this difference will be a `double`](../02_arithmetic_and_testing/), which does not match the required signature for the `compare` function.
</details>
So we _could_ write the function in "long form":
<pre><code class="language-java">Comparator&lt;Album&gt; priceComp = (a1, a2) -&gt; {
  if (a1.getPrice() &gt; a2.getPrice()) {
    return 1; // or any positive integer
  } else if (a1.getPrice() &lt; a2.getPrice()) {
    return -1; // or any negative integer
  } else {
    return 0;
  }
}
</code></pre>
<p>Alternatively, the <a href="14_comparators/../03_lists_maps_existing_classes#boxed-primitives">boxed primitive types</a> provide a handy static function meant to do just this.
The above comparator can be written as:</p>
<pre><code class="language-java">Comparator&lt;Album&gt; priceComp = (a1, a2) -&gt; Double.compare(a1.getPrice(), a2.getPrice());
</code></pre>
<p>The <code>Double.compare</code> function returns a positive number, negative number, or 0, as appropriate for its two given parameters.
Similarly, other primitive types provide similar static functions, e.g., <code>Long.compare</code>, <code>Float.compare</code>, etc.</p>
<h2 id="method-references--key-extractors"><a class="header" href="#method-references--key-extractors">Method references / key extractors</a></h2>
<p>Finally, we can use the <em>method reference</em> or <em>key extractor</em> syntax.</p>
<p>You already know what <em>methods</em> are in Java.
You can <em>call</em> or <em>invoke</em> or <em>apply</em> methods on objects.
For example, <code>obj.someMethod()</code> will call <code>someMethod()</code> on the <code>obj</code> object.</p>
<p>However, it is also possible to simply "refer to" instance methods in Java, <em>without</em> calling them.
We do this using the method reference or "key extractor" syntax.</p>
<p>For example,</p>
<ul>
<li>To refer to an instance method on a particular object, you would use: <code>obj::instanceMethodName</code>, where <code>obj</code> is some object you have created, and <code>instanceMethodName</code> is an instance method for that particular object.</li>
<li>To refer to an instance method for any arbitrary object of a particular type, you would use <code>ClassName::instanceMethodName</code>, where <code>ClassName</code> is the name of a class, and <code>instanceMethodName</code> is an instance method in the class.</li>
</ul>
<p>These are useful because sometimes you end up creating lambdas that do nothing but call an existing method on an object.
In these cases, it's easier and simpler to simply "point to" the method you want to call instead of creating a lambda that takes a parameter and calls an existing named method on that parameter.</p>
<h3 id="creating-a-comparator-using-a-method-reference"><a class="header" href="#creating-a-comparator-using-a-method-reference">Creating a comparator using a method reference</a></h3>
<p>The <code>Comparator</code> interface provides a <code>Comparator.comparing</code> static method.
The <code>Comparator.comparing</code> method takes <strong>a lambda</strong> OR <strong>a method reference</strong> as a parameter.</p>
<p>If you give it a lambda, you define the lambda to follow the <code>compare</code> function signature.
You are more-or-less doing what we've already done above.</p>
<p>If you give it a method reference, you "point to" the method in the class that you want the comparator to use in its comparison, and it uses that method to create a <code>compare</code> function.</p>
<p>So here's the third and final way in which we can create comparators:</p>
<pre><code class="language-java">Comparator&lt;Album&gt; titleComp = Comparator.comparing(Album::getTitle);
</code></pre>
<p>A few things to notice about the code above:</p>
<ul>
<li>There are no parentheses (<code>()</code>) after the <code>getTitle</code>, because we are not <em>calling</em> the method; we are only referring to it.</li>
<li>We use the key extractor to tell the <code>Comparator.comparing</code> method to create a new <code>Comparator</code> that calls <code>getTitle</code> on each of its parameters, and compares the results.</li>
<li>It's important that our method reference refers to a method that returns a <code>ComparABLE</code> value (e.g., a <code>String</code>, a primitive type, any class you create that implements <code>Comparable</code>). If the method we refer to returns some type that cannot be compared, then we can't rely on this shorthand, because Java won't know how to compare them.</li>
</ul>
<h2 id="chaining-comparators"><a class="header" href="#chaining-comparators">Chaining comparators</a></h2>
<p>Remember <code>default</code> methods?
The <code>Comparator</code> defines a bunch of really useful <code>default</code> methods.
These methods are instance methods that exist on all <code>Comparator</code> objects (just like you've learned about <code>default</code> methods).</p>
<p>We know that the <code>Comparator</code> interface only defines one abstract method: <code>compare</code>.</p>
<h3 id="thencomparing"><a class="header" href="#thencomparing"><code>thenComparing</code></a></h3>
<p>The <code>thenComparing</code> function lets us combine multiple comparators to create "composed" comparators.
For example, to deal with tie-breakers.</p>
<p>Suppose we want to compare <code>Album</code>s by <code>artist</code> name, and then for <code>Album</code>s with the same <code>artist</code> name, we want to compare them based on their <code>title</code>.
We can use the <code>thenComparing</code> function to chain an <strong>artist comparator</strong> and a <strong>title comparator</strong>.
The result will be a <em>third</em> comparator that is the combination of the previous two.</p>
<p>Like <code>Comparator.comparing</code>, <code>thenComparing</code> can take either a <strong>lambda</strong> or a <strong>method reference</strong> as a parameter, and returns a <code>Comparator</code> instance.</p>
<pre><code class="language-java">// Written step-by-step
Comparator&lt;Album&gt; artistComp = Comparator.comparing(Album::getArtist);
Comparator&lt;Album&gt; titleComp = Comparator.comparing(Album::getTitle);
Comparator&lt;Album&gt; artistTitleComp = artistComp.thenComparing(titleComp);

// Written in one statement
Comparator&lt;Album&gt; artistTitleComp = Comparator.comparing(Album::getArtist).thenComparing(Album::getTitle);

// Sort albums by artist name, and sort by title for albums by the same artist
Collections.sort(albums, artistTitleComp);
</code></pre>
<p>This is a concise and convenient way to quickly chain together multiple comparisons to create complex comparison criteria.
Because <code>thenComparing</code> returns a <code>Comparator</code>, you can chain together several <code>thenComparing</code> calls.</p>
<h3 id="reversed"><a class="header" href="#reversed"><code>reversed</code></a></h3>
<p>Another handy <code>default</code> method on <code>Comparator</code>s is the <code>reversed</code> method.
It simply reverses the <code>Comparator</code> object on which it is called, and returns a new <code>Comparator</code>.</p>
<pre><code class="language-java">// Written step-by-step
Comparator&lt;Album&gt; titleComp = Comparator.comparing(Album::getTitle);
Comparator&lt;Album&gt; reversed = titleComp.reversed();

// Written in one statement
Comparator&lt;Album&gt; reversed = Comparator.comparing(Album::getTitle).reversed();

// Sort albums in DESCENDING ORDER of title
Collections.sort(albums, reversed);
</code></pre>
<p>Like <code>thenComparing</code>, <code>reversed</code> also returns a <code>Comparator</code> object.
This means that calls to <code>reversed</code> and <code>thenComparing</code> can be chained together to create various comparison combinations.</p>
<blockquote>
<p><strong>DISCUSS</strong></p>
<p>How would you use method references, <code>thenComparing</code>, and <code>reversed</code> to sort <code>Album</code>s by <code>year</code> in DESCENDING order, sorting <code>Album</code>s within the same year by <code>artist</code> in ASCENDING order, followed by <code>title</code> in ASCENDING order?</p>
</blockquote>
<hr>
<ol class="footnote-definition"><li id="footnote-expression">
<p>Recall that an <em>expression</em> is anything that evaluates to a value. <a href="#fr-expression-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="lambdas-1"><a class="header" href="#lambdas-1">Lambdas</a></h1>
<p>In the previous lesson, we learned about expressing <code>Comparator</code>s more concisely using the lambda syntax.
This is possible because <code>Comparator</code> is a <em>functional interface</em>.</p>
<blockquote>
<p>A functional interface is an interface in Java with exactly one abstract method.</p>
</blockquote>
<p>Because <code>Comparator</code> only has one abstract method (<code>compare</code>), we can concisely initialise <code>Comparator</code>s like so:</p>
<pre><code class="language-java">Comparator&lt;Album&gt; comp = (a1, a2) -&gt; a1.getTitle.compareTo(a2.getTitle());
</code></pre>
<p>The lambda above defines a function, and because there is only one abstract method in <code>Comparator</code>, there is no ambiguity about what that function is.
It's the <code>compare</code> function!
This means the compiler is able to infer things like the parameter types of <code>a1</code> and <code>a2</code>, and check that the function returns an <code>int</code> as is required by the <code>compare</code> function.</p>
<p>There are a whole bunch of other lambdas available in Java — too many to describe here!
So in this lesson, we'll focus our discussion on three useful types of lambdas available in Java:</p>
<ul>
<li><code>Function&lt;T, R&gt;</code>: This is the most generally-useful type of lambda. It represents a function that takes in one input and produces an output. The <code>T</code> is a placeholder for the input type, and the <code>R</code> is a placeholder for the result type.</li>
<li><code>Predicate&lt;T&gt;</code>: A predicate is essentially a function that returns a boolean. The <code>T</code> is a placeholder for the input type. There is no placeholder for the output type because the output is a <code>Boolean</code>.</li>
<li><code>Consumer&lt;T&gt;</code>: A consumer is an operation that takes in a single input and returns no result. Sort of like a lambda version of a <code>void</code> method. The <code>T</code> is a placeholder for the input type. There is no placeholder for the output type because there <em>is</em> no output.</li>
</ul>
<p>All of the above are <em>functional interfaces</em>, meaning they are all interfaces that contain exactly one abstract method each.
The three functional interfaces above are rather more generally useful than the <code>Comparator</code> interface.
While the <code>Comparator</code> interface defines a function for a very specific purpose (taking in two objects and returning an <code>int</code> based on their comparison), the lambdas above can be used in a wide variety of problems.</p>
<p>Let's talk about them.</p>
<h2 id="function"><a class="header" href="#function">Function</a></h2>
<p>A <code>Function</code> is exactly what you think it is: it's a procedure that takes in some input value and produces some output.</p>
<p>When you use a <code>Function</code>, you must also declare its input and output types.
Here are several examples of <code>Function</code>s written as lambdas:</p>
<p><strong>A function that takes in a number and returns its square:</strong></p>
<p>This function is expected to take in an integer as its input and return an integer as output.
Therefore, we declare the function using <code>Function&lt;Integer, Integer&gt;</code>.</p>
<pre><code class="language-java">Function&lt;Integer, Integer&gt; square = num -&gt; num * num;
</code></pre>
<p>Because the function above takes a single parameter, we can omit the parentheses around the parameter <code>num</code>.
We also don't need to specify the type of <code>num</code>, because we've already declared that the function is a <code>Function&lt;Integer, Integer&gt;</code>, i.e., its input type is an <code>Integer</code> and its output type is <code>Integer</code>.</p>
<p><strong>A function that takes in a String and returns its length:</strong></p>
<p>This function is expected to take in a string and return an integer.
So we declare it using <code>Function&lt;String, Integer&gt;</code>.</p>
<pre><code class="language-java">Function&lt;String, Integer&gt; stringLength = s -&gt; s.length();
</code></pre>
<blockquote>
<p><strong>PONDER</strong></p>
<p>The above function is using a lambda only to call an existing method on the input. This is the exact use case for using method references. How would you re-write the above function using a method reference? <strong>Try to answer this yourself before expanding the answer below.</strong></p>
</blockquote>
<details>
<summary>Click to see answer</summary>
<pre><code class="language-java">Function&lt;String, Integer&gt; stringLength = String::length;
</code></pre>
</details>
<p><strong>A function that takes in an Album and returns a String describing it:</strong> (e.g., <code>"Rubber Soul by The Beatles"</code>)</p>
<pre><code class="language-java">Function&lt;Album, String&gt; stringDesc = a -&gt; a.getTitle() + " by " + a.getArtist();
</code></pre>
<p><strong>The <code>Function</code> interface has one abstract method: the <code>apply</code> method.</strong>
The method takes in one parameter and returns one value.
The types for the parameter and the returned value are decided when the <code>Function</code> is first created, as you can see in the examples above.
This <code>apply</code> method is what you are defining when you write a lambda.</p>
<h3 id="a-motivating-example"><a class="header" href="#a-motivating-example">A motivating example</a></h3>
<p>A common task in programming problems is to apply some operation to all the items in a list, and produce a list of results.
This is commonly referred to as a <strong>map</strong> operation, i.e., you are <em>mapping</em> some input value to some output value.
You will be surprised at how often this pattern appears in your programs.</p>
<p>In a <strong>map</strong> operation:</p>
<ul>
<li>The <strong>input</strong> is a list of some type (e.g., <code>List&lt;T&gt;</code>).</li>
<li>The <strong>output</strong> is a list of some type (e.g., <code>List&lt;R&gt;</code>), where <code>R</code> can be the same as or different from <code>T</code>.</li>
<li>The input and output lists are the same length, because the output is obtained by applying a function to each item in the input.</li>
</ul>
<p>For example, suppose you are a teacher and your students have just taken an exam.</p>
<p>Suppose you realise that the class as a whole performed poorly on a particular question that was not clearly worded.
As a result, you need to add 2 points to everyone's exam scores.</p>
<p>First, let's acknowledge that you could easily write this using a <code>for</code> loop.</p>
<pre><code class="language-java">public static List&lt;Integer&gt; mapToAdjustedScores(List&lt;Integer&gt; examScores) {
  List&lt;Integer&gt; result = new ArrayList&lt;&gt;();

  for (int current : examScores) {
    int adjusted = current + 2; // This is the "map" operation
    result.add(percent);
  }

  return result;
}
</code></pre>
<p>As another example, the maximum possible score is 44 points, so your students have scores like <code>42</code>, <code>44</code>, <code>40</code>, <code>39</code>, etc.
You would like to turn all of these scores into percentages, i.e., by dividing each of them by <code>44</code> and multiplying by <code>100</code>.</p>
<p>Again, easily doable using a <code>for</code> loop.</p>
<pre><code class="language-java">public static List&lt;Double&gt; mapToPercentages(List&lt;Integer&gt; examScores) {
  List&lt;Double&gt; result = new ArrayList&lt;&gt;();

  for (int current : examScores) {
    double percent = ((double) current / 44) * 100; // This is the "map" operation
    result.add(percent);
  }

  return result;
}
</code></pre>
<p>Observe that <em>the two functions are nearly identical</em>, except for one thing: they differ in the operation performed on each list item within the for loop (and consequently, the data type of the resulting lists).
This is because both functions are versions of the <strong>map</strong> pattern in action. Can we abstract out the common parts so that only the differing parts (the insides of the for loops) need to be specified each time?</p>
<p>In other words, can we <em>parameterise</em> the map operation so that the nearly-identical functions don't need to be written multiple times?</p>
<h3 id="parameterising-our-mapper"><a class="header" href="#parameterising-our-mapper">Parameterising our mapper</a></h3>
<p>Instead of the two functions above, consider the following generalised <code>map</code> function.
We can take in a function as a parameter to this function, allowing this <code>map</code> function to be more generally useful.</p>
<p>There is some new notation in this code, which I will explain below.
Please take some time to read the code and its accompanying comments.</p>
<pre><code class="language-java">// T and R are declared as "type parameters"
public static &lt;T, R&gt; List&lt;R&gt; map(List&lt;T&gt; inputList, Function&lt;T, R&gt; func) {
  // The type of this list should match the output type of the Function parameter
  List&lt;R&gt; outputList = new ArrayList&lt;&gt;();

  // The type in this for loop should match the type of the input list
  for (T current : inputList) {

    // Recall that "apply" is the name of the abstract method in the Function interface.
    // We call "func" on the current item and save the result in a variable.
    R result = func.apply(current);

    // Store the result in the output list.
    outputList.add(result);
  }

  return outputList;
}
</code></pre>
<p>Some key things to note about the code above:</p>
<ul>
<li><strong><code>&lt;T, R&gt;</code></strong> — <code>T</code> and <code>R</code> are <strong>type parameters</strong> in this function. We don't yet know what those types will be, so for now we declare them as parameters, similar to how <code>inputList</code> and <code>func</code> are "value parameters".<sup class="footnote-reference" id="fr-generics-1"><a href="#footnote-generics">1</a></sup></li>
<li><strong><code>Function&lt;T, R&gt; func</code></strong> — Notice this <code>Function</code>'s input and output types. The input type, <code>T</code>, matches the type of each item in the <code>inputList</code>. The output type, <code>R</code>, matches the type of each item in the returned list, i.e., <code>List&lt;R&gt;</code>. At this point we don't know what the actual types for <code>T</code> and <code>R</code> are.</li>
<li><strong><code>func.apply(current)</code></strong> — Inside the <code>for</code> loop, we apply or call our mapper function on each item in the input list. Remember that at the end of the day <code>Function</code> is just an interface. It contains a single abstract method called <code>apply</code>. In this line, we call that <code>apply</code> function, giving it the current item in the list as an input.
<ul>
<li>Because we've declared the output type of our function to be <code>R</code>, we can use <code>R</code> as the data type when we store the result in a variable.</li>
</ul>
</li>
</ul>
<h4 id="usage-examples"><a class="header" href="#usage-examples">Usage examples</a></h4>
<p>We can now use our <code>map</code> function to accomplish both tasks above, by only writing the code that does the mapping, and not having to re-write the rest of the function each time.
We can express those operations as lambdas, given as parameters to our <code>map</code> function.</p>
<pre><code class="language-java">List&lt;Integer&gt; scores = List.of(42, 39, 43, 44, 40, 37, 35);

// Bump all scores by 2 using our map function
List&lt;Integer&gt; bumpedScores = map(scores, s -&gt; s + 2);
</code></pre>
<p>When we call <code>map</code> in the code above, the type parameters <code>T</code> and <code>R</code> are now resolved to actual types. <code>T</code> is now <code>Integer</code>, because the input list is a list of integers, and <code>R</code> is also <code>Integer</code> in this case, because our lambda's return type is integer.</p>
<p>We can also turn all scores into percentages.</p>
<pre><code class="language-java">// Turn scores into percentages
List&lt;Double&gt; percentages = map(scores, s -&gt; ((double) s / 44) * 100);
</code></pre>
<p>In the call above, <code>T</code> is <code>Integer</code>, and <code>R</code> is <code>Double</code>.</p>
<p>The <strong>map pattern</strong> is an extremely common programming pattern.
Virtually every mainstream programming language provides <code>map</code> as an operation that can be performed on collections of objects, and Java is no exception.
We will see how to use this in the next lesson on Streams.</p>
<p>For now, let's continue talking about different types of lambdas available in Java, and move on to the <code>Predicate</code>.</p>
<h2 id="predicate"><a class="header" href="#predicate">Predicate</a></h2>
<p>A <code>Predicate</code> is a function that returns a Boolean value.
Unlike a <code>Function</code>, you only need to specify an input type for a <code>Predicate</code>, because the output type is always <code>Boolean</code>.</p>
<p>Here are several examples of <code>Predicate</code>s written as lambdas.</p>
<p><strong>A predicate that takes in an integer and check if it is even.</strong></p>
<pre><code class="language-java">Predicate&lt;Integer&gt; isEven = num -&gt; num % 2 == 0;
</code></pre>
<p><strong>A predicate that takes in an Album and checks if it was released in this millenium.</strong></p>
<pre><code class="language-java">Predicate&lt;Album&gt; inThisMillenium = album -&gt; album.getYear() &gt; 2000;
</code></pre>
<blockquote>
<p>Both of the above can also be declared as <code>Function</code>s, i.e., as <code>Function&lt;Integer, Boolean&gt;</code> and <code>Function&lt;Album, Boolean&gt;</code>. The <code>Predicate</code> exists as a useful abstraction because creating boolean functions is a common use case in programming, as we will see. <strong><code>Predicate</code>s are, in essence, a way to parameterise boolean conditions.</strong></p>
</blockquote>
<p>The <code>Predicate</code> interface has one abstract method: the <code>test</code> method.
The <code>test</code> method takes in one input and returns a <code>boolean</code>.
That <code>test</code> method is what you are implementing when you express a <code>Predicate</code> as a lambda.</p>
<h3 id="a-motivating-example-1"><a class="header" href="#a-motivating-example-1">A motivating example</a></h3>
<p>Another common task in programming problems is to <strong>filter</strong> a collection of items based on some condition.
Like <code>map</code>, <code>filter</code> is an extremely common sub-step in solving programming problems.</p>
<p>In a <strong>filter</strong> operation:</p>
<ul>
<li>The <strong>input</strong> is a list of some type (e.g., <code>List&lt;T&gt;</code>).</li>
<li>The <strong>output</strong> is a list of the <em>same</em> type (<code>List&lt;T&gt;</code>).</li>
<li>The output is a subset of the input, because the output is obtained by filtering the input based on some condition.</li>
</ul>
<p>For example, continuing with the teacher example above, let's say you want to find out which students scored below a 70% on the exam (i.e., scores that are less than 31).
The first thing you need to do is filter out the scores that are greater than 31.</p>
<p>We could do this easily using a for loop.</p>
<pre><code class="language-java">public static List&lt;Integer&gt; filterLessThan70(List&lt;Integer&gt; scores) {
  List&lt;Integer&gt; result = new ArrayList&lt;&gt;();

  for (int current : scores) {
    if (current &lt; (0.7 * 44)) { // This is the filter condition
      result.add(current);
    }
  }

  return result;
}
</code></pre>
<h3 id="parameterising-our-filter"><a class="header" href="#parameterising-our-filter">Parameterising our filter</a></h3>
<p>Like we did with the <code>map</code> function we can make our <code>filter</code> more generally usable by parameterising the condition on which the list is filtered.</p>
<p>Consider the code below. We have re-written our <code>filter</code> function to only include the common elements of a typical <code>filter</code> operation, and parameterised things that might change from one instance to another.
For example, we have parameterised the data type of the input and output lists, and we have parameterised the predicate used to test whether a given item should be kept or filtered out.</p>
<pre><code class="language-java">// T is declared as a "type parameter". We don't need to declare an output
// type because it is the same as the input type.
public static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; inputList, Predicate&lt;T&gt; pred) {
  List&lt;T&gt; outputList = new ArrayList&lt;&gt;();

  for (T current : inputList) {
    if (pred.test(current)) { // Use predicate to check the condition
      // If the predicate passes, save the current item
      outputList.add(current);
    }
  }

  return outputList;
}
</code></pre>
<p>In the code above, we use the <code>Predicate</code>'s <code>test</code> method to invoke the boolean function. If the <code>test</code> passes (i.e., it returns <code>true</code>), we save that list item to be returned in the output list.</p>
<h4 id="usage-examples-1"><a class="header" href="#usage-examples-1">Usage examples</a></h4>
<p>We can use our <code>filter</code> function to accomplish filter tasks like the example above.</p>
<pre><code class="language-java">List&lt;Integer&gt; scores = List.of(42, 39, 43, 44, 40, 37, 35);

// Filter down to scores less than 70% of 44
List&lt;Integer&gt; lessThan70Percent = filter(scores, s -&gt; s &lt; (0.7 * 44));

// Filter down to "A" scores (e.g., greater than 90%)
List&lt;Integer&gt; aScores = filter(scores, s -&gt; s &gt; (0.9 * 44));
</code></pre>
<p>The <strong>filter</strong> pattern is also an extremely common programming pattern, available "ready to use" on collections of data in most programming languages.</p>
<h2 id="consumer"><a class="header" href="#consumer">Consumer</a></h2>
<p>Finally, we will talk about the <code>Consumer</code>.
The <code>Consumer</code> is a functional interface used to define operations that have no outputs.</p>
<p>It defines one abstract method: <code>accept</code>. The method takes in one input and returns nothing, i.e., its return type is <code>void</code>.</p>
<p>Here are several examples of consumers:</p>
<p><strong>A consumer that takes in an album and cuts their prices by 10% (heck yeah, sale!).</strong></p>
<pre><code class="language-java">Consumer&lt;Album&gt; discount = album -&gt; album.setPrice(album.getPrice() * 0.9);
</code></pre>
<p><strong>A consumer that takes in a Student and increases the number of units they have completed by 12.</strong></p>
<pre><code class="language-java">Consumer&lt;Student&gt; increaseUnits = student -&gt; student.setUnits(student.getUnits() + 12);
</code></pre>
<h3 id="a-motivating-example-2"><a class="header" href="#a-motivating-example-2">A motivating example</a></h3>
<p>Just like <code>map</code> and <code>filter</code> are patterns for performing different types of operations on lists of data, a third pattern is also extremely common in programming.
And you're already familiar with this!</p>
<p>Consider the <code>for-each</code> loop — it loops over a collection of data, and performs some operation on each item in the list.</p>
<p>We could also write a <code>forEach</code> function that accomplishes this.</p>
<pre><code class="language-java">public static &lt;T&gt; void forEach(List&lt;T&gt; inputList, Consumer&lt;T&gt; consumer) {
  for (T current : inputList) {
    consumer.accept(current);
  }
}
</code></pre>
<p>We now have a function version of the <code>for-each</code> loop!</p>
<h2 id="other-functional-interfaces"><a class="header" href="#other-functional-interfaces">Other functional interfaces</a></h2>
<p>The <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/package-summary.html"><code>java.util.function</code> package</a> lists a number of functional interfaces, of which we have learned about 3 so far.</p>
<p>A key limiting factor in the <code>Function</code>, <code>Predicate</code>, and <code>Consumer</code> is that all of those lambdas can only take a single input.
We often need to write functions (or lambdas) that operate on multiple parameters.</p>
<p>The <code>Comparator</code> interface comes to mind — its <code>compare</code> function takes in two objects, the two objects being compared.</p>
<p>Among the other functions available in <code>java.util.function</code> are:</p>
<ul>
<li><code>BiFunction&lt;T, U, R&gt;</code> — A function that accepts two arguments and produces a result.</li>
<li><code>BiPredicate&lt;T, U&gt;</code> — A function that accepts two arguments and produces a boolean (or a predicate that accepts two arguments).</li>
<li><code>BiConsumer&lt;T, U&gt;</code> — An operation that accepts two input arguments and returns no result.</li>
<li><code>BinaryOperator&lt;T&gt;</code> — An operation upon two operands of the same type, producing a result of the same type as the operands. For example, arithmetic expressions like plus or minus, or boolean expressions like <strong>and</strong> and <strong>or</strong> are examples of binary operators.</li>
</ul>
<p>In many ways, the exact names of all the functional interfaces isn't what's most important.
In the next lesson, we will learn about <em>streams</em>, which allow us to express a series of operations to be performed on lists of data by chaining together calls to functions like <code>map</code>, <code>filter</code>, and <code>forEach</code>.
In these cases, lambdas are written inline as arguments to those functions themselves, and you rarely have to declare that a lambda is a <code>Function</code>, <code>BiFunction</code>, <code>Predicate</code>, etc.</p>
<p>For example, if you had a list of exam scores, and you wanted to:</p>
<ul>
<li>turn each score into a percentage</li>
<li>bump up each percentage by 5</li>
<li>round each percentage to the nearest whole number</li>
<li>filter down to the "A" scores</li>
</ul>
<p>You <em>could</em> do all of that in a for loop, or you could use lambdas and streams. Here's a sneak peak:</p>
<pre><code class="language-java">List&lt;Integer&gt; scores = List.of(42, 39, 43, 44, 40, 37, 35);

List&lt;Double&gt; scoresUpdated = scores.stream()
                                   .map(s -&gt; ((double) s / 44) * 100) // percentages
                                   .map(s -&gt; s + 5) // bump up
                                   .map(Math::round) // round the scores.
                                   .filter(s -&gt; s &gt;= 90) // filter to "A" scores
                                   .toList(); // get the final result list back
</code></pre>
<hr>
<ol class="footnote-definition"><li id="footnote-generics">
<p>This is an example of using <strong>Java generics</strong>. Generics allow you to declare <em>type parameters</em>, i.e, you can use placeholder names for data types, with the understanding that the placeholder will be replaced with an actual type when the code is invoked. This is identical to how you use "normal" parameters for methods and functions: you declare a variable name in the method signature, and when you call the function, that's when the variable actually gets a value. <a href="#fr-generics-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="streams"><a class="header" href="#streams">Streams</a></h1>
<p>Having learned about lambdas in <a href="16_streams/../15_lambdas/">the previous lesson</a>, we will learn about a related construct in Java called <strong>streams</strong>.
Lambdas and streams are often used together.</p>
<p>Streams allow us to take a series of computations we mean to perform on a collection of data, and compose them into a "pipeline".</p>
<p>In this lesson, we'll start with concrete examples of using the Streams API, since on the surface there is very little new or unfamiliar happening here.
Following this, there is a brief discussion about what exactly is meant by "streaming", and some of the underlying properties of streams in Java that are important to know about.</p>
<h2 id="an-example-problem"><a class="header" href="#an-example-problem">An example problem</a></h2>
<p>Before we start, let's recall the <strong>map</strong> and <strong>filter</strong> patterns that we talked about in the previous lesson.</p>
<ul>
<li>In the <strong>map</strong> pattern, we define a function that describes a computation that we want to perform on each item in a collection. The <strong>map</strong> applies that function to each item in the list and returns a new list containing the results (i.e., the result of applying the function to each item in the original list).</li>
<li>In the <strong>filter</strong> pattern, we define a predicate that describes a condition we want to check for each item in a collection. The <strong>filter</strong> tests each item against that condition, and returns a list containing the items that "pass" or "satisfy" the predicate.</li>
</ul>
<p>Continuing with our examples of <code>Album</code> objects, let's suppose we have a list of <code>Album</code>s that we are working with.
For the purposes of this example, let's assume <code>Album</code> objects have the following fields:</p>
<ul>
<li><code>String title</code></li>
<li><code>String artist</code></li>
<li><code>int year</code></li>
<li><code>long unitsSold</code></li>
<li><code>double price</code></li>
</ul>
<p>We are given the following problem prompt:</p>
<blockquote>
<p>Write a program that consumes a list of <code>Album</code> objects, and, for the <code>Album</code>s released after the year 2000, computes the average number of units they have sold.</p>
</blockquote>
<p>Let's consider two solutions to this problem: one using regular <code>for-each</code> loops, like we are used to, and one using streams and lambdas.</p>
<h3 id="a-for-each-loop-solution"><a class="header" href="#a-for-each-loop-solution">A <code>for-each</code> loop solution</a></h3>
<p>As you read the code below, try to identify usage of the <strong>map</strong> or <strong>filter</strong> patterns.</p>
<pre><code class="language-java">public static double averageSalesAfter2000(List&lt;Album&gt; albums) {
  long sum = 0;
  int albumsAfter2000 = 0;

  for (Album current : albums) {
    if (album.getYear() &gt; 2000) {
      long sales = album.getSales();
      sum = sum + sales;
      albumsAfter2000 = albumsAfter2000 + 1;
    }
  }

  if (albumsAfter2000 &gt; 0) {
    return sum / albumsAfter2000;
  } else {
    return 0;
  }
}
</code></pre>
<h3 id="a-streams-solution"><a class="header" href="#a-streams-solution">A streams solution</a></h3>
<p>The same problem can be solved using streams.
The code is below, and an explanation of each line follows.</p>
<pre><code class="language-java">public static double averageSalesAfter2000(List&lt;Album&gt; albums) {
  OptionalDouble result =  albums.stream() // Stream&lt;Album&gt;
    .filter(a -&gt; a.getYear() &gt; 2000) // Stream&lt;Album&gt;
    .mapToLong(a -&gt; a.getUnitsSold()) // LongStream
    .average(); // OptionalDouble

  // After filtering, there may not be any albums left.
  // In that case, we just return 0.
  return result.orElse(0);
}
</code></pre>
<p>In the code above, we have organised a series of computations into a <em>stream pipeline</em>.</p>
<ul>
<li>We first call <code>stream</code> on the list of albums, to turn it into a stream of albums (<code>Stream&lt;Album&gt;</code>). This step is necessary to be able to call the other stream operations.</li>
<li>Then, we use <code>filter</code> to filter down to albums released after the year 2000. We define the condition as a lambda (a <code>Predicate</code>), passed as a parameter to <code>filter</code>.</li>
<li>Then, we use <code>mapToLong</code> to go from a collection of <code>Album</code> objects to a collection of <code>Long</code> values. We could've used <code>map</code> here instead of <code>mapToLong</code>, but using <code>mapToLong</code> means that we get back a stream whose <em>static type</em> is <code>LongStream</code>. This means we have access to a number of useful numerical operations, like <code>average</code>.</li>
<li>The <code>LongStream</code> provides an <code>average</code> method, which we can use to compute the average of the items remaining in the stream. This gives us an <code>OptionalDouble</code> in return. <code>OptionalDouble</code> is a class in Java representing a <code>double</code> which may or may not exist.
<ul>
<li>The reason this double may not exist is that, if the list is empty after filtering, we can't compute an average, because you can't divide by 0.</li>
</ul>
</li>
<li>We get the computed average from the <code>OptionalDouble</code> object and return the value.
<ul>
<li>The <code>orElse</code> method on the <code>OptionalDouble</code> gets us the computed value if it exists, or it gives us a specified "backup" value otherwise.</li>
</ul>
</li>
</ul>
<h2 id="common-stream-operations"><a class="header" href="#common-stream-operations">Common stream operations</a></h2>
<p>The <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/stream/package-summary.html">Streams API</a> provides a whole host of operations that can performed on streams of data.</p>
<p>Here are some commonly used operations you'll want to know about.</p>
<h3 id="filter"><a class="header" href="#filter"><code>filter</code></a></h3>
<p>The <code>filter</code> function is used to discard items that do not match a given condition.
It is called on a <code>Stream</code>, takes a <code>Predicate</code> as a parameter, and returns a <code>Stream</code>.
The <code>Predicate</code> is called on each item in the <code>Stream</code>, and only items for which the result is <code>true</code> are kept in the resulting <code>Stream</code>.</p>
<p>So for example, if you have a list of <code>Album</code> objects, and you want to only keep <code>Album</code>s that were released after the year 2000, you can achieve this using <code>filter</code> as follows:</p>
<pre><code class="language-java">// Assuming "albums" is a List&lt;Album&gt;, populated with records
Stream&lt;Album&gt; filtered = albums.stream()
  .filter((album) -&gt; album.getYear() &gt; 2000);
</code></pre>
<h3 id="map"><a class="header" href="#map"><code>map</code></a></h3>
<p>The <code>map</code> function is used to apply a function to each item in a collection, obtaining a result for each item.
It is called on a <code>Stream</code>, takes a <code>Function</code> as a parameter, and returns a <code>Stream</code>.
The resulting <code>Stream</code> contains the results of applying the function to each item in the original <code>Stream</code>.</p>
<p>For example, if you have a list of <code>Album</code> objects and you would like to compute, for each <code>Album</code>, its total sales (i.e., <code>unitsSold * price</code>), you could use <code>map</code> as follows:</p>
<pre><code class="language-java">// Assuming "albums" is a List&lt;Album&gt;, populated with records
Stream&lt;Double&gt; totalSales = albums.stream()
  .map((album) -&gt; album.getUnitsSold() * album.getPrice());
</code></pre>
<blockquote>
<p><strong>PONDER</strong></p>
<p>Why do you suppose the data type of <code>totalSales</code> above is <code>Stream&lt;Double&gt;</code>?</p>
</blockquote>
<h3 id="reduce"><a class="header" href="#reduce"><code>reduce</code></a></h3>
<p>Finally, the <code>reduce</code> function is used to, well, <em>reduce</em> a list of data into a single value.
For example, finding the sum of a list of numbers and finding the minimum in a list of numbers are both examples of reduce operations.</p>
<p>The <code>reduce</code> function is called on a <code>Stream</code>, and takes a <code>BinaryOperator</code> as a parameter.
A <code>BinaryOperator</code> is a function that takes in two parameters of the same data type, and returns a value that also belongs to the same data type.</p>
<p>Let's call it the <em>accumulator</em> function.
The accumulator function has two parameters: the <em>result</em> so far and the <em>current</em> value.
The reduce operation starts by invoking the accumulator function on the first two items in the list.
The result of this operation is used in the next invocation of the accumulator, along with the <em>next</em> item in the list, and this continues until the list is exhausted, leaving you with a single final result.</p>
<p>Let's look at a relatively simple example: finding the sum of a list of numbers.</p>
<pre><code class="language-java">List&lt;Integer&gt; numbers = List.of(2, 3, 10, 5);
Optional&lt;Integer&gt; optionalSum = numbers.stream()
  .reduce((result, current) -&gt; result + current); // Optional in case the list was empty
</code></pre>
<p>In the example above, the accumulator function starts with the first two items in the list, <code>2</code> and <code>3</code> and gives the value <code>5</code> in return.
The value <code>5</code> is then used as the <code>result</code> parameter in the next usage of the accumulator, along with the number <code>10</code>, and we get the value <code>15</code>.
Finally, the value <code>15</code> is used as the <code>result</code> parameter and added to the number <code>5</code>, and we get the final answer <code>20</code>, which is the sum of the list of numbers.</p>
<p>In this way, the <code>reduce</code> operation <em>folds</em> the list in on itself, one value at a time, starting from the left.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>The original list</td><td>2</td><td>3</td><td>10</td><td>5</td></tr>
<tr><td>Sum the first 2 numbers</td><td></td><td><strong>5</strong></td><td>10</td><td>5</td></tr>
<tr><td>Add the next number to the running total</td><td></td><td></td><td><strong>15</strong></td><td>5</td></tr>
<tr><td>Add the next number to the running total</td><td></td><td></td><td></td><td><strong>20</strong></td></tr>
</tbody></table>
</div>
<p>Notice that the return type of <code>reduce</code> is an <code>Optional</code> — this is because if the list was empty, no result would be produced.
To get the final <code>int</code> result, you would call <code>.get()</code> on the result, after making sure it <code>isPresent</code>.
Clunky, I know.</p>
<p><code>reduce</code> has an overload in which you can specify an <em>initial value.</em>
In this case, instead of starting off your accumulator on the first two items in the list, you would start it on the initial value and the first item in the list.
It can be used as follows.</p>
<pre><code class="language-java">List&lt;Integer&gt; numbers = List.of(2, 3, 10, 5);
int sum = numbers.stream()
  .reduce(0, (result, current) -&gt; result + current);
</code></pre>
<p>In the example above, the initial result is <code>0</code>, and if the list had happened to be empty, the final answer would also be 0.</p>
<p>Reductions are extremely common list operations.
For example, if you want to check if <em>any</em> item in a list meets a condition, the accumulator would use a Boolean OR.
To check if <em>all</em> items meet a condition, the accumulator would use a Boolean AND.
Counting the number of items in a list is also use a reduction—the accumulator adds <code>1</code> for each item in the list.</p>
<p>Many of these operations have been provided as convenience functions in the <a href="https://docs.oracle.com/en/java/javase//21/docs/api/java.base/java/util/stream/Stream.html">Stream API</a>: see <code>anyMatch</code>, <code>allMatch</code>, and <code>count</code>, for example.</p>
<blockquote>
<p><strong>DISCUSS</strong></p>
<p>Given a list of <code>Album</code> objects, how would you use <code>reduce</code> to find the <code>Album</code> with the highest <code>unitsSold</code>?</p>
</blockquote>
<h2 id="streams-are-not-data-structures"><a class="header" href="#streams-are-not-data-structures">Streams are not data structures</a></h2>
<p><strong>A stream, by itself, does not store data, and is technically not a data structure.</strong>
Streams are wrappers around a data source.
They allow us to define a series of operations that should be performed on that data source, and they make bulk processing of data convenient and fast.</p>
<p>The "data source" for a stream can be anything—an array or list, a file stored on disk, a stream of data coming from some external service, etc.
In this class, we will only deal with streams based on lists or arrays, but this section describes how Streams might be used to work with other types of data sources.</p>
<p><strong>A stream never modifies its underlying data source.</strong>
For example, you cannot use stream operations on a list to remove items from or add items to the list.
Just like you can't add or remove items from a list while looping over it using a <code>for-each</code> loop.</p>
<p><strong>A stream pipeline usually consists of 3 pieces</strong>:</p>
<ul>
<li><strong>A data source</strong>, which can be an array, a list, a file, etc.</li>
<li><strong>Zero or more intermediate operations</strong>, each of which transforms the stream into another stream. Because these intermediate operations return streams themselves, they can be chained together to perform a number of operations.</li>
<li><strong>Exactly one terminal operation</strong>, which produces a result or a side effect. Since the terminal operation "exits" the pipeline, no further stream operations can be added to the pipeline. That is, the terminal operation is always the last operation in a stream pipeline.</li>
</ul>
<p>In our example above,</p>
<ul>
<li><code>albums</code> was the <strong>source</strong> of the stream</li>
<li><code>filter</code> and <code>mapToLong</code> were <strong>intermediate operations</strong></li>
<li><code>average</code> was a <strong>terminal operation</strong></li>
</ul>
<p><strong>Stream pipelines are lazy.</strong>
A stream pipeline will not begin executing until it has to.
Specifically, the stream processing won't be "kicked off" until a terminal operation is called.</p>
<p>For example, if we had only called <code>filter</code> and <code>mapToLong</code> above, we would still be left with a <code>LongStream</code>, i.e., a stream of longs.
No processing would take place unless some terminal operation was added to the pipeline.</p>
<p>Some examples of terminal operations are:</p>
<ul>
<li>Collecting the result of the stream pipeline into a list (<code>.toList()</code>).</li>
</ul>
<pre><code class="language-java">List&lt;Double&gt; albumCosts = albums.stream()
  .filter(a -&gt; a.getYear() &gt; 2000)
  .map(a -&gt; a.getPrice())
  .toList();
</code></pre>
<ul>
<li>Counting the elements left in the stream after the intermediate operations have been performed (<code>count()</code>)</li>
</ul>
<pre><code class="language-java">int albumsBefore2000 = albums.stream()
  .filter(a -&gt; getYear() &lt; 2000)
  .count();
</code></pre>
<ul>
<li>Looping over the elements in the stream and operating on them, i.e., applying a <code>Consumer</code> to each item (<code>.forEach(Consumer)</code>)</li>
</ul>
<pre><code class="language-java">// Reduce cost of pre-2000 albums by 10%
albums.stream()
  .filter(a -&gt; a.Year() &lt; 2000)
  .forEach(a -&gt; a.setPrice(a.getPrice() * 0.9));
</code></pre>
<ul>
<li>Finally, as we've seen above, you can perform numerical aggregations (like <code>.sum()</code> or <code>.average()</code>) when you have primitive streams like <code>IntStream</code>, <code>DoubleStream</code>, <code>LongStream</code>.</li>
</ul>
<h2 id="what-is-streaming"><a class="header" href="#what-is-streaming">What is "streaming"?</a></h2>
<p>You likely already know the meaning of the word "streaming".
For example, you've heard of "streaming music" or "streaming a video" over the internet.
To simplify it greatly, it means to <em>process data while it loads</em>, rather than to load all the data before beginning to process it.</p>
<p>For example, when you're streaming a movie on Netflix, you're not actually downloading the whole movie to your machine and then watching it.
Rather, chunks of the movie are being sent to your computer and played in your browser as they arrive.</p>
<p><code>Stream</code>s in Java are a similar idea.</p>
<p>This can be a useful mode of operation when you are working with huge amounts of data that cannot all be loaded into memory at once, or if you are working with "never-ending data", for example, minute-by-minute readings from weather sensors.
In these situations, you cannot wait to load all the data into, say, an <code>ArrayList</code> before you begin processing the data.</p>
<p>Consider the following scenario.
Let's imagine you need to read and process data from a HUGE file on your hard disk: <code>MyGiantFile.txt</code>
The file is too large for you read the entire thing into a list of strings.</p>
<p>One way you could do this is to use a <code>Scanner</code> to read the file and process it line by line, like we have done in a project and a couple of labs this term.</p>
<pre><code class="language-java">Scanner scanner = new Scanner(new File("MyGiantFile.txt"));
while (scanner.hasNext()) {
  String line = scanner.nextLine();

  // Assume we do some work with the line here
}
</code></pre>
<p>With the streams API, we can now concisely define operations like the above using lambdas and all the benefits they bring.</p>
<p>The <code>Files.lines</code> static method creates a stream of strings, allowing us to define a pipeline of operations that will apply to each line in <code>MyGiantFile.txt</code>.</p>
<pre><code class="language-java">Files.lines(Path.of("MyGiantFile.txt"))
  .map(line -&gt; .....)
  .filter(line -&gt; ........)
  .forEach(line -&gt; .......);
</code></pre>
<p>Because <code>Files.lines</code> returns a <code>Stream&lt;String&gt;</code>, the lines in the file and <em>streamed</em> through our pipeline, but this detail is abstracted away from you, the developer.</p>
<p>If you use a simple collection in memory (like an array or list) as the source of a stream, you're not gaining much in the way of "streaming" — in that situation, the Streams API mostly provides a convenient library and syntax for performing operations on a collection data. Still pretty good!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exception-handling"><a class="header" href="#exception-handling">Exception handling</a></h1>
<blockquote>
<p><em>Exceptions</em> are unexpected occurrences that disrupt the normal flow of your program. In this lesson we'll learn how we can use Java's Exception handling mechanisms for handling Exceptions.</p>
<p>Here, "handling" an Exception can mean many things:</p>
<ul>
<li>Logging an error, or notifying the user that an action cannot be completed because an error occurred.</li>
<li>Performing some work to "recover" from the Exception</li>
<li>Letting someone else handle the Exception</li>
</ul>
</blockquote>
<!--Outline

- What an Exception is
- Running example: reading a file
- A sneak peek at the Exception class hierarchy
- Handling an exception: try-catch
- The finally block
- Making it somebody else's problem: throws
- Checked vs unchecked exceptions
- Creating your own exception types
-->
<p>An Exception is...well, it's an <em>exceptional</em> situation that occurs in your program, either because:</p>
<ul>
<li>You've encountered a situation you cannot control: for example, your program tried to read a file that does not exist,</li>
<li>You received input that you did not expect: for example, you expected a String containing a math expression like <code>23 + 32</code>, but instead got <code>"jiminy billy bob"</code></li>
</ul>
<p>In these cases, you (the programmer) need to decide how your program is going to handle those situations.
In programs you wrote in your early classes, you may have decided to not handle them at all, opting simply to assume that your program would not be used in these unexpected ways.</p>
<p>However, as you edge closer toward writing programs that real people will use, you will need to start accounting for these exceptional situations.</p>
<h2 id="a-running-example-reading-a-file"><a class="header" href="#a-running-example-reading-a-file">A running example: Reading a file</a></h2>
<p>As always, we'll keep a running example going.</p>
<p>In this case, let's assume we have a file (<code>runningData.txt</code>) that contains a list of names and miles run by each person, like so:</p>
<pre><code class="language-txt">Michael,5.2
Phyllis,3.8
Dwight,3.1
Pam,2.5
Jim,4.0
Oscar,6.3
Stanley,1.2
</code></pre>
<p>(I did say it was a "running" example.)</p>
<p>And we have some simple Java code that reads the file, line by line, and totals up the total number of miles run.<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup>
Take a moment to read the code below.</p>
<pre><code class="language-java">// When we run the program, this method will be executed
void main() {
  double totalMiles = getTotalMilesRun("runningData.txt");
  System.out.println("Total miles run: " + totalMiles);
}

// Reads the given file and returns the total number of miles run
// This method contains several potential points of failure!
double getTotalMilesRun(String fileName) {
  // Create a Scanner to read the file
  Scanner fileScanner = new Scanner(new File(fileName));
  double totalMiles = 0.0;

  // Read each line of the file
  while (fileScanner.hasNext()) {
    String line = fileScanner.nextLine();
    String[] parts = line.split(",");
    String name = parts[0];
    double miles = Double.parseDouble(parts[1]);
    totalMiles += miles;
  }

  // Always a good idea to close the Scanner when you're done.
  // More on this in the next lesson.
  fileScanner.close();

  return totalMiles;
}
</code></pre>
<blockquote>
<p><strong>PONDER</strong></p>
<p>The <code>getTotalMilesRun</code> method contains several potential points of failure. <em>Can you see what they are</em>?</p>
</blockquote>
<h2 id="file-io-gone-wrong"><a class="header" href="#file-io-gone-wrong">File I/O gone wrong</a></h2>
<p>First, the file may not exist, or we may not have permission to read it, or it may be locked by another program, etc.</p>
<p>Any time we read a file, Java <em>requires us</em> to "have a plan" for these exceptional circumstances.
Our program will not compile without such a plan.</p>
<p><strong>What does that mean in terms of Java code?</strong> The code above will give us a compiler error on the following line:</p>
<pre><code class="language-java">Scanner fileScanner = new Scanner(new File(fileName));
</code></pre>
<p>Hovering over the error shows us this message:</p>
<pre><code>Unhandled exception: java.io.FileNotFoundException
</code></pre>
<p>This is telling us that that line of code—the <code>Scanner</code> constructor in particular—<em>might</em> throw a <code>FileNotFoundException</code>, and if we want to use the <code>Scanner</code>, we need to be able to handle that.
The <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Scanner.html#%3Cinit%3E(java.io.File)"><code>Scanner</code> constructor's documentation</a> states that it throws a <code>FileNotFoundException</code> if the file is not found.<sup class="footnote-reference" id="fr-best-1"><a href="#footnote-best">2</a></sup></p>
<p>So how do we handle it?</p>
<p>We have two options for handling this potential <code>FileNotFoundException</code>:</p>
<ol>
<li>We can either handle it ourselves (e.g., by printing a message saying that something went wrong when reading the file), or</li>
<li>We can pass the buck to whoever called our method, letting them handle it instead</li>
</ol>
<p>We'll consider each option in turn.</p>
<h2 id="option-1-handle-the-exception"><a class="header" href="#option-1-handle-the-exception">Option 1: Handle the exception</a></h2>
<p>Java gives us the <code>try-catch</code> construct for handling Exceptions ourselves.
It is used to "try" to do some work that might "throw" an Exception.
And if an Exception is thrown, we can "catch" the Exception and handle it gracefully.</p>
<p>The flow of control in a <code>try-catch</code> block is shown below (a code example follows):</p>
<pre class="mermaid">flowchart TD
    A[Start try block] --&gt; B{Exception thrown?}
    B -- No --&gt; C[Finish the try block]
    C --&gt; G[End]
    B -- Yes --&gt; E[Jump to catch block]
    E --&gt; G[Execution continues after the try-catch]
</pre>
<p>Here's an example of its usage:</p>
<pre><code class="language-java">try {
  // Do some work that could possibly throw an exception.
  Scanner fileScanner = new Scanner(new File(fileName));

  // If we reach here, we know the previous line was successful.
  while (fileScanner.hasNext()) {
    // Read and process each line as before.
  }
} catch (FileNotFoundException fnfe) {
  // Gracefully handle the exception.
  // For example, print a message.
  System.out.println("Could not find a file called " + fileName);

  // You could also print the exception message. The Exception
  // is given to you in the "fnfe" variable.
  System.out.println("Error message: " + fnfe.getMessage());
}

// After the try-catch block, execution continues here.
doMoreStuff();
</code></pre>
<p>In sum:</p>
<ul>
<li>If an Exception occurs partway through the <code>try</code> block, execution jumps to the <code>catch</code> block. We skip any code in the the <code>try</code> block that comes after the offending line.</li>
<li>After the <code>catch</code> block finishes executing, execution continues with the code <em>after</em> the <code>try-catch</code> statement.</li>
</ul>
<p>It can be tempting to think of it as a control flow construct akin to an <code>if-else</code> statement, but there are important differences to be aware of.
Importantly, unlike an <code>if-else</code> statement, where only one branch is executed, in a <code>try-catch</code>, both the <code>try</code> block (partially) and the <code>catch</code> block (fully) may be executed.</p>
<p>With this knowledge in hand, let's see our method using a <code>try-catch</code> block to handle the potential <code>FileNotFoundException</code>.</p>
<h4 id="gettotalmilesrun-with-a-try-catch-block"><a class="header" href="#gettotalmilesrun-with-a-try-catch-block"><code>getTotalMilesRun</code>, with a <code>try-catch</code> block</a></h4>
<pre><code class="language-java">double getTotalMilesRun(String fileName) {
  double totalMiles = 0.0;

  try {
    // Create a Scanner to read the file
    Scanner fileScanner = new Scanner(new File(fileName));

    // Read each line of the file
    while (fileScanner.hasNext()) {
      String line = fileScanner.nextLine();
      String[] parts = line.split(",");
      String name = parts[0];
      double miles = Double.parseDouble(parts[1]);
      totalMiles += miles;
    }

    // Always a good idea to close the Scanner when you're done.
    fileScanner.close();
  } catch (FileNotFoundException fnfe) {
    // Gracefully handle the exception
    System.out.println("Could not find a file called " + fileName);
    System.out.println("Error message: " + fnfe.getMessage());
  }

  return totalMiles;
}
</code></pre>
<p>Now, if we call <code>getTotalMilesRun</code> with a file that doesn't exist, our program can gracefully handle it by printing a useful error message.</p>
<p>But what if some <em>other</em> Exception occurs, not specifically a <code>FileNotFoundException</code>? Will our <code>catch</code> still catch it?</p>
<p>Here's a excerpt of the hierarchy of Exception types in Java. We'll say much more about this in the next lesson!</p>
<pre class="mermaid">flowchart TD
  Exception
  Exception --&gt; Others...
  Exception --&gt; IOException --&gt; FileNotFoundException
  Exception --&gt; RuntimeException --&gt; NumberFormatException
</pre>
<p>All exception types inherit from the base <code>Exception</code> type.
So, a <code>FileNotFoundException</code> <em>is an</em> <code>Exception</code>.
A <code>NumberFormatException</code>—another exception type—<em>is an</em> <code>Exception</code>.</p>
<p>So it's possible, but not advisable, to catch all possible Exceptions by simply catching the base <code>Exception</code> type, like so:</p>
<pre><code class="language-java">} catch (Exception e) {
  // This will catch any Exception, including FileNotFoundException,
  // NumberFormatException, etc.
}
</code></pre>
<p>However, this is considered an antipattern (as in, don't do it).
It's important that our <code>catch</code> block catch the correct Exception type, so that error handling can be targeted to the particular thing that went wrong.
If we treat all exceptions the same, we run the risk of not being able to track down the causes of failures if they occur.</p>
<h4 id="handling-multiple-exception-types"><a class="header" href="#handling-multiple-exception-types">Handling multiple Exception types</a></h4>
<p>If multiple Exception types are possible from your code, you can have multiple <code>catch</code> blocks, like so:</p>
<pre><code class="language-java">try {
  // Code that might throw multiple exception types
} catch (FileNotFoundException fnfe) {
  // Handle file not found
} catch (NumberFormatException nfe) {
  // Handle number format error
}
</code></pre>
<p>If an exception occurs, it will be passed to the first <code>catch</code> block that matches its type.
Note that the order of the <code>catch</code> blocks matters: more specific exceptions should be caught before more general ones.
Java will not automatically map to the "closest matching" <code>catch</code> block.</p>
<p>Alternatively, you may want to handle multiple exception types in the same way. For those cases, you can use the pipe (<code>|</code>) operator to catch multiple exceptions in a single <code>catch</code> block:</p>
<pre><code class="language-java">try {
  // Code that might throw multiple exception types
  // This catch block would catch FileNotFoundExceptions or NumberFormatExceptions
} catch (FileNotFoundException | NumberFormatException e) {
  // Handle both exceptions the same way
}
</code></pre>
<p>You should have a good reason to do this, since it can make your error handling and reporting less specific.
That is, these two exceptions may indicate very different problems, and handling them the same way may not be appropriate.
It also shouldn't be used as an escape hatch to avoid writing proper error handling code.</p>
<blockquote>
<p><strong>NOTE</strong></p>
<p>An Exception being thrown is <em>kind of</em> like a <code>return</code> statement. When an Exception occurs inside a method, execution is interrupted and transferred to the nearest appropriate <code>catch</code> block (if it exists), or the Exception "escapes upward" to whoever called the method.
Because of this, only one Exception can occur at a time in a single <code>try</code> block, just like only one <code>return</code> statement can be executed at a time in a method.</p>
</blockquote>
<h2 id="option-2-make-it-somebody-elses-problem"><a class="header" href="#option-2-make-it-somebody-elses-problem">Option 2: Make it somebody else's problem</a></h2>
<p>Ok, so we know how to handle an Exception ourselves if it occurs.
But we do have another option: we could make it somebody else's problem using the <code>throws</code> keyword.</p>
<p>Instead of handling the exception ourselves, we could pass the buck to whoever called our <code>getTotalMilesRun</code> method.
I mean, hey, they are the ones who told us the file name, maybe they have a better idea of what to do if the file doesn't exist.</p>
<p>We can do this by adding a <code>throws</code> declaration to our method.</p>
<p>In the method below, we've gone back to our original version of the method (without a <code>try-catch</code>), with one small change.
In the method signature, we've added <code>throws FileNotFoundException</code>.</p>
<p>This is us telling Java (and anyone who calls this method) that this method <em>might</em> throw a <code>FileNotFoundException</code>.</p>
<pre><code class="language-java">double getTotalMilesRun(String fileName) throws FileNotFoundException {
  // Create a Scanner to read the file
  Scanner fileScanner = new Scanner(new File(fileName));
  double totalMiles = 0.0;

  // Read each line of the file
  while (fileScanner.hasNext()) {
    String line = fileScanner.nextLine();
    String[] parts = line.split(",");
    String name = parts[0];
    double miles = Double.parseDouble(parts[1]);
    totalMiles += miles;
  }

  // Always a good idea to close the Scanner when you're done.
  fileScanner.close();

  return totalMiles;
}
</code></pre>
<p>Now, anyone who calls <code>getTotalMilesRun</code> must handle the <code>FileNotFoundException</code> themselves (either by using a <code>try-catch</code>, or themselves declaring that they themselves would throw it).</p>
<p>This is actually what the <code>Scanner</code> constructor did to us!
Take a look at the <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Scanner.html#%3Cinit%3E(java.io.File)">constructor's documentation again</a>.
Notice that the constructor has a <code>throws</code> declaration.
This caused <em>us</em> to take action to handle the potential <code>FileNotFoundException</code>.</p>
<p>That is, if we now have the following  <code>main</code> method, <em>we will have a compiler error on the line where we call <code>getTotalMilesRun</code></em>, because the Exception is now the <code>main</code> method's problem to handle.</p>
<pre><code class="language-java">void main() {
  double totalMiles = getTotalMilesRun("runningData.txt");
  System.out.println("Total miles run: " + totalMiles);
}
</code></pre>
<p>Once again, we have two options:</p>
<p>The <code>main</code> method could use <code>try-catch</code> to handle the exception, like we did in <a href="17_exceptions/index.html#option-1-handle-the-exception">Option 1</a>.</p>
<p>Or, the <code>main</code> method can <em>propogate the Exception</em> using a <code>throws</code> declaration, like we did in <a href="17_exceptions/index.html#option-2-make-it-somebody-elses-problem">Option 2</a>.
However, <strong>this is generally a bad idea for <code>main</code></strong>.
There's nowhere else to go! <code>main</code> is the entry point of the program—the <em>user</em> is the one who called the method, by virtue of running our program.
So if an Exception "escapes" <code>main</code>, the program will simply crash.</p>
<h2 id="throwing-exceptions-intentionally"><a class="header" href="#throwing-exceptions-intentionally">Throwing Exceptions Intentionally</a></h2>
<p>In addition to <code>catch</code>ing exceptions or declaring exceptions using <code>throws</code>, we can also <code>throw</code> exceptions for others to handle.</p>
<p>A common pattern when writing methods that take parameters is to check <em>preconditions</em> about those parameters.</p>
<p>For example, in our <code>getRunningTotalMiles</code>, we might want to check that the <code>fileName</code> parameter is not <code>null</code> or empty.
If it is, we might manually throw an <code>IllegalArgumentException</code> and give it a meaningful error message.</p>
<p>We can use the <code>throw</code> keyword to do this.</p>
<pre><code class="language-java">double getTotalMilesRun(String fileName) {
  if (fileName == null || fileName.isEmpty()) {
    throw new IllegalArgumentException("fileName cannot be null or empty");
  }

  // Rest of the method remains the same
}
</code></pre>
<p>This is our way of saying "I got some invalid input, and I cannot proceed with it."
We do this to throw an error back to whoever called the method with erroneous input, so they can fix the issue on their end.</p>
<h2 id="checked-and-unchecked-exceptions"><a class="header" href="#checked-and-unchecked-exceptions">Checked and unchecked exceptions</a></h2>
<p>Remember how I said our <code>getTotalMilesRun</code> method has several potential points of failure? We've only handled one of them so far: the possibility that the file doesn't exist.</p>
<p>It was easy to notice that one, because the <code>Scanner</code> constructor explicitly told us about it by throwing a <code>FileNotFoundException</code>, and the compiler wouldn't move on until we handled it.</p>
<p>These types of exceptions are called <em>checked exceptions</em>, because they are checked at compile time.</p>
<p><em>Unchecked exceptions</em>, on the other hand, are not checked at compile time.
Can you tell if there's potential for such an exception to occur in our <code>getTotalMilesRun</code> method? If so, what would it be?</p>
<h2 id="referencesother-reading"><a class="header" href="#referencesother-reading">References/Other reading</a></h2>
<ul>
<li>Oracle's <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/">Java tutorial on Exceptions</a> is excellent.</li>
</ul>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>Since we're just dealing with simple methods here, I won't create classes for this example. Instead, we'll use top-level methods that are supported in Java 25 onward. <a href="#fr-1-1">↩</a></p>
</li>
<li id="footnote-best">
<p>If we can't handle <code>Scanner</code> at its worst, do we really deserve it at its best? <a href="#fr-best-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="checked-and-unchecked-exceptions-1"><a class="header" href="#checked-and-unchecked-exceptions-1">Checked and unchecked exceptions</a></h1>
<blockquote>
<p>In this lesson, we'll learn about Exceptions that are "checked" or "unchecked" by the compiler and, more broadly, about the Exception hierarchy in Java.</p>
</blockquote>
<h2 id="recap-2"><a class="header" href="#recap-2">Recap</a></h2>
<p>Here's one version of the code we left off with in the previous lesson.
We're reading a file, and accounting for the case where the file doesn't exist.</p>
<pre><code class="language-java">double getTotalMilesRun(String fileName) {
  if (fileName == null || fileName.isEmpty()) {
    throw new IllegalArgumentException("fileName cannot be null or empty");
  }

  double totalMiles = 0.0;

  try {
    // Create a Scanner to read the file
    Scanner fileScanner = new Scanner(new File(fileName));

    // Read each line of the file
    while (fileScanner.hasNext()) {
      String line = fileScanner.nextLine();
      String[] parts = line.split(",");
      String name = parts[0];
      double miles = Double.parseDouble(parts[1]);
      totalMiles += miles;
    }
  } catch (FileNotFoundException fnfe) {
    // Gracefully handle the exception
    System.out.println("Could not find a file called " + fileName);
    System.out.println("Error message: " + fnfe.getMessage());
  }

  return totalMiles;
}
</code></pre>
<p>We were <em>forced</em> to account for that case by the compiler, because the <code>Scanner</code> constructor declares that it <code>throws</code> a <code>FileNotFoundException</code>.</p>
<p>That's because the <code>FileNotFoundException</code> is a <em>checked</em> exception.
The next section discusses the differences between <em>checked</em> and <em>unchecked</em> exceptions and shows some examples.</p>
<h2 id="the-exception-type-hierarchy"><a class="header" href="#the-exception-type-hierarchy">The Exception type hierarchy</a></h2>
<p>Here's an excerpt of the Java Exception type hierarchy (drawn from left-to-right so the font doesn't shrink too much).</p>
<pre class="mermaid">flowchart LR
  Exception --&gt; IOException
  Exception --&gt; Others...
  IOException --&gt; FileNotFoundException
  Exception --&gt; RuntimeException
  RuntimeException --&gt; NullPointerException
  RuntimeException --&gt; IllegalArgumentException
  RuntimeException --&gt; NumberFormatException
</pre>
<p>Broadly speaking, exception types that are subclasses of <code>Exception</code> but <em>not</em> subclasses of <code>RuntimeException</code> are <em>checked</em> by the compiler.</p>
<blockquote>
<p><em>Checked exceptions</em> are the ones for which the compiler checks whether or not you have a plan to handle them (i.e., a <code>try-catch</code> or a <code>throws</code>).</p>
</blockquote>
<p>On the other hand, subclasses of <code>RuntimeExceptions</code> are <em>unchecked</em> by the compiler.</p>
<blockquote>
<p><em>Unchecked exceptions</em> are the ones for which the compiler does not require exception-handling.</p>
</blockquote>
<p>For example, before dereferencing an object pointer (i.e., before using the dot operator <code>.</code> on the object to access its methods or instance variables), you need to be sure that it's not <code>null</code>. If it is <code>null</code>, you would get a <code>NullPointerException</code>, which is an unchecked exception.</p>
<p>In the previous lesson, we saw an example of checking for null-ness and throwing an <code>IllegalArgumentException</code> in the case of invalid. <code>IllegalArgumentException</code> is another example of an unchecked exception, commonly used when preconditions are violated (e.g., when a method is called with invalid inputs or "arguments").</p>
<h3 id="should-you-throw-checked-or-unchecked-exceptions"><a class="header" href="#should-you-throw-checked-or-unchecked-exceptions">Should you throw checked or unchecked exceptions?</a></h3>
<p>When you're writing a method and want to notify method caller's about some erroneous conditions, you have a choice: you can throw a checked exception, or you can throw an unchecked exception. Which one should you use?</p>
<p>The conventional wisdom is (courtesy of <a href="https://dn721901.ca.archive.org/0/items/java_20230528/Joshua%20Bloch%20-%20Effective%20Java%20%283rd%29%20-%202018.pdf">Joshua Bloch</a>):</p>
<ul>
<li><strong>Throw checked exceptions</strong> for cases where the error is recoverable. That is, your method will force the calling method to handle the exception. This is useful for things like reading files, where the caller can do something about the error (e.g., ask the user for a different file name, or create a new file).</li>
<li><strong>Throw unchecked exceptions</strong> for things that are likely programmer errors, like passing <code>null</code> to a method that asks for an object, or passing a negative number to a method that asks for positive number. These are cases that simply shouldn't happen, and the programmer who gets hit with an unchecked exception should be able to fix the problem by changing <em>their</em> code, rather than having to write code to handle the exception.<sup class="footnote-reference" id="fr-you-1"><a href="#footnote-you">1</a></sup></li>
</ul>
<h2 id="handling-potential-unchecked-exceptions"><a class="header" href="#handling-potential-unchecked-exceptions">Handling potential unchecked exceptions</a></h2>
<p>So, if the compiler doesn't require you to handle unchecked exceptions, does that mean you can ignore them? Absolutely not!</p>
<p>They can still crash program if they "escape containment", so you need to either make sure they won't occur (e.g., because you've checked conditions before using data), or you need to handle them with a <code>try-catch</code> block if they do occur.</p>
<p>How do we know <em>which</em> unchecked Exceptions might occur in our code?
Some good practices are:</p>
<ul>
<li><strong>Be defensive</strong> about any data you're working with that comes from an external source, like a file, method parameter, or a returned value from another method.</li>
<li><strong>Check for null-ness</strong> before dereferencing an object pointer, especially if the object came to you from an external source (e.g., a method parameter, or a return value from another method). This is a sub-category of the point above, but is quite common so it bears mentioning.
<ul>
<li>Because <code>NullPointerExceptions</code> are such a common failure mode, Java also contains the <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Optional.html"><code>Optional&lt;T&gt;</code></a> type.<sup class="footnote-reference" id="fr-generics-1"><a href="#footnote-generics">2</a></sup> If you're writing a method that might return <code>null</code> in certain conditions (e.g., a failed search in a data structure), you should consider returning an <code>Optional</code> instead. That way, a "client" (or "user") of your method will be forced to check for the presence of the value before using it.</li>
</ul>
</li>
<li><strong>Read the documentation</strong> for methods you're using from external libraries. They will (or they <em>should</em>, at any rate) document the exceptions they will throw and under what conditions.
<ul>
<li>The corollary to this is: if <em>you're</em> throwing Exceptions in your own code, or returning exceptional values like <code>null</code>, make sure to document them clearly.</li>
</ul>
</li>
</ul>
<h3 id="is-our-method-safe-yet"><a class="header" href="#is-our-method-safe-yet">Is our method safe yet?</a></h3>
<p>All right, with all that background: is our <code>getTotalMilesRun</code> method safe from unchecked exceptions?</p>
<p>Let's go through our function line-by-line. It may seem a bit tedious, but it's a good habit to get into.
An escaped Exception can crash your program, the consequences of which can be simply inconvenient (e.g., a user has to restart the program), catastrophic (e.g., a user loses data), or even dangerous (e.g., a user gets injured because of a software failure in a medical device, e.g., <a href="https://www.consumerreports.org/health/diabetes/when-diabetes-devices-fail-a2408992822/">there have been multiple casualties or life-threatening events as a result of faults or exceptions in blood glucose monitoring devices or insulin pumps</a>).
There's simply no room for carelessness.</p>
<p>What "external" data, methods, or constructors are we using? We go through the method's components line-by-line, and I've <strong>bolded</strong> the items we're gonna need to handle.</p>
<ul>
<li><code>fileName</code> might be <code>null</code> or empty. We've handled that already.</li>
<li><code>new Scanner(...)</code>:  We've handled the checked <code>FileNotFoundException</code> that's throwable by this constructor. No other exceptions are documented by the <code>Scanner</code> constructor, so we're good here.</li>
<li><a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Scanner.html#nextLine()"><code>fileScanner.nextLine()</code></a>: Gets the next line. The documentation declares two possible throwable exceptions:
<ul>
<li><code>NoSuchElementException</code>: Thrown if there <em>isn't</em> a next line. In this case we're okay because always we're checking <code>hasNext()</code> before calling it.</li>
<li><strong><code>IllegalStateException</code>: Thrown if the scanner is "closed". Let's file that away as something we need to handle!</strong></li>
</ul>
</li>
<li>We're reading a <code>line</code> from the file, and <code>split</code>ting it around a comma. This should be fine: the <code>nextLine</code> method wouldn't give us a <code>null</code> value back.</li>
<li><code>parts[0]</code> and <code>Double.parseDouble(parts[1])</code>: Accesses the first and second element from the split pieces, and parses the second element into a <code>double</code>. These two lines are rife with potential program crashes!
<ul>
<li><strong><code>parts[0]</code>: Do we <em>know</em> there'll be a <code>parts[0]</code>?</strong> If the line is empty, this would result in an <code>ArrayIndexOutOfBoundsException</code>, an unchecked exception.</li>
<li><code>Double.parseDouble(parts[1])</code>: This one's a double-whammy.
<ul>
<li><strong>Do we <em>know</em> there'll be a <code>parts[1]</code>?</strong></li>
<li><strong>If there <em>is</em> a <code>parts[1]</code>, what if it isn't a numeric value like <code>32.2</code>, and is instead, like, a banana?</strong> This would result in a <code>NumberFormatException</code>, another unchecked exception.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Essentially, our program is happy with a well-formed data file like this:</p>
<pre><code class="language-txt">Michael,5.2
Phyllis,3.8
Dwight,3.1
Pam,2.5
Jim,4.0
Oscar,6.3
Stanley,1.2
</code></pre>
<p>But we have no error handling for malformed data files like this:</p>
<pre><code class="language-txt">Fun Run for the Cure

Michael,5.2
Phyllis,3.8
Dwight,3.1

Angela,missing

Pam,2.5
Jim,4.0

Daryl,three

Oscar,6.3
Stanley,1.2
</code></pre>
<p>Ok, so our TO-DO list is:</p>
<ol>
<li>Handle the possibility of an <code>ArrayIndexOutOfBoundsException</code> from trying to access <code>parts[0]</code> or <code>parts[1]</code> when the line is empty or doesn't contain a comma.</li>
<li>Handle the possibility of a <code>NumberFormatException</code> from trying to parse a non-numeric value with <code>Double.parseDouble</code>.</li>
<li>Handle the possibility of an <code>IllegalStateException</code> from the <code>Scanner</code> constructor.</li>
</ol>
<h3 id="ask-for-permission-not-forgiveness"><a class="header" href="#ask-for-permission-not-forgiveness">Ask for permission, not forgiveness</a></h3>
<p>How should we handle those potential failure points? Should we just go full-speed-ahead and wrap the whole method body in a <code>try-catch</code> block that catches all of those exceptions, handling them only if they occur?</p>
<p>Or should we check if our data is valid <em>before</em> using it?</p>
<p>In Java, the conventional wisdom is to <strong>"ask for permission, not forgiveness"</strong>: that is, check for the conditions that would cause an exception before you use the data, rather than just trying to use it and catching the exception if it occurs.</p>
<blockquote>
<p>Exceptions are, as their name implies, to be used only for exceptional conditions; they should never be used for ordinary control flow.</p>
<p>Joshua Bloch. <a href="https://dn721901.ca.archive.org/0/items/java_20230528/Joshua%20Bloch%20-%20Effective%20Java%20%283rd%29%20-%202018.pdf"><em>Effective Java</em>, Chapter 10: Exceptions</a></p>
</blockquote>
<p>However, parsing strings into numeric values is almost the only exception (hah) to this rule: the Java standard library does not provide methods to check if a <code>String</code> is parse-able into a number.
We could roll our own, but it could be error prone, and anyway, the <code>Double.parseDouble</code> method already does this check.
So we would end up doing the check twice.</p>
<p>Ok, all that said, here's our code where we're handling items #1 and #2 from our TO-DO list.
For now, we're simply printing an error message and skipping invalid lines.
In a real project, you might do something else, depending on requirements.
For example, the <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html"><code>read_csv</code> function in the <code>pandas</code> library</a> will raise an error by default if it encounters malformed lines while reading a file, but also lets the user decide if they want some different response to malformed lines.</p>
<p>It's really important to do <em>something</em> when handling an exception—there are few things worse in software development than silent software failures.</p>
<pre><code class="language-java">double getTotalMilesRun(String fileName) {
  if (fileName == null || fileName.isEmpty()) {
    throw new IllegalArgumentException("fileName cannot be null or empty");
  }

  double totalMiles = 0.0;

  try {
    // Create a Scanner to read the file
    Scanner fileScanner = new Scanner(new File(fileName));

    while (fileScanner.hasNext()) {
      String line = fileScanner.nextLine();
      String[] parts = line.split(",");

      // Ask permission: Check if the line is valid before proceeding
      if (parts.length &lt; 2) {
        System.out.println("Invalid line: " + line);
        continue; // skip this line and move on to the next one
      }

      String name = parts[0];
      double miles;

      // Ask forgiveness: try to parse the double, and recover from the
      //  Exception if needed.
      try {
        miles = Double.parseDouble(parts[1]);
      } catch (NumberFormatException nfe) {
        System.out.println("Invalid miles value: " + parts[1]);
        continue; // skip this line and move on to the next one
      }

      totalMiles += miles;
    }

    // Always a good idea to close the Scanner when we're done with it.
    fileScanner.close();
  } catch (FileNotFoundException fnfe) {
    System.out.println("Could not find a file called " + fileName);
    System.out.println("Error message: " + fnfe.getMessage());
  }

  return totalMiles;
}
</code></pre>
<p>Ok, item #3 from our TO-DO list.
We see that the <code>Scanner</code> constructor might throw an <code>IllegalStateException</code> if the <code>Scanner</code> is "closed". What does that mean?</p>
<p>Well, when we use a <code>Scanner</code> to read a file, we're obtaining a resource (i.e., a file handle) from the operating system.
When we're done with that resource, we need to "close" it, which tells the operating system that we're done with it and that it can be freed up for other uses.</p>
<p>We're doing this using the <code>Scanner</code>'s <code>close()</code> method. After we've closed it, the <code>Scanner</code> can no longer be used to read lines from the file.</p>
<p>In our case, we are clearly closing the <code>Scanner</code> <em>after</em> using it to read lines.
So, in terms of the <code>IllegalStateException</code> from the <code>Scanner</code> constructor, we're okay.</p>
<p><strong>Does that mean that nothing can possibly go wrong with our <code>getTotalMilesRun</code> method?</strong> Of course not! The file might be locked by another process, or it might be on a network drive that has gone offline, or it have so many records that our <code>totalMiles</code> variable overflows, or ... ... ...</p>
<p>The point is, you can never be sure that your code is 100% safe from exceptions, but you can do your best to handle the ones you know about, and to check for conditions that might cause exceptions before they occur.</p>
<p>In this case, we've done a fairly good job being defensive about the data we're working with, and we've handled the exceptions that we know about.</p>
<p>That said, if something unforeseen <em>does</em> go wrong while reading the file, an exception would occur and jump to the <code>catch</code> block, or escape the method.
Either way, we're going to be stuck with an open <code>Scanner</code>, because in that case we wouldn't have reached the <code>fileScanner.close()</code> method call.
This will leave us with an open file handle, which can lead to resource leaks and other problems.</p>
<p>Can we make sure that our <code>Scanner</code> <em>always</em> closes, <strong>no matter what</strong>?</p>
<p>That's where the <code>finally</code> block comes in.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-you">
<p>Note that this imagined "other" programmer might well be <em>you</em>, working on a different part of the same code base. <a href="#fr-you-1">↩</a></p>
</li>
<li id="footnote-generics">
<p>If you are not sure what the <code>&lt;T&gt;</code> means here, please see the notes about <em>generics</em> or <em>type parameters</em> in the <a href="18_checked_unchecked/../15_lambdas">lesson on lambdas</a>. <a href="#fr-generics-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="finally"><a class="header" href="#finally">finally</a></h1>
<blockquote>
<p>The <code>finally</code> keyword is used to define a block of code that will be executed after a <code>try-catch</code> block, regardless of whether an exception occurred or was caught. It is useful for cleaning up resources, like closing files or releasing locks, that need to be done regardless of the outcome of the <code>try-catch</code> block.</p>
</blockquote>
<p>In the previous lesson, we ended with the following <code>getTotalMilesRun</code> method. It's pretty good, but it has one problem: if something goes wrong while reading the file, we'll skip reading the rest of the file and throw an Exception, <strong><em>and we would skip closing the <code>Scanner</code></em></strong>.</p>
<p>We can ensure that we <em>always</em> hit the <code>fileScanner.close()</code> line by enclosing it in a <code>finally</code> block.
This requires relatively minor changes to our method.
I've marked the new parts with comments in the code below.</p>
<pre><code class="language-java">double getTotalMilesRun(String fileName) {
  if (fileName == null || fileName.isEmpty()) {
    throw new IllegalArgumentException("fileName cannot be null or empty");
  }

  // NEW: We need to declare the Scanner in a broader scope
  // so it's accessible in the finally block.
  Scanner fileScanner = null;

  double totalMiles = 0.0;

  try {
    fileScanner = new Scanner(new File(fileName));

    while (fileScanner.hasNext()) {
      String line = fileScanner.nextLine();
      String[] parts = line.split(",");

      if (parts.length &lt; 2) {
        System.out.println("Invalid line: " + line);
        continue;
      }

      String name = parts[0];
      double miles;

      try {
        miles = Double.parseDouble(parts[1]);
      } catch (NumberFormatException nfe) {
        System.out.println("Invalid miles value: " + parts[1]);
        continue;
      }

      totalMiles += miles;
    }
  } catch (FileNotFoundException fnfe) {
    System.out.println("Could not find a file called " + fileName);
    System.out.println("Error message: " + fnfe.getMessage());
  } finally {
    // This will be executed no matter what
    if (fileScanner != null) {
      fileScanner.close();
    }
  }

  return totalMiles;
}
</code></pre>
<h3 id="all-roads-lead-to-finally"><a class="header" href="#all-roads-lead-to-finally">All roads lead to finally</a></h3>
<p>Let's update our mental mode of the flow of control with <code>try-catch</code> blocks by adding a <code>finally</code> block.</p>
<pre class="mermaid">flowchart TD
  A[try block]
  A --&gt;|No exception or return| C[finally block]
  A --&gt;|Exception, caught| D[catch block]
  A --&gt;|Return statement&lt;br&gt;or uncaught Exception| C
  D --&gt; C
  C --&gt;|No pending exception&lt;br/&gt;or return| E[Continue with rest of code]
  C --&gt;|Pending return value&lt;br&gt;or exception| F[Return value/Exception&lt;br/&gt;propagates up call stack]
</pre>
<p>Notice how we reach the <code>finally</code> block <em>no matter what</em>.
Every path through the <code>try-catch</code> block goes through <code>finally</code>.</p>
<ul>
<li>If the <code>try</code> block goes through without a hitch, we'll go through <code>finally</code> before continuing with the code after the <code>try-catch-finally</code> block.</li>
<li>If the <code>try</code> block encounters an exception,
<ul>
<li>If that exception is handled in a <code>catch</code> block, we'll go through the <code>catch</code> block and then through the <code>finally</code> block, before continuing with the code after the <code>try-catch-finally</code> block.</li>
<li>If that exceptoin is <em>not</em> handled by any <code>catch</code> block, we'll <em>still</em> go through <code>finally</code> before throwing the Exception up the call stack to the method that called us</li>
</ul>
</li>
<li>If a <code>try</code> or <code>catch</code> block <code>return</code> a value, we'll <em>still</em> go through <code>finally</code> before exiting the method.</li>
</ul>
<h2 id="try-with-resources"><a class="header" href="#try-with-resources">try-with-resources</a></h2>
<p>The pattern we're seeing above—declaring a resource (like a <code>Scanner</code>) outside the <code>try</code> block, initializing it inside <code>try</code>, and then closing it in <code>finally</code>—is a common idiom in Java.</p>
<p>Java therefore introduced a newer syntax called "try-with-resources" that takes care of closing your resources for you.</p>
<blockquote>
<p>You should always use the try-with-resources syntax when working with resources that need to be closed, like <code>Scanner</code>, <code>FileReader</code>, <code>BufferedReader</code>, <code>InputStream</code>, <code>OutputStream</code>, etc.</p>
</blockquote>
<p>We can therefore re-write our method as follows (and I promise this is its final form):</p>
<pre><code class="language-java">double getTotalMilesRun(String fileName) {
  if (fileName == null || fileName.isEmpty()) {
    throw new IllegalArgumentException("fileName cannot be null or empty");
  }

  double totalMiles = 0.0;

  // NEW: Use try-with-resources to automatically close the Scanner
  // The fileScanner variable is only visible inside the try block
  try (Scanner fileScanner = new Scanner(new File(fileName))) {
    while (fileScanner.hasNext()) {
      String line = fileScanner.nextLine();
      String[] parts = line.split(",");

      if (parts.length &lt; 2) {
        System.out.println("Invalid line: " + line);
        continue;
      }

      String name = parts[0];
      double miles;

      try {
        miles = Double.parseDouble(parts[1]);
      } catch (NumberFormatException nfe) {
        System.out.println("Invalid miles value: " + parts[1]);
        continue;
      }

      totalMiles += miles;
    }
  } catch (FileNotFoundException fnfe) {
    System.out.println("Could not find a file called " + fileName);
    System.out.println("Error message: " + fnfe.getMessage());
  }

  return totalMiles;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributors"><a class="header" href="#contributors">Contributors</a></h1>
<p>Various CSC 203 instructors over the years, including</p>
<ul>
<li>Ayaan Kazerouni</li>
<li>Zoë Wood</li>
<li>Aaron Keen</li>
<li>Julie Workman</li>
<li>Paul Hatalsky</li>
<li>Alex Bisberg</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>


    </div>
    </body>
</html>
