<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Streams - Cal Poly CSC 203 Lecture notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Cal Poly CSC 203 Lecture notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="streams"><a class="header" href="#streams">Streams</a></h1>
<p>Having learned about lambdas in <a href="../15_lambdas/">the previous lesson</a>, we will learn about a related construct in Java called <strong>streams</strong>.
Lambdas and streams are often used together.</p>
<p>Streams allow us to take a series of computations we mean to perform on a collection of data, and compose them into a "pipeline".</p>
<p>In this lesson, we'll start with concrete examples of using the Streams API, since on the surface there is very little new or unfamiliar happening here.
Following this, there is a brief discussion about what exactly is meant by "streaming", and some of the underlying properties of streams in Java that are important to know about.</p>
<h2 id="an-example-problem"><a class="header" href="#an-example-problem">An example problem</a></h2>
<p>Before we start, let's recall the <strong>map</strong> and <strong>filter</strong> patterns that we talked about in the previous lesson.</p>
<ul>
<li>In the <strong>map</strong> pattern, we define a function that describes a computation that we want to perform on each item in a collection. The <strong>map</strong> applies that function to each item in the list and returns a new list containing the results (i.e., the result of applying the function to each item in the original list).</li>
<li>In the <strong>filter</strong> pattern, we define a predicate that describes a condition we want to check for each item in a collection. The <strong>filter</strong> tests each item against that condition, and returns a list containing the items that "pass" or "satisfy" the predicate.</li>
</ul>
<p>Continuing with our examples of <code>Album</code> objects, let's suppose we have a list of <code>Album</code>s that we are working with.
For the purposes of this example, let's assume <code>Album</code> objects have the following fields:</p>
<ul>
<li><code>String title</code></li>
<li><code>String artist</code></li>
<li><code>int year</code></li>
<li><code>long unitsSold</code></li>
<li><code>double price</code></li>
</ul>
<p>We are given the following problem prompt:</p>
<blockquote>
<p>Write a program that consumes a list of <code>Album</code> objects, and, for the <code>Album</code>s released after the year 2000, computes the average number of units they have sold.</p>
</blockquote>
<p>Let's consider two solutions to this problem: one using regular <code>for-each</code> loops, like we are used to, and one using streams and lambdas.</p>
<h3 id="a-for-each-loop-solution"><a class="header" href="#a-for-each-loop-solution">A <code>for-each</code> loop solution</a></h3>
<p>As you read the code below, try to identify usage of the <strong>map</strong> or <strong>filter</strong> patterns.</p>
<pre><code class="language-java">public static double averageSalesAfter2000(List&lt;Album&gt; albums) {
  long sum = 0;
  int albumsAfter2000 = 0;

  for (Album current : albums) {
    if (album.getYear() &gt; 2000) {
      long sales = album.getSales();
      sum = sum + sales;
      albumsAfter2000 = albumsAfter2000 + 1;
    }
  }

  if (albumsAfter2000 &gt; 0) {
    return sum / albumsAfter2000;
  } else {
    return 0;
  }
}
</code></pre>
<h3 id="a-streams-solution"><a class="header" href="#a-streams-solution">A streams solution</a></h3>
<p>The same problem can be solved using streams.
The code is below, and an explanation of each line follows.</p>
<pre><code class="language-java">public static double averageSalesAfter2000(List&lt;Album&gt; albums) {
  OptionalDouble result =  albums.stream() // Stream&lt;Album&gt;
    .filter(a -&gt; a.getYear() &gt; 2000) // Stream&lt;Album&gt;
    .mapToLong(a -&gt; a.getUnitsSold()) // LongStream
    .average(); // OptionalDouble

  // After filtering, there may not be any albums left.
  // In that case, we just return 0.
  return result.orElse(0);
}
</code></pre>
<p>In the code above, we have organised a series of computations into a <em>stream pipeline</em>.</p>
<ul>
<li>We first call <code>stream</code> on the list of albums, to turn it into a stream of albums (<code>Stream&lt;Album&gt;</code>). This step is necessary to be able to call the other stream operations.</li>
<li>Then, we use <code>filter</code> to filter down to albums released after the year 2000. We define the condition as a lambda (a <code>Predicate</code>), passed as a parameter to <code>filter</code>.</li>
<li>Then, we use <code>mapToLong</code> to go from a collection of <code>Album</code> objects to a collection of <code>Long</code> values. We could've used <code>map</code> here instead of <code>mapToLong</code>, but using <code>mapToLong</code> means that we get back a stream whose <em>static type</em> is <code>LongStream</code>. This means we have access to a number of useful numerical operations, like <code>average</code>.</li>
<li>The <code>LongStream</code> provides an <code>average</code> method, which we can use to compute the average of the items remaining in the stream. This gives us an <code>OptionalDouble</code> in return. <code>OptionalDouble</code> is a class in Java representing a <code>double</code> which may or may not exist.
<ul>
<li>The reason this double may not exist is that, if the list is empty after filtering, we can't compute an average, because you can't divide by 0.</li>
</ul>
</li>
<li>We get the computed average from the <code>OptionalDouble</code> object and return the value.
<ul>
<li>The <code>orElse</code> method on the <code>OptionalDouble</code> gets us the computed value if it exists, or it gives us a specified "backup" value otherwise.</li>
</ul>
</li>
</ul>
<h2 id="common-stream-operations"><a class="header" href="#common-stream-operations">Common stream operations</a></h2>
<p>The <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/stream/package-summary.html">Streams API</a> provides a whole host of operations that can performed on streams of data.</p>
<p>Here are some commonly used operations you'll want to know about.</p>
<h3 id="filter"><a class="header" href="#filter"><code>filter</code></a></h3>
<p>The <code>filter</code> function is used to discard items that do not match a given condition.
It is called on a <code>Stream</code>, takes a <code>Predicate</code> as a parameter, and returns a <code>Stream</code>.
The <code>Predicate</code> is called on each item in the <code>Stream</code>, and only items for which the result is <code>true</code> are kept in the resulting <code>Stream</code>.</p>
<p>So for example, if you have a list of <code>Album</code> objects, and you want to only keep <code>Album</code>s that were released after the year 2000, you can achieve this using <code>filter</code> as follows:</p>
<pre><code class="language-java">// Assuming "albums" is a List&lt;Album&gt;, populated with records
Stream&lt;Album&gt; filtered = albums.stream()
  .filter((album) -&gt; album.getYear() &gt; 2000);
</code></pre>
<h3 id="map"><a class="header" href="#map"><code>map</code></a></h3>
<p>The <code>map</code> function is used to apply a function to each item in a collection, obtaining a result for each item.
It is called on a <code>Stream</code>, takes a <code>Function</code> as a parameter, and returns a <code>Stream</code>.
The resulting <code>Stream</code> contains the results of applying the function to each item in the original <code>Stream</code>.</p>
<p>For example, if you have a list of <code>Album</code> objects and you would like to compute, for each <code>Album</code>, its total sales (i.e., <code>unitsSold * price</code>), you could use <code>map</code> as follows:</p>
<pre><code class="language-java">// Assuming "albums" is a List&lt;Album&gt;, populated with records
Stream&lt;Double&gt; totalSales = albums.stream()
  .map((album) -&gt; album.getUnitsSold() * album.getPrice());
</code></pre>
<blockquote>
<p><strong>PONDER</strong></p>
<p>Why do you suppose the data type of <code>totalSales</code> above is <code>Stream&lt;Double&gt;</code>?</p>
</blockquote>
<h3 id="reduce"><a class="header" href="#reduce"><code>reduce</code></a></h3>
<p>Finally, the <code>reduce</code> function is used to, well, <em>reduce</em> a list of data into a single value.
For example, finding the sum of a list of numbers and finding the minimum in a list of numbers are both examples of reduce operations.</p>
<p>The <code>reduce</code> function is called on a <code>Stream</code>, and takes a <code>BinaryOperator</code> as a parameter.
A <code>BinaryOperator</code> is a function that takes in two parameters of the same data type, and returns a value that also belongs to the same data type.</p>
<p>Let's call it the <em>accumulator</em> function.
The accumulator function has two parameters: the <em>result</em> so far and the <em>current</em> value.
The reduce operation starts by invoking the accumulator function on the first two items in the list.
The result of this operation is used in the next invocation of the accumulator, along with the <em>next</em> item in the list, and this continues until the list is exhausted, leaving you with a single final result.</p>
<p>Let's look at a relatively simple example: finding the sum of a list of numbers.</p>
<pre><code class="language-java">List&lt;Integer&gt; numbers = List.of(2, 3, 10, 5);
Optional&lt;Integer&gt; optionalSum = numbers.stream()
  .reduce((result, current) -&gt; result + current); // Optional in case the list was empty
</code></pre>
<p>In the example above, the accumulator function starts with the first two items in the list, <code>2</code> and <code>3</code> and gives the value <code>5</code> in return.
The value <code>5</code> is then used as the <code>result</code> parameter in the next usage of the accumulator, along with the number <code>10</code>, and we get the value <code>15</code>.
Finally, the value <code>15</code> is used as the <code>result</code> parameter and added to the number <code>5</code>, and we get the final answer <code>20</code>, which is the sum of the list of numbers.</p>
<p>In this way, the <code>reduce</code> operation <em>folds</em> the list in on itself, one value at a time, starting from the left.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>The original list</td><td>2</td><td>3</td><td>10</td><td>5</td></tr>
<tr><td>Sum the first 2 numbers</td><td></td><td><strong>5</strong></td><td>10</td><td>5</td></tr>
<tr><td>Add the next number to the running total</td><td></td><td></td><td><strong>15</strong></td><td>5</td></tr>
<tr><td>Add the next number to the running total</td><td></td><td></td><td></td><td><strong>20</strong></td></tr>
</tbody></table>
</div>
<p>Notice that the return type of <code>reduce</code> is an <code>Optional</code> — this is because if the list was empty, no result would be produced.
To get the final <code>int</code> result, you would call <code>.get()</code> on the result, after making sure it <code>isPresent</code>.
Clunky, I know.</p>
<p><code>reduce</code> has an overload in which you can specify an <em>initial value.</em>
In this case, instead of starting off your accumulator on the first two items in the list, you would start it on the initial value and the first item in the list.
It can be used as follows.</p>
<pre><code class="language-java">List&lt;Integer&gt; numbers = List.of(2, 3, 10, 5);
int sum = numbers.stream()
  .reduce(0, (result, current) -&gt; result + current);
</code></pre>
<p>In the example above, the initial result is <code>0</code>, and if the list had happened to be empty, the final answer would also be 0.</p>
<p>Reductions are extremely common list operations.
For example, if you want to check if <em>any</em> item in a list meets a condition, the accumulator would use a Boolean OR.
To check if <em>all</em> items meet a condition, the accumulator would use a Boolean AND.
Counting the number of items in a list is also use a reduction—the accumulator adds <code>1</code> for each item in the list.</p>
<p>Many of these operations have been provided as convenience functions in the <a href="https://docs.oracle.com/en/java/javase//21/docs/api/java.base/java/util/stream/Stream.html">Stream API</a>: see <code>anyMatch</code>, <code>allMatch</code>, and <code>count</code>, for example.</p>
<blockquote>
<p><strong>DISCUSS</strong></p>
<p>Given a list of <code>Album</code> objects, how would you use <code>reduce</code> to find the <code>Album</code> with the highest <code>unitsSold</code>?</p>
</blockquote>
<h2 id="streams-are-not-data-structures"><a class="header" href="#streams-are-not-data-structures">Streams are not data structures</a></h2>
<p><strong>A stream, by itself, does not store data, and is technically not a data structure.</strong>
Streams are wrappers around a data source.
They allow us to define a series of operations that should be performed on that data source, and they make bulk processing of data convenient and fast.</p>
<p>The "data source" for a stream can be anything—an array or list, a file stored on disk, a stream of data coming from some external service, etc.
In this class, we will only deal with streams based on lists or arrays, but this section describes how Streams might be used to work with other types of data sources.</p>
<p><strong>A stream never modifies its underlying data source.</strong>
For example, you cannot use stream operations on a list to remove items from or add items to the list.
Just like you can't add or remove items from a list while looping over it using a <code>for-each</code> loop.</p>
<p><strong>A stream pipeline usually consists of 3 pieces</strong>:</p>
<ul>
<li><strong>A data source</strong>, which can be an array, a list, a file, etc.</li>
<li><strong>Zero or more intermediate operations</strong>, each of which transforms the stream into another stream. Because these intermediate operations return streams themselves, they can be chained together to perform a number of operations.</li>
<li><strong>Exactly one terminal operation</strong>, which produces a result or a side effect. Since the terminal operation "exits" the pipeline, no further stream operations can be added to the pipeline. That is, the terminal operation is always the last operation in a stream pipeline.</li>
</ul>
<p>In our example above,</p>
<ul>
<li><code>albums</code> was the <strong>source</strong> of the stream</li>
<li><code>filter</code> and <code>mapToLong</code> were <strong>intermediate operations</strong></li>
<li><code>average</code> was a <strong>terminal operation</strong></li>
</ul>
<p><strong>Stream pipelines are lazy.</strong>
A stream pipeline will not begin executing until it has to.
Specifically, the stream processing won't be "kicked off" until a terminal operation is called.</p>
<p>For example, if we had only called <code>filter</code> and <code>mapToLong</code> above, we would still be left with a <code>LongStream</code>, i.e., a stream of longs.
No processing would take place unless some terminal operation was added to the pipeline.</p>
<p>Some examples of terminal operations are:</p>
<ul>
<li>Collecting the result of the stream pipeline into a list (<code>.toList()</code>).</li>
</ul>
<pre><code class="language-java">List&lt;Double&gt; albumCosts = albums.stream()
  .filter(a -&gt; a.getYear() &gt; 2000)
  .map(a -&gt; a.getPrice())
  .toList();
</code></pre>
<ul>
<li>Counting the elements left in the stream after the intermediate operations have been performed (<code>count()</code>)</li>
</ul>
<pre><code class="language-java">int albumsBefore2000 = albums.stream()
  .filter(a -&gt; getYear() &lt; 2000)
  .count();
</code></pre>
<ul>
<li>Looping over the elements in the stream and operating on them, i.e., applying a <code>Consumer</code> to each item (<code>.forEach(Consumer)</code>)</li>
</ul>
<pre><code class="language-java">// Reduce cost of pre-2000 albums by 10%
albums.stream()
  .filter(a -&gt; a.Year() &lt; 2000)
  .forEach(a -&gt; a.setPrice(a.getPrice() * 0.9));
</code></pre>
<ul>
<li>Finally, as we've seen above, you can perform numerical aggregations (like <code>.sum()</code> or <code>.average()</code>) when you have primitive streams like <code>IntStream</code>, <code>DoubleStream</code>, <code>LongStream</code>.</li>
</ul>
<h2 id="what-is-streaming"><a class="header" href="#what-is-streaming">What is "streaming"?</a></h2>
<p>You likely already know the meaning of the word "streaming".
For example, you've heard of "streaming music" or "streaming a video" over the internet.
To simplify it greatly, it means to <em>process data while it loads</em>, rather than to load all the data before beginning to process it.</p>
<p>For example, when you're streaming a movie on Netflix, you're not actually downloading the whole movie to your machine and then watching it.
Rather, chunks of the movie are being sent to your computer and played in your browser as they arrive.</p>
<p><code>Stream</code>s in Java are a similar idea.</p>
<p>This can be a useful mode of operation when you are working with huge amounts of data that cannot all be loaded into memory at once, or if you are working with "never-ending data", for example, minute-by-minute readings from weather sensors.
In these situations, you cannot wait to load all the data into, say, an <code>ArrayList</code> before you begin processing the data.</p>
<p>Consider the following scenario.
Let's imagine you need to read and process data from a HUGE file on your hard disk: <code>MyGiantFile.txt</code>
The file is too large for you read the entire thing into a list of strings.</p>
<p>One way you could do this is to use a <code>Scanner</code> to read the file and process it line by line, like we have done in a project and a couple of labs this term.</p>
<pre><code class="language-java">Scanner scanner = new Scanner(new File("MyGiantFile.txt"));
while (scanner.hasNext()) {
  String line = scanner.nextLine();

  // Assume we do some work with the line here
}
</code></pre>
<p>With the streams API, we can now concisely define operations like the above using lambdas and all the benefits they bring.</p>
<p>The <code>Files.lines</code> static method creates a stream of strings, allowing us to define a pipeline of operations that will apply to each line in <code>MyGiantFile.txt</code>.</p>
<pre><code class="language-java">Files.lines(Path.of("MyGiantFile.txt"))
  .map(line -&gt; .....)
  .filter(line -&gt; ........)
  .forEach(line -&gt; .......);
</code></pre>
<p>Because <code>Files.lines</code> returns a <code>Stream&lt;String&gt;</code>, the lines in the file and <em>streamed</em> through our pipeline, but this detail is abstracted away from you, the developer.</p>
<p>If you use a simple collection in memory (like an array or list) as the source of a stream, you're not gaining much in the way of "streaming" — in that situation, the Streams API mostly provides a convenient library and syntax for performing operations on a collection data. Still pretty good!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../15_lambdas/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../contributors.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../15_lambdas/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../contributors.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
