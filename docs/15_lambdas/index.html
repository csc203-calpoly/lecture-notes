<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Lambdas and functional interfaces - Cal Poly CSC 203 Lecture notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Cal Poly CSC 203 Lecture notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="lambdas"><a class="header" href="#lambdas">Lambdas</a></h1>
<p>In the previous lesson, we learned about expressing <code>Comparator</code>s more concisely using the lambda syntax.
This is possible because <code>Comparator</code> is a <em>functional interface</em>.</p>
<blockquote>
<p>A functional interface is an interface in Java with exactly one abstract method.</p>
</blockquote>
<p>Because <code>Comparator</code> only has one abstract method (<code>compare</code>), we can concisely initialise <code>Comparator</code>s like so:</p>
<pre><code class="language-java">Comparator&lt;Album&gt; comp = (a1, a2) -&gt; a1.getTitle.compareTo(a2.getTitle());
</code></pre>
<p>The lambda above defines a function, and because there is only one abstract method in <code>Comparator</code>, there is no ambiguity about what that function is.
It's the <code>compare</code> function!
This means the compiler is able to infer things like the parameter types of <code>a1</code> and <code>a2</code>, and check that the function returns an <code>int</code> as is required by the <code>compare</code> function.</p>
<p>There are a whole bunch of other lambdas available in Java — too many to describe here!
So in this lesson, we'll focus our discussion on three useful types of lambdas available in Java:</p>
<ul>
<li><code>Function&lt;T, R&gt;</code>: This is the most generally-useful type of lambda. It represents a function that takes in one input and produces an output. The <code>T</code> is a placeholder for the input type, and the <code>R</code> is a placeholder for the result type.</li>
<li><code>Predicate&lt;T&gt;</code>: A predicate is essentially a function that returns a boolean. The <code>T</code> is a placeholder for the input type. There is no placeholder for the output type because the output is a <code>Boolean</code>.</li>
<li><code>Consumer&lt;T&gt;</code>: A consumer is an operation that takes in a single input and returns no result. Sort of like a lambda version of a <code>void</code> method. The <code>T</code> is a placeholder for the input type. There is no placeholder for the output type because there <em>is</em> no output.</li>
</ul>
<p>All of the above are <em>functional interfaces</em>, meaning they are all interfaces that contain exactly one abstract method each.
The three functional interfaces above are rather more generally useful than the <code>Comparator</code> interface.
While the <code>Comparator</code> interface defines a function for a very specific purpose (taking in two objects and returning an <code>int</code> based on their comparison), the lambdas above can be used in a wide variety of problems.</p>
<p>Let's talk about them.</p>
<h2 id="function"><a class="header" href="#function">Function</a></h2>
<p>A <code>Function</code> is exactly what you think it is: it's a procedure that takes in some input value and produces some output.</p>
<p>When you use a <code>Function</code>, you must also declare its input and output types.
Here are several examples of <code>Function</code>s written as lambdas:</p>
<p><strong>A function that takes in a number and returns its square:</strong></p>
<p>This function is expected to take in an integer as its input and return an integer as output.
Therefore, we declare the function using <code>Function&lt;Integer, Integer&gt;</code>.</p>
<pre><code class="language-java">Function&lt;Integer, Integer&gt; square = num -&gt; num * num;
</code></pre>
<p>Because the function above takes a single parameter, we can omit the parentheses around the parameter <code>num</code>.
We also don't need to specify the type of <code>num</code>, because we've already declared that the function is a <code>Function&lt;Integer, Integer&gt;</code>, i.e., its input type is an <code>Integer</code> and its output type is <code>Integer</code>.</p>
<p><strong>A function that takes in a String and returns its length:</strong></p>
<p>This function is expected to take in a string and return an integer.
So we declare it using <code>Function&lt;String, Integer&gt;</code>.</p>
<pre><code class="language-java">Function&lt;String, Integer&gt; stringLength = s -&gt; s.length();
</code></pre>
<blockquote>
<p><strong>PONDER</strong></p>
<p>The above function is using a lambda only to call an existing method on the input. This is the exact use case for using method references. How would you re-write the above function using a method reference? <strong>Try to answer this yourself before expanding the answer below.</strong></p>
</blockquote>
<details>
<summary>Click to see answer</summary>
<pre><code class="language-java">Function&lt;String, Integer&gt; stringLength = String::length;
</code></pre>
</details>
<p><strong>A function that takes in an Album and returns a String describing it:</strong> (e.g., <code>"Rubber Soul by The Beatles"</code>)</p>
<pre><code class="language-java">Function&lt;Album, String&gt; stringDesc = a -&gt; a.getTitle() + " by " + a.getArtist();
</code></pre>
<p><strong>The <code>Function</code> interface has one abstract method: the <code>apply</code> method.</strong>
The method takes in one parameter and returns one value.
The types for the parameter and the returned value are decided when the <code>Function</code> is first created, as you can see in the examples above.
This <code>apply</code> method is what you are defining when you write a lambda.</p>
<h3 id="a-motivating-example"><a class="header" href="#a-motivating-example">A motivating example</a></h3>
<p>A common task in programming problems is to apply some operation to all the items in a list, and produce a list of results.
This is commonly referred to as a <strong>map</strong> operation, i.e., you are <em>mapping</em> some input value to some output value.
You will be surprised at how often this pattern appears in your programs.</p>
<p>In a <strong>map</strong> operation:</p>
<ul>
<li>The <strong>input</strong> is a list of some type (e.g., <code>List&lt;T&gt;</code>).</li>
<li>The <strong>output</strong> is a list of some type (e.g., <code>List&lt;R&gt;</code>), where <code>R</code> can be the same as or different from <code>T</code>.</li>
<li>The input and output lists are the same length, because the output is obtained by applying a function to each item in the input.</li>
</ul>
<p>For example, suppose you are a teacher and your students have just taken an exam.</p>
<p>Suppose you realise that the class as a whole performed poorly on a particular question that was not clearly worded.
As a result, you need to add 2 points to everyone's exam scores.</p>
<p>First, let's acknowledge that you could easily write this using a <code>for</code> loop.</p>
<pre><code class="language-java">public static List&lt;Integer&gt; mapToAdjustedScores(List&lt;Integer&gt; examScores) {
  List&lt;Integer&gt; result = new ArrayList&lt;&gt;();

  for (int current : examScores) {
    int adjusted = current + 2; // This is the "map" operation
    result.add(percent);
  }

  return result;
}
</code></pre>
<p>As another example, the maximum possible score is 44 points, so your students have scores like <code>42</code>, <code>44</code>, <code>40</code>, <code>39</code>, etc.
You would like to turn all of these scores into percentages, i.e., by dividing each of them by <code>44</code> and multiplying by <code>100</code>.</p>
<p>Again, easily doable using a <code>for</code> loop.</p>
<pre><code class="language-java">public static List&lt;Double&gt; mapToPercentages(List&lt;Integer&gt; examScores) {
  List&lt;Double&gt; result = new ArrayList&lt;&gt;();

  for (int current : examScores) {
    double percent = ((double) current / 44) * 100; // This is the "map" operation
    result.add(percent);
  }

  return result;
}
</code></pre>
<p>Observe that <em>the two functions are nearly identical</em>, except for one thing: they differ in the operation performed on each list item within the for loop (and consequently, the data type of the resulting lists).
This is because both functions are versions of the <strong>map</strong> pattern in action. Can we abstract out the common parts so that only the differing parts (the insides of the for loops) need to be specified each time?</p>
<p>In other words, can we <em>parameterise</em> the map operation so that the nearly-identical functions don't need to be written multiple times?</p>
<h3 id="parameterising-our-mapper"><a class="header" href="#parameterising-our-mapper">Parameterising our mapper</a></h3>
<p>Instead of the two functions above, consider the following generalised <code>map</code> function.
We can take in a function as a parameter to this function, allowing this <code>map</code> function to be more generally useful.</p>
<p>There is some new notation in this code, which I will explain below.
Please take some time to read the code and its accompanying comments.</p>
<pre><code class="language-java">// T and R are declared as "type parameters"
public static &lt;T, R&gt; List&lt;R&gt; map(List&lt;T&gt; inputList, Function&lt;T, R&gt; func) {
  // The type of this list should match the output type of the Function parameter
  List&lt;R&gt; outputList = new ArrayList&lt;&gt;();

  // The type in this for loop should match the type of the input list
  for (T current : inputList) {

    // Recall that "apply" is the name of the abstract method in the Function interface.
    // We call "func" on the current item and save the result in a variable.
    R result = func.apply(current);

    // Store the result in the output list.
    outputList.add(result);
  }

  return outputList;
}
</code></pre>
<p>Some key things to note about the code above:</p>
<ul>
<li><strong><code>&lt;T, R&gt;</code></strong> — <code>T</code> and <code>R</code> are <strong>type parameters</strong> in this function. We don't yet know what those types will be, so for now we declare them as parameters, similar to how <code>inputList</code> and <code>func</code> are "value parameters".<sup class="footnote-reference" id="fr-generics-1"><a href="#footnote-generics">1</a></sup></li>
<li><strong><code>Function&lt;T, R&gt; func</code></strong> — Notice this <code>Function</code>'s input and output types. The input type, <code>T</code>, matches the type of each item in the <code>inputList</code>. The output type, <code>R</code>, matches the type of each item in the returned list, i.e., <code>List&lt;R&gt;</code>. At this point we don't know what the actual types for <code>T</code> and <code>R</code> are.</li>
<li><strong><code>func.apply(current)</code></strong> — Inside the <code>for</code> loop, we apply or call our mapper function on each item in the input list. Remember that at the end of the day <code>Function</code> is just an interface. It contains a single abstract method called <code>apply</code>. In this line, we call that <code>apply</code> function, giving it the current item in the list as an input.
<ul>
<li>Because we've declared the output type of our function to be <code>R</code>, we can use <code>R</code> as the data type when we store the result in a variable.</li>
</ul>
</li>
</ul>
<h4 id="usage-examples"><a class="header" href="#usage-examples">Usage examples</a></h4>
<p>We can now use our <code>map</code> function to accomplish both tasks above, by only writing the code that does the mapping, and not having to re-write the rest of the function each time.
We can express those operations as lambdas, given as parameters to our <code>map</code> function.</p>
<pre><code class="language-java">List&lt;Integer&gt; scores = List.of(42, 39, 43, 44, 40, 37, 35);

// Bump all scores by 2 using our map function
List&lt;Integer&gt; bumpedScores = map(scores, s -&gt; s + 2);
</code></pre>
<p>When we call <code>map</code> in the code above, the type parameters <code>T</code> and <code>R</code> are now resolved to actual types. <code>T</code> is now <code>Integer</code>, because the input list is a list of integers, and <code>R</code> is also <code>Integer</code> in this case, because our lambda's return type is integer.</p>
<p>We can also turn all scores into percentages.</p>
<pre><code class="language-java">// Turn scores into percentages
List&lt;Double&gt; percentages = map(scores, s -&gt; ((double) s / 44) * 100);
</code></pre>
<p>In the call above, <code>T</code> is <code>Integer</code>, and <code>R</code> is <code>Double</code>.</p>
<p>The <strong>map pattern</strong> is an extremely common programming pattern.
Virtually every mainstream programming language provides <code>map</code> as an operation that can be performed on collections of objects, and Java is no exception.
We will see how to use this in the next lesson on Streams.</p>
<p>For now, let's continue talking about different types of lambdas available in Java, and move on to the <code>Predicate</code>.</p>
<h2 id="predicate"><a class="header" href="#predicate">Predicate</a></h2>
<p>A <code>Predicate</code> is a function that returns a Boolean value.
Unlike a <code>Function</code>, you only need to specify an input type for a <code>Predicate</code>, because the output type is always <code>Boolean</code>.</p>
<p>Here are several examples of <code>Predicate</code>s written as lambdas.</p>
<p><strong>A predicate that takes in an integer and check if it is even.</strong></p>
<pre><code class="language-java">Predicate&lt;Integer&gt; isEven = num -&gt; num % 2 == 0;
</code></pre>
<p><strong>A predicate that takes in an Album and checks if it was released in this millenium.</strong></p>
<pre><code class="language-java">Predicate&lt;Album&gt; inThisMillenium = album -&gt; album.getYear() &gt; 2000;
</code></pre>
<blockquote>
<p>Both of the above can also be declared as <code>Function</code>s, i.e., as <code>Function&lt;Integer, Boolean&gt;</code> and <code>Function&lt;Album, Boolean&gt;</code>. The <code>Predicate</code> exists as a useful abstraction because creating boolean functions is a common use case in programming, as we will see. <strong><code>Predicate</code>s are, in essence, a way to parameterise boolean conditions.</strong></p>
</blockquote>
<p>The <code>Predicate</code> interface has one abstract method: the <code>test</code> method.
The <code>test</code> method takes in one input and returns a <code>boolean</code>.
That <code>test</code> method is what you are implementing when you express a <code>Predicate</code> as a lambda.</p>
<h3 id="a-motivating-example-1"><a class="header" href="#a-motivating-example-1">A motivating example</a></h3>
<p>Another common task in programming problems is to <strong>filter</strong> a collection of items based on some condition.
Like <code>map</code>, <code>filter</code> is an extremely common sub-step in solving programming problems.</p>
<p>In a <strong>filter</strong> operation:</p>
<ul>
<li>The <strong>input</strong> is a list of some type (e.g., <code>List&lt;T&gt;</code>).</li>
<li>The <strong>output</strong> is a list of the <em>same</em> type (<code>List&lt;T&gt;</code>).</li>
<li>The output is a subset of the input, because the output is obtained by filtering the input based on some condition.</li>
</ul>
<p>For example, continuing with the teacher example above, let's say you want to find out which students scored below a 70% on the exam (i.e., scores that are less than 31).
The first thing you need to do is filter out the scores that are greater than 31.</p>
<p>We could do this easily using a for loop.</p>
<pre><code class="language-java">public static List&lt;Integer&gt; filterLessThan70(List&lt;Integer&gt; scores) {
  List&lt;Integer&gt; result = new ArrayList&lt;&gt;();

  for (int current : scores) {
    if (current &lt; (0.7 * 44)) { // This is the filter condition
      result.add(current);
    }
  }

  return result;
}
</code></pre>
<h3 id="parameterising-our-filter"><a class="header" href="#parameterising-our-filter">Parameterising our filter</a></h3>
<p>Like we did with the <code>map</code> function we can make our <code>filter</code> more generally usable by parameterising the condition on which the list is filtered.</p>
<p>Consider the code below. We have re-written our <code>filter</code> function to only include the common elements of a typical <code>filter</code> operation, and parameterised things that might change from one instance to another.
For example, we have parameterised the data type of the input and output lists, and we have parameterised the predicate used to test whether a given item should be kept or filtered out.</p>
<pre><code class="language-java">// T is declared as a "type parameter". We don't need to declare an output
// type because it is the same as the input type.
public static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; inputList, Predicate&lt;T&gt; pred) {
  List&lt;T&gt; outputList = new ArrayList&lt;&gt;();

  for (T current : inputList) {
    if (pred.test(current)) { // Use predicate to check the condition
      // If the predicate passes, save the current item
      outputList.add(current);
    }
  }

  return outputList;
}
</code></pre>
<p>In the code above, we use the <code>Predicate</code>'s <code>test</code> method to invoke the boolean function. If the <code>test</code> passes (i.e., it returns <code>true</code>), we save that list item to be returned in the output list.</p>
<h4 id="usage-examples-1"><a class="header" href="#usage-examples-1">Usage examples</a></h4>
<p>We can use our <code>filter</code> function to accomplish filter tasks like the example above.</p>
<pre><code class="language-java">List&lt;Integer&gt; scores = List.of(42, 39, 43, 44, 40, 37, 35);

// Filter down to scores less than 70% of 44
List&lt;Integer&gt; lessThan70Percent = filter(scores, s -&gt; s &lt; (0.7 * 44));

// Filter down to "A" scores (e.g., greater than 90%)
List&lt;Integer&gt; aScores = filter(scores, s -&gt; s &gt; (0.9 * 44));
</code></pre>
<p>The <strong>filter</strong> pattern is also an extremely common programming pattern, available "ready to use" on collections of data in most programming languages.</p>
<h2 id="consumer"><a class="header" href="#consumer">Consumer</a></h2>
<p>Finally, we will talk about the <code>Consumer</code>.
The <code>Consumer</code> is a functional interface used to define operations that have no outputs.</p>
<p>It defines one abstract method: <code>accept</code>. The method takes in one input and returns nothing, i.e., its return type is <code>void</code>.</p>
<p>Here are several examples of consumers:</p>
<p><strong>A consumer that takes in an album and cuts their prices by 10% (heck yeah, sale!).</strong></p>
<pre><code class="language-java">Consumer&lt;Album&gt; discount = album -&gt; album.setPrice(album.getPrice() * 0.9);
</code></pre>
<p><strong>A consumer that takes in a Student and increases the number of units they have completed by 12.</strong></p>
<pre><code class="language-java">Consumer&lt;Student&gt; increaseUnits = student -&gt; student.setUnits(student.getUnits() + 12);
</code></pre>
<h3 id="a-motivating-example-2"><a class="header" href="#a-motivating-example-2">A motivating example</a></h3>
<p>Just like <code>map</code> and <code>filter</code> are patterns for performing different types of operations on lists of data, a third pattern is also extremely common in programming.
And you're already familiar with this!</p>
<p>Consider the <code>for-each</code> loop — it loops over a collection of data, and performs some operation on each item in the list.</p>
<p>We could also write a <code>forEach</code> function that accomplishes this.</p>
<pre><code class="language-java">public static &lt;T&gt; void forEach(List&lt;T&gt; inputList, Consumer&lt;T&gt; consumer) {
  for (T current : inputList) {
    consumer.accept(current);
  }
}
</code></pre>
<p>We now have a function version of the <code>for-each</code> loop!</p>
<h2 id="other-functional-interfaces"><a class="header" href="#other-functional-interfaces">Other functional interfaces</a></h2>
<p>The <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/package-summary.html"><code>java.util.function</code> package</a> lists a number of functional interfaces, of which we have learned about 3 so far.</p>
<p>A key limiting factor in the <code>Function</code>, <code>Predicate</code>, and <code>Consumer</code> is that all of those lambdas can only take a single input.
We often need to write functions (or lambdas) that operate on multiple parameters.</p>
<p>The <code>Comparator</code> interface comes to mind — its <code>compare</code> function takes in two objects, the two objects being compared.</p>
<p>Among the other functions available in <code>java.util.function</code> are:</p>
<ul>
<li><code>BiFunction&lt;T, U, R&gt;</code> — A function that accepts two arguments and produces a result.</li>
<li><code>BiPredicate&lt;T, U&gt;</code> — A function that accepts two arguments and produces a boolean (or a predicate that accepts two arguments).</li>
<li><code>BiConsumer&lt;T, U&gt;</code> — An operation that accepts two input arguments and returns no result.</li>
<li><code>BinaryOperator&lt;T&gt;</code> — An operation upon two operands of the same type, producing a result of the same type as the operands. For example, arithmetic expressions like plus or minus, or boolean expressions like <strong>and</strong> and <strong>or</strong> are examples of binary operators.</li>
</ul>
<p>In many ways, the exact names of all the functional interfaces isn't what's most important.
In the next lesson, we will learn about <em>streams</em>, which allow us to express a series of operations to be performed on lists of data by chaining together calls to functions like <code>map</code>, <code>filter</code>, and <code>forEach</code>.
In these cases, lambdas are written inline as arguments to those functions themselves, and you rarely have to declare that a lambda is a <code>Function</code>, <code>BiFunction</code>, <code>Predicate</code>, etc.</p>
<p>For example, if you had a list of exam scores, and you wanted to:</p>
<ul>
<li>turn each score into a percentage</li>
<li>bump up each percentage by 5</li>
<li>round each percentage to the nearest whole number</li>
<li>filter down to the "A" scores</li>
</ul>
<p>You <em>could</em> do all of that in a for loop, or you could use lambdas and streams. Here's a sneak peak:</p>
<pre><code class="language-java">List&lt;Integer&gt; scores = List.of(42, 39, 43, 44, 40, 37, 35);

List&lt;Double&gt; scoresUpdated = scores.stream()
                                   .map(s -&gt; ((double) s / 44) * 100) // percentages
                                   .map(s -&gt; s + 5) // bump up
                                   .map(Math::round) // round the scores.
                                   .filter(s -&gt; s &gt;= 90) // filter to "A" scores
                                   .toList(); // get the final result list back
</code></pre>
<hr>
<ol class="footnote-definition"><li id="footnote-generics">
<p>This is an example of using <strong>Java generics</strong>. Generics allow you to declare <em>type parameters</em>, i.e, you can use placeholder names for data types, with the understanding that the placeholder will be replaced with an actual type when the code is invoked. This is identical to how you use "normal" parameters for methods and functions: you declare a variable name in the method signature, and when you call the function, that's when the variable actually gets a value. <a href="#fr-generics-1">↩</a></p>
</li>
</ol>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../14_comparators/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../16_streams/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../14_comparators/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../16_streams/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
